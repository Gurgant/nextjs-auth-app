<!doctype html>
<html lang="en">
  <head>
    <title>
      Code coverage report for src/generated/prisma/runtime/library.js
    </title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="../../../../favicon.png"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
      .coverage-summary .sorter {
        background-image: url(../../../../sort-arrow-sprite.png);
      }
    </style>
  </head>

  <body>
    <div class="wrapper">
      <div class="pad1">
        <h1>
          <a href="../../../../index.html">All files</a> /
          <a href="index.html">src/generated/prisma/runtime</a> library.js
        </h1>
        <div class="clearfix">
          <div class="fl pad1y space-right2">
            <span class="strong">37.13% </span>
            <span class="quiet">Statements</span>
            <span class="fraction">1707/4597</span>
          </div>

          <div class="fl pad1y space-right2">
            <span class="strong">21.41% </span>
            <span class="quiet">Branches</span>
            <span class="fraction">855/3992</span>
          </div>

          <div class="fl pad1y space-right2">
            <span class="strong">33.47% </span>
            <span class="quiet">Functions</span>
            <span class="fraction">463/1383</span>
          </div>

          <div class="fl pad1y space-right2">
            <span class="strong">64% </span>
            <span class="quiet">Lines</span>
            <span class="fraction">32/50</span>
          </div>
        </div>
        <p class="quiet">
          Press <em>n</em> or <em>j</em> to go to the next uncovered block,
          <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
          <div class="quiet">
            Filter:
            <input type="search" id="fileSearch" />
          </div>
        </template>
      </div>
      <div class="status-line low"></div>
      <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">992x</span>
<span class="cline-any cline-yes">22x</span>
<span class="cline-any cline-yes">161x</span>
<span class="cline-any cline-yes">21x</span>
<span class="cline-any cline-yes">952x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">22x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">801x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">63x</span>
<span class="cline-any cline-yes">19x</span>
<span class="cline-any cline-yes">146x</span>
<span class="cline-any cline-yes">626x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">782x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">54x</span>
<span class="cline-any cline-yes">53x</span>
<span class="cline-any cline-yes">40x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">436x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">78x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">&nbsp;
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
"use strict";var xu=Object.create;var Vt=Object.defineProperty;var vu=Object.getOwnPropertyDescriptor;var Pu=Object.getOwnPropertyNames;var Tu=Object.getPrototypeOf,Su=Object.prototype.hasOwnProperty;var Oo=(e,r)=&gt;()=&gt;(e&amp;&amp;(r=e(e=0)),r);var ne=(e,r)=&gt;()=&gt;(r||e((r={exports:{}}).exports,r),r.exports),tr=(e,r)=&gt;{for(var t in r)Vt(e,t,{get:r[t],enumerable:!0})},_o=(e,r,t,n)=&gt;{<span class="missing-if-branch" title="else path not taken" >E</span>if(r&amp;&amp;typeof r=="object"||typeof r=="function")for(let i of Pu(r))!Su.call(e,i)&amp;&amp;i!==t&amp;&amp;Vt(e,i,{get:()=&gt;r[i],enumerable:!(n=vu(r,i))||n.enumerable});return e};var C=(e,r,t)=&gt;(t=e!=null?xu(Tu(e)):<span class="branch-1 cbranch-no" title="branch not covered" >{},_</span>o(r||!e||!e.__esModule?Vt(t,"default",{value:e,enumerable:!0}):t,e)),Ru=e=&gt;_o(Vt({},"__esModule",{value:!0}),e);var yi=ne((Fg,ss)=&gt;{"use strict";ss.exports=(e,r=process.argv)=&gt;{let t=e.startsWith("-")?<span class="branch-0 cbranch-no" title="branch not covered" >"":e</span>.length===1?<span class="branch-0 cbranch-no" title="branch not covered" >"-":"</span>--",n=r.indexOf(t+e),i=r.indexOf("--");return n!==-1&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >i===-1||<span class="branch-2 cbranch-no" title="branch not covered" >n</span>&lt;i)}</span>});var us=ne((Mg,ls)=&gt;{"use strict";var jc=require("node:os"),as=require("node:tty"),de=yi(),{env:G}=process,Qe;de("no-color")||de("no-colors")||de("color=false")||de("color=never")?<span class="branch-0 cbranch-no" title="branch not covered" >Qe=0:(</span>de("color")||de("colors")||de("color=true")||de("color=always"))&amp;&amp;(<span class="branch-4 cbranch-no" title="branch not covered" >Qe=1);"</span>FORCE_COLOR"in G&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >G.FORCE_COLOR==="true"?Qe=1:G.FORCE_COLOR==="false"?Qe=0:Qe=G.FORCE_COLOR.length===0?1:Math.min(parseInt(G.FORCE_COLOR,10),3)</span>);function bi(e){return e===0?!1:<span class="branch-1 cbranch-no" title="branch not covered" >{level:e,hasBasic:!0,has256:e&gt;=2,has16m:e&gt;=3}}</span>function Ei(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(Qe===0)<span class="cstat-no" title="statement not covered" >return 0;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(de("color=16m")||de("color=full")||de("color=truecolor"))<span class="cstat-no" title="statement not covered" >return 3;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(de("color=256"))<span class="cstat-no" title="statement not covered" >return 2;<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(e&amp;&amp;!r&amp;&amp;Qe===void 0)return 0;let t=<span class="cstat-no" title="statement not covered" >Qe||0;<span class="cstat-no" title="statement not covered" >i</span>f(G.TERM==="dumb")<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(process.platform==="win32"){let n=<span class="cstat-no" title="statement not covered" >jc.release().split(".");<span class="cstat-no" title="statement not covered" >r</span>eturn Number(n[0])&gt;=10&amp;&amp;Number(n[2])&gt;=10586?Number(n[2])&gt;=14931?3:2:1}<span class="cstat-no" title="statement not covered" ></span>i</span>f("CI"in G)<span class="cstat-no" title="statement not covered" >return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span> in G)||G</span>.CI_NAME==="codeship"?1:t;<span class="cstat-no" title="statement not covered" >i</span></span>f("TEAMCITY_VERSION"in G)<span class="cstat-no" title="statement not covered" >return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION)?1:0;<span class="cstat-no" title="statement not covered" >i</span></span>f(G.COLORTERM==="truecolor")<span class="cstat-no" title="statement not covered" >return 3;<span class="cstat-no" title="statement not covered" >i</span></span>f("TERM_PROGRAM"in G){let n=<span class="cstat-no" title="statement not covered" >parseInt((G.TERM_PROGRAM_VERSION||"").split(".")[0],10);<span class="cstat-no" title="statement not covered" >s</span>witch(G.TERM_PROGRAM){case"iTerm.app":<span class="cstat-no" title="statement not covered" >return n&gt;=3?3:2;c</span>ase"Apple_Terminal":<span class="cstat-no" title="statement not covered" >return 2}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn/-256(color)?$/i.test(G.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM)||"COLORTERM"in G?1:t}</span>function Vc(e){let r=Ei(e,e&amp;&amp;e.isTTY);return bi(r)}ls.exports={supportsColor:Vc,stdout:bi(Ei(!0,as.isatty(1))),stderr:bi(Ei(!0,as.isatty(2)))}});var ds=ne(($g,ps)=&gt;{"use strict";var Bc=us(),br=yi();function <span class="fstat-no" title="function not covered" >cs(e</span>){<span class="cstat-no" title="statement not covered" >if(/^\d{3,4}$/.test(e)){let t=<span class="cstat-no" title="statement not covered" >/(\d{1,2})(\d{2})/.exec(e)||[];<span class="cstat-no" title="statement not covered" ></span>return{major:0,minor:parseInt(t[1],10),patch:parseInt(t[2],10)}}</span>l</span>et r=<span class="cstat-no" title="statement not covered" >(e||"").split(".").map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >p</span>arseInt(t,10));<span class="cstat-no" title="statement not covered" >r</span></span>eturn{major:r[0],minor:r[1],patch:r[2]}}</span>function wi(e){let{CI:r,FORCE_HYPERLINK:t,NETLIFY:n,TEAMCITY_VERSION:i,TERM_PROGRAM:o,TERM_PROGRAM_VERSION:s,VTE_VERSION:a,TERM:l}=process.env;<span class="missing-if-branch" title="if path not taken" >I</span>if(t)<span class="cstat-no" title="statement not covered" >return!(t.length&gt;0&amp;&amp;parseInt(t,10)===0);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(br("no-hyperlink")||br("no-hyperlinks")||br("hyperlink=false")||br("hyperlink=never"))<span class="cstat-no" title="statement not covered" >return!1;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(br("hyperlink=true")||br("hyperlink=always")||n)<span class="cstat-no" title="statement not covered" >return!0;<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(!Bc.supportsColor(e)||<span class="branch-1 cbranch-no" title="branch not covered" >e&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >!</span>e.isTTY)</span>return!1;<span class="cstat-no" title="statement not covered" >if("WT_SESSION"in process.env)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(process.platform==="win32"||r||i)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(o){let u=<span class="cstat-no" title="statement not covered" >cs(s||"");<span class="cstat-no" title="statement not covered" >s</span>witch(o){case"iTerm.app":<span class="cstat-no" title="statement not covered" >return u.major===3?u.minor&gt;=1:u.major&gt;3;c</span>ase"WezTerm":<span class="cstat-no" title="statement not covered" >return u.major&gt;=20200620;c</span>ase"vscode":<span class="cstat-no" title="statement not covered" >return u.major&gt;1||u.major===1&amp;&amp;u.minor&gt;=72;c</span>ase"ghostty":<span class="cstat-no" title="statement not covered" >return!0}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a){<span class="cstat-no" title="statement not covered" >if(a==="0.50.0")<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et u=<span class="cstat-no" title="statement not covered" >cs(a);<span class="cstat-no" title="statement not covered" >r</span>eturn u.major&gt;0||u.minor&gt;=50}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(l){<span class="branch-0 cbranch-no" title="branch not covered" >case"alacritty":<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>ps.exports={supportsHyperlink:wi,stdout:wi(process.stdout),stderr:wi(process.stderr)}});var ms=ne((zg,Uc)=&gt;{Uc.exports={name:"@prisma/internals",version:"6.13.0",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.5.0",esbuild:"0.25.5","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.13.0-35.361e86d0ea4987e9f53a565309b3eed797a6bcbd","@prisma/schema-engine-wasm":"6.13.0-35.361e86d0ea4987e9f53a565309b3eed797a6bcbd","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:"&gt;=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}});var Si=ne((bh,Kc)=&gt;{Kc.exports={name:"@prisma/engines-version",version:"6.13.0-35.361e86d0ea4987e9f53a565309b3eed797a6bcbd",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",prisma:{enginesVersion:"361e86d0ea4987e9f53a565309b3eed797a6bcbd"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var on=ne(nn=&gt;{"use strict";Object.defineProperty(nn,"__esModule",{value:!0});nn.enginesVersion=void 0;nn.enginesVersion=Si().prisma.enginesVersion});var bs=ne((Oh,ys)=&gt;{"use strict";ys.exports=<span class="fstat-no" title="function not covered" >e=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >e.match(/^[ \t]*(?=\S)/gm);<span class="cstat-no" title="statement not covered" >r</span>eturn r?r.reduce(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >Math.min(t,n.length),1</span>/0):0}</span>});var Di=ne((Lh,xs)=&gt;{"use strict";xs.exports=<span class="fstat-no" title="function not covered" >(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>t)=&gt;{<span class="cstat-no" title="statement not covered" >if(t={indent:" ",includeEmptyLines:!1,...t},typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof r!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof t.indent!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(r===0)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et n=<span class="cstat-no" title="statement not covered" >t.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;<span class="cstat-no" title="statement not covered" >r</span>eturn e.replace(n,t.indent.repeat(r))}</span>});var Ss=ne(($h,Ts)=&gt;{"use strict";Ts.exports=<span class="fstat-no" title="function not covered" >({</span>onlyFirst:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=&gt;&lt;~]))"].join("|");<span class="cstat-no" title="statement not covered" >r</span>eturn new RegExp(r,e?void 0:"g")}</span>});var Li=ne((qh,Rs)=&gt;{"use strict";var op=Ss();Rs.exports=<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof e=="string"?e.replace(op(),""):e}</span>);var As=ne((Uh,sp)=&gt;{sp.exports={name:"dotenv",version:"16.5.0",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard",pretest:"npm run lint &amp;&amp; npm run dts-check",test:"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},homepage:"https://github.com/motdotla/dotenv#readme",funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@types/node":"^18.11.3",decache:"^4.6.2",sinon:"^14.0.1",standard:"^17.0.0","standard-version":"^9.5.0",tap:"^19.2.0",typescript:"^4.8.4"},engines:{node:"&gt;=12"},browser:{fs:!1}}});var Os=ne((Gh,Le)=&gt;{"use strict";var Mi=require("node:fs"),$i=require("node:path"),ap=require("node:os"),lp=require("node:crypto"),up=As(),Is=up.version,cp=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function pp(e){let r={},t=e.toString();t=t.replace(/\r\n?/mg,`
`);let n;for(;(n=cp.exec(t))!=null;){let i=n[1],o=n[2]||<span class="branch-1 cbranch-no" title="branch not covered" >"";o</span>=o.trim();let s=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),s==='"'&amp;&amp;(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),r[i]=o}return r}function <span class="fstat-no" title="function not covered" >dp(e</span>){let r=<span class="cstat-no" title="statement not covered" >Ds(e),t</span>=<span class="cstat-no" title="statement not covered" >B.configDotenv({path:r});<span class="cstat-no" title="statement not covered" >i</span>f(!t.parsed){let s=<span class="cstat-no" title="statement not covered" >new Error(`MISSING_DATA: Cannot parse ${r} for an unknown reason`);<span class="cstat-no" title="statement not covered" >t</span>hrow s.code="MISSING_DATA",s}</span>l</span>et n=<span class="cstat-no" title="statement not covered" >ks(e).split(","),i</span>=<span class="cstat-no" title="statement not covered" >n.length,</span>o;<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;i;s++)<span class="cstat-no" title="statement not covered" >try{let a=<span class="cstat-no" title="statement not covered" >n[s].trim(),l</span>=<span class="cstat-no" title="statement not covered" >fp(t,a);<span class="cstat-no" title="statement not covered" >o</span>=B.decrypt(l.ciphertext,l.key);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>catch(a){<span class="cstat-no" title="statement not covered" >if(s+1&gt;=i)<span class="cstat-no" title="statement not covered" >throw a}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn B.parse(o)}</span>function <span class="fstat-no" title="function not covered" >mp(e</span>){<span class="cstat-no" title="statement not covered" >console.log(`[dotenv@${Is}][WARN] ${e}`)}</span>function <span class="fstat-no" title="function not covered" >ot(e</span>){<span class="cstat-no" title="statement not covered" >console.log(`[dotenv@${Is}][DEBUG] ${e}`)}</span>function ks(e){return e&amp;&amp;e.DOTENV_KEY&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.DOTENV_KEY.length&gt;0?<span class="branch-0 cbranch-no" title="branch not covered" >e</span>.DOTENV_KEY:</span>process.env.DOTENV_KEY&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >process.env.DOTENV_KEY.length&gt;0?<span class="branch-0 cbranch-no" title="branch not covered" >p</span>rocess.env.DOTENV_KEY:</span>""}function <span class="fstat-no" title="function not covered" >fp(e</span>,r){let t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=new URL(r)}</span>catch(a){<span class="cstat-no" title="statement not covered" >if(a.code==="ERR_INVALID_URL"){let l=<span class="cstat-no" title="statement not covered" >new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");<span class="cstat-no" title="statement not covered" >t</span>hrow l.code="INVALID_DOTENV_KEY",l}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow a}</span>l</span>et n=<span class="cstat-no" title="statement not covered" >t.password;<span class="cstat-no" title="statement not covered" ></span>if(!n){let a=<span class="cstat-no" title="statement not covered" >new Error("INVALID_DOTENV_KEY: Missing key part");<span class="cstat-no" title="statement not covered" >t</span>hrow a.code="INVALID_DOTENV_KEY",a}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >t.searchParams.get("environment");<span class="cstat-no" title="statement not covered" >i</span>f(!i){let a=<span class="cstat-no" title="statement not covered" >new Error("INVALID_DOTENV_KEY: Missing environment part");<span class="cstat-no" title="statement not covered" >t</span>hrow a.code="INVALID_DOTENV_KEY",a}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >`DOTENV_VAULT_${i.toUpperCase()}`,</span>s=<span class="cstat-no" title="statement not covered" >e.parsed[o];<span class="cstat-no" title="statement not covered" ></span>if(!s){let a=<span class="cstat-no" title="statement not covered" >new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);<span class="cstat-no" title="statement not covered" >t</span>hrow a.code="NOT_FOUND_DOTENV_ENVIRONMENT",a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{ciphertext:s,key:n}}</span>function <span class="fstat-no" title="function not covered" >Ds(e</span>){let r=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" >i</span>f(e&amp;&amp;e.path&amp;&amp;e.path.length&gt;0)<span class="cstat-no" title="statement not covered" >if(Array.isArray(e.path))<span class="cstat-no" title="statement not covered" >for(let t of e.path)<span class="cstat-no" title="statement not covered" >Mi.existsSync(t)&amp;&amp;(r=t.endsWith(".vault")?t:`${t}.vault`)</span></span>;else <span class="cstat-no" title="statement not covered" >r=e.path.endsWith(".vault")?e.path:`${e.path}.vault`;else <span class="cstat-no" title="statement not covered" >r</span></span>=$i.resolve(process.cwd(),".env.vault");<span class="cstat-no" title="statement not covered" >r</span></span>eturn Mi.existsSync(r)?r:null}</span>function Cs(e){return e[0]==="~"?<span class="branch-0 cbranch-no" title="branch not covered" >$i.join(ap.homedir(),e.slice(1)):e</span>}function <span class="fstat-no" title="function not covered" >gp(e</span>){<span class="cstat-no" title="statement not covered" >!!(e&amp;&amp;e.debug)&amp;&amp;ot("Loading env from encrypted .env.vault");l</span>et t=<span class="cstat-no" title="statement not covered" >B._parseVault(e),n</span>=<span class="cstat-no" title="statement not covered" >process.env;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;e.processEnv!=null&amp;&amp;(n=e.processEnv),B.populate(n,t,e),{parsed:t}}</span>function hp(e){let r=$i.resolve(process.cwd(),".env"),t="utf8",n=!!(e&amp;&amp;e.debug);e&amp;&amp;e.encoding?<span class="branch-0 cbranch-no" title="branch not covered" >t=e.encoding:</span>n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >ot("No encoding is specified. UTF-8 is used by default");l</span>et i=[r];<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.path)if(!Array.isArray(e.path))i=[Cs(e.path)];else<span class="missing-if-branch" title="else path not taken" >E</span>{<span class="cstat-no" title="statement not covered" >i=[];<span class="cstat-no" title="statement not covered" >f</span>or(let l of e.path)<span class="cstat-no" title="statement not covered" >i.push(Cs(l))}</span></span>let o,s={};for(let l of i)try{let u=B.parse(Mi.readFileSync(l,{encoding:t}));B.populate(s,u,e)}catch(u){<span class="cstat-no" title="statement not covered" >n&amp;&amp;ot(`Failed to load ${l} ${u.message}`),o=u}</span>let a=process.env;return e&amp;&amp;e.processEnv!=null&amp;&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >a=e.processEnv)</span>,B.populate(a,s,e),o?<span class="branch-0 cbranch-no" title="branch not covered" >{parsed:s,error:o}:{</span>parsed:s}}function yp(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(ks(e).length===0)return B.configDotenv(e);let r=<span class="cstat-no" title="statement not covered" >Ds(e);<span class="cstat-no" title="statement not covered" >r</span>eturn r?B._configVault(e):(mp(`You set DOTENV_KEY but you are missing a .env.vault file at ${r}. Did you forget to build it?`),B.configDotenv(e))}</span>function <span class="fstat-no" title="function not covered" >bp(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >Buffer.from(r.slice(-64),"hex"),n</span>=<span class="cstat-no" title="statement not covered" >Buffer.from(e,"base64"),i</span>=<span class="cstat-no" title="statement not covered" >n.subarray(0,12),o</span>=<span class="cstat-no" title="statement not covered" >n.subarray(-16);<span class="cstat-no" title="statement not covered" >n</span>=n.subarray(12,-16);<span class="cstat-no" title="statement not covered" >t</span>ry{let s=<span class="cstat-no" title="statement not covered" >lp.createDecipheriv("aes-256-gcm",t,i);<span class="cstat-no" title="statement not covered" >r</span>eturn s.setAuthTag(o),`${s.update(n)}${s.final()}`}c</span>atch(s){let a=<span class="cstat-no" title="statement not covered" >s instanceof RangeError,l</span>=<span class="cstat-no" title="statement not covered" >s.message==="Invalid key length",u</span>=<span class="cstat-no" title="statement not covered" >s.message==="Unsupported state or unable to authenticate data";<span class="cstat-no" title="statement not covered" >i</span>f(a||l){let c=<span class="cstat-no" title="statement not covered" >new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");<span class="cstat-no" title="statement not covered" >t</span>hrow c.code="INVALID_DOTENV_KEY",c}</span>else <span class="cstat-no" title="statement not covered" >if(u){let c=<span class="cstat-no" title="statement not covered" >new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");<span class="cstat-no" title="statement not covered" >t</span>hrow c.code="DECRYPTION_FAILED",c}</span>else <span class="cstat-no" title="statement not covered" >throw s}</span></span></span>}</span>function Ep(e,r,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let n=!!(t&amp;&amp;t.debug),i=!!(t&amp;&amp;t.override);<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof r!="object"){let o=<span class="cstat-no" title="statement not covered" >new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");<span class="cstat-no" title="statement not covered" >t</span>hrow o.code="OBJECT_REQUIRED",o}</span>for(let o of Object.keys(r))Object.prototype.hasOwnProperty.call(e,o)?(i===!0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e[o]=r[o])</span>,n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >ot(i===!0?`"${o}" is already defined and WAS overwritten`:`"${o}" is already defined and was NOT overwritten`)):e</span>[o]=r[o]}var B={configDotenv:hp,_configVault:gp,_parseVault:dp,config:yp,decrypt:bp,parse:pp,populate:Ep};Le.exports.configDotenv=B.configDotenv;Le.exports._configVault=B._configVault;Le.exports._parseVault=B._parseVault;Le.exports.config=B.config;Le.exports.decrypt=B.decrypt;Le.exports.parse=B.parse;Le.exports.populate=B.populate;Le.exports=B});var Fs=ne((Yh,cn)=&gt;{"use strict";cn.exports=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r;<span class="cstat-no" title="statement not covered" >if(e.repoUrl)<span class="cstat-no" title="statement not covered" >r=e.repoUrl;else <span class="cstat-no" title="statement not covered" >i</span>f(e.user&amp;&amp;e.repo)<span class="cstat-no" title="statement not covered" >r=`https://github.com/${e.user}/${e.repo}`;else <span class="cstat-no" title="statement not covered" >t</span>hrow new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");l</span></span></span>et t=<span class="cstat-no" title="statement not covered" >new URL(`${r}/issues/new`),n</span>=<span class="cstat-no" title="statement not covered" >["body","title","labels","template","milestone","assignee","projects"];<span class="cstat-no" title="statement not covered" >f</span>or(let i of n){let o=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>if(o!==void 0){<span class="cstat-no" title="statement not covered" >if(i==="labels"||i==="projects"){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(o))<span class="cstat-no" title="statement not covered" >throw new TypeError(`The \`${i}\` option should be an array`);<span class="cstat-no" title="statement not covered" >o</span></span>=o.join(",")}<span class="cstat-no" title="statement not covered" ></span>t</span>.searchParams.set(i,o)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.toString()}</span>;cn.exports.default=cn.exports});var Ki=ne((Ab,oa)=&gt;{"use strict";oa.exports=function(){function <span class="fstat-no" title="function not covered" >e(r</span>,t,n,i,o){<span class="cstat-no" title="statement not covered" >return r&lt;t||n&lt;t?r&gt;n?n+1:r+1:i===o?t:t+1}</span>return <span class="fstat-no" title="function not covered" >function(r</span>,t){<span class="cstat-no" title="statement not covered" >if(r===t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.length&gt;t.length){var n=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" >r</span>=t,t=n}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >r.length,</span>o=<span class="cstat-no" title="statement not covered" >t.length;</span>i&gt;0&amp;&amp;r.charCodeAt(i-1)===t.charCodeAt(o-1);)<span class="cstat-no" title="statement not covered" >i--,o--;<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;i&amp;&amp;r.charCodeAt(s)===t.charCodeAt(s);)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >i</span></span>f(i-=s,o-=s,i===0||o&lt;3)<span class="cstat-no" title="statement not covered" >return o;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >0,l</span>,u,c,p,d,f,h,g,S,P,R,b,D=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(l=0;l&lt;i;l++)<span class="cstat-no" title="statement not covered" >D.push(l+1),D.push(r.charCodeAt(s+l));<span class="cstat-no" title="statement not covered" >f</span></span>or(var me=<span class="cstat-no" title="statement not covered" >D.length-1;a</span>&lt;o-3;)<span class="cstat-no" title="statement not covered" >for(S=t.charCodeAt(s+(u=a)),P=t.charCodeAt(s+(c=a+1)),R=t.charCodeAt(s+(p=a+2)),b=t.charCodeAt(s+(d=a+3)),f=a+=4,l=0;l&lt;me;l+=2)<span class="cstat-no" title="statement not covered" >h=D[l],g=D[l+1],u=e(h,u,c,S,g),c=e(u,c,p,P,g),p=e(c,p,d,R,g),f=e(p,d,f,b,g),D[l]=f,d=p,p=c,c=u,u=h;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;a&lt;o;)<span class="cstat-no" title="statement not covered" >for(S=t.charCodeAt(s+(u=a)),f=++a,l=0;l&lt;me;l+=2)<span class="cstat-no" title="statement not covered" >h=D[l],D[l]=f=e(h,u,f,S,D[l+1]),u=h;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn f}</span>}()});var ca=Oo(()=&gt;{"use strict"});var pa=Oo(()=&gt;{"use strict"});var Gf={};tr(Gf,{DMMF:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >c</span>t,D</span>ebug:()=&gt;N,Decimal:()=&gt;ve,Extensions:()=&gt;ii,MetricsClient:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >F</span>r,P</span>rismaClientInitializationError:()=&gt;T,PrismaClientKnownRequestError:()=&gt;z,PrismaClientRustPanicError:()=&gt;le,PrismaClientUnknownRequestError:()=&gt;j,PrismaClientValidationError:()=&gt;Z,Public:()=&gt;oi,Sql:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >o</span>e,c</span>reateParam:()=&gt;Aa,defineDmmfProperty:()=&gt;_a,deserializeJsonResponse:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >T</span>r,d</span>eserializeRawResult:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>i,d</span>mmfToRuntimeDataModel:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >X</span>s,e</span>mpty:()=&gt;Fa,getPrismaClient:()=&gt;bu,getRuntime:()=&gt;Gn,join:()=&gt;La,makeStrictEnum:()=&gt;Eu,makeTypedQueryFactory:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >N</span>a,o</span>bjectEnumValues:()=&gt;kn,raw:()=&gt;io,serializeJsonQuery:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >M</span>n,s</span>kip:()=&gt;Fn,sqltag:()=&gt;oo,warnEnvConflicts:()=&gt;wu,warnOnce:()=&gt;at});module.exports=Ru(Gf);var ii={};tr(ii,{defineExtension:()=&gt;No,getExtensionContext:()=&gt;Lo});function <span class="fstat-no" title="function not covered" >No(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="function"?e:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.$extends(e)}</span></span>function <span class="fstat-no" title="function not covered" >Lo(e</span>){<span class="cstat-no" title="statement not covered" >return e}</span>var oi={};tr(oi,{validator:()=&gt;Fo});function <span class="fstat-no" title="function not covered" >Fo(.</span>..e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>}</span></span>var Bt={};tr(Bt,{$:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >V</span>o,b</span>gBlack:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >F</span>u,b</span>gBlue:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >j</span>u,b</span>gCyan:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >B</span>u,b</span>gGreen:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >$</span>u,b</span>gMagenta:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >V</span>u,b</span>gRed:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >M</span>u,b</span>gWhite:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >U</span>u,b</span>gYellow:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >q</span>u,b</span>lack:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>u,b</span>lue:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>r,b</span>old:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >W</span>,c</span>yan:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >D</span>e,d</span>im:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >I</span>e,g</span>ray:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >K</span>r,g</span>reen:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >q</span>e,g</span>rey:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >L</span>u,h</span>idden:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >k</span>u,i</span>nverse:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >I</span>u,i</span>talic:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >C</span>u,m</span>agenta:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >_</span>u,r</span>ed:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >c</span>e,r</span>eset:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >A</span>u,s</span>trikethrough:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >D</span>u,u</span>nderline:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >Y</span>,w</span>hite:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >N</span>u,y</span>ellow:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >k</span>e}</span>);var si,Mo,$o,qo,jo=!0;typeof process&lt;"u"&amp;&amp;({FORCE_COLOR:si,NODE_DISABLE_COLORS:Mo,NO_COLOR:$o,TERM:qo}=process.env||<span class="branch-1 cbranch-no" title="branch not covered" >{},j</span>o=process.stdout&amp;&amp;process.stdout.isTTY);var Vo={enabled:!Mo&amp;&amp;$o==null&amp;&amp;qo!=="dumb"&amp;&amp;(si!=null&amp;&amp;<span class="branch-4 cbranch-no" title="branch not covered" >si!=="0"||j</span>o)};function F(e,r){let t=new RegExp(`\\x1b\\[${r}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${r}m`;return function(o){return!Vo.enabled||<span class="branch-1 cbranch-no" title="branch not covered" >o==null?o</span>:<span class="branch-1 cbranch-no" title="branch not covered" >n+(~(""+o).indexOf(i)?o.replace(t,i+n):o)+i}</span>}var Au=F(0,0),W=F(1,22),Ie=F(2,22),Cu=F(3,23),Y=F(4,24),Iu=F(7,27),ku=F(8,28),Du=F(9,29),Ou=F(30,39),ce=F(31,39),qe=F(32,39),ke=F(33,39),nr=F(34,39),_u=F(35,39),De=F(36,39),Nu=F(37,39),Kr=F(90,39),Lu=F(90,39),Fu=F(40,49),Mu=F(41,49),$u=F(42,49),qu=F(43,49),ju=F(44,49),Vu=F(45,49),Bu=F(46,49),Uu=F(47,49);var Gu=100,Bo=["green","yellow","blue","magenta","cyan","red"],Yr=[],Uo=Date.now(),Qu=0,ai=typeof process&lt;"u"?process.env:<span class="branch-1 cbranch-no" title="branch not covered" >{};g</span>lobalThis.DEBUG??=ai.DEBUG??"";globalThis.DEBUG_COLORS??=ai.DEBUG_COLORS?<span class="branch-0 cbranch-no" title="branch not covered" >ai.DEBUG_COLORS==="true":!</span>0;var zr={<span class="fstat-no" title="function not covered" >enable(e</span>){<span class="cstat-no" title="statement not covered" >typeof e=="string"&amp;&amp;(globalThis.DEBUG=e)}</span>,<span class="fstat-no" title="function not covered" >disable(){l</span>et e=<span class="cstat-no" title="statement not covered" >globalThis.DEBUG;<span class="cstat-no" title="statement not covered" ></span>return globalThis.DEBUG="",e}</span>,enabled(e){let r=globalThis.DEBUG.split(",").map(i=&gt;i.replace(/[.+?^${}()|[\]\\]/g,"\\$&amp;")),t=r.some(i=&gt;i===""||<span class="branch-1 cbranch-no" title="branch not covered" >i[0]==="-"?!</span>1:<span class="branch-1 cbranch-no" title="branch not covered" >e.match(RegExp(i.split("*").join(".*")+"$"))),n</span>=r.some(i=&gt;i===""||<span class="branch-1 cbranch-no" title="branch not covered" >i[0]!=="-"?!</span>1:<span class="branch-1 cbranch-no" title="branch not covered" >e.match(RegExp(i.slice(1).split("*").join(".*")+"$")));r</span>eturn t&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!n}</span>,log:<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;{let[r,t,...n]=<span class="cstat-no" title="statement not covered" >e;(<span class="cstat-no" title="statement not covered" >c</span>onsole.warn??console.log)(`${r} ${t}`,...n)}</span>,formatters:{}};function Wu(e){let r={color:Bo[Qu++%Bo.length],enabled:zr.enabled(e),namespace:e,log:zr.log,extend:<span class="fstat-no" title="function not covered" >()=&gt;{}</span>},t=(...n)=&gt;{let{enabled:i,namespace:o,color:s,log:a}=r;<span class="missing-if-branch" title="if path not taken" >I</span>if(n.length!==0&amp;&amp;Yr.push([o,...n]),Yr.length&gt;Gu&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Yr.shift(),z</span>r.enabled(o)||i){let l=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >c=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof c=="string"?c:Ju(c)),u</span></span>=<span class="cstat-no" title="statement not covered" >`+${Date.now()-Uo}ms`;<span class="cstat-no" title="statement not covered" ></span>Uo=Date.now(),globalThis.DEBUG_COLORS?a(Bt[s](W(o)),...l,Bt[s](u)):a(o,...l,u)}</span>};return new Proxy(t,{get:<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >r[i],</span>set:<span class="fstat-no" title="function not covered" >(n</span>,i,o)=&gt;<span class="cstat-no" title="statement not covered" >r[i]=o}</span>)}var N=new Proxy(Wu,{get:(e,r)=&gt;zr[r],set:<span class="fstat-no" title="function not covered" >(e</span>,r,t)=&gt;<span class="cstat-no" title="statement not covered" >zr[r]=t}</span>);function <span class="fstat-no" title="function not covered" >Ju(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >2)</span>{let t=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" >r</span>eturn JSON.stringify(e,<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof i=="object"&amp;&amp;i!==null){<span class="cstat-no" title="statement not covered" >if(t.has(i))<span class="cstat-no" title="statement not covered" >return"[Circular *]";<span class="cstat-no" title="statement not covered" >t</span></span>.add(i)}</span>else <span class="cstat-no" title="statement not covered" >if(typeof i=="bigint")<span class="cstat-no" title="statement not covered" >return i.toString();<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>,r)}</span>function <span class="fstat-no" title="function not covered" >Go(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >7500)</span>{let r=<span class="cstat-no" title="statement not covered" >Yr.map(<span class="fstat-no" title="function not covered" >([</span>t,...n])=&gt;<span class="cstat-no" title="statement not covered" >`${t} ${n.map(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof i=="string"?i:JSON.stringify(i)).j</span>oin(" ")}`)</span>.join(`</span>
`);<span class="cstat-no" title="statement not covered" >return r.length&lt;e?r:r.slice(-e)}</span>function Qo(){Yr.length=0}var gr=N;var Wo=C(require("node:fs"));function li(){let e=process.env.PRISMA_QUERY_ENGINE_LIBRARY;<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Wo.default.existsSync(e)</span>)&amp;&amp;process.arch==="ia32")<span class="cstat-no" title="statement not covered" >throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)')}</span>var ui=["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];var Ut="libquery_engine";function Gt(e,r){let t=r==="url";return e.includes("windows")?<span class="branch-0 cbranch-no" title="branch not covered" >t?"query_engine.dll.node":`query_engine-${e}.dll.node`:</span>e.includes("darwin")?<span class="branch-0 cbranch-no" title="branch not covered" >t?`${Ut}.dylib.node`:`${Ut}-${e}.dylib.node`:</span>t?<span class="branch-0 cbranch-no" title="branch not covered" >`${Ut}.so.node`:</span>`${Ut}-${e}.so.node`}var Yo=C(require("node:child_process")),fi=C(require("node:fs/promises")),Kt=C(require("node:os"));var Oe=Symbol.for("@ts-pattern/matcher"),Hu=Symbol.for("@ts-pattern/isVariadic"),Wt="@ts-pattern/anonymous-select-key",ci=e=&gt;!!(e&amp;&amp;typeof e=="object"),Qt=e=&gt;e&amp;&amp;!!e[Oe],Ee=(e,r,t)=&gt;{<span class="missing-if-branch" title="if path not taken" >I</span>if(Qt(e)){let n=<span class="cstat-no" title="statement not covered" >e[Oe](),{</span>matched:i,selections:o}=<span class="cstat-no" title="statement not covered" >n.match(r);<span class="cstat-no" title="statement not covered" >r</span>eturn i&amp;&amp;o&amp;&amp;Object.keys(o).forEach(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >t</span>(s,o[s])),i</span>}</span>if(ci(e)){<span class="missing-if-branch" title="if path not taken" >I</span>if(!ci(r))<span class="cstat-no" title="statement not covered" >return!1;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(Array.isArray(e)){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(r))<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et n=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let s of e.keys()){let a=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>Qt(a)&amp;&amp;a[Hu]?o.push(a):o.length?i.push(a):n.push(a)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o.length){<span class="cstat-no" title="statement not covered" >if(o.length&gt;1)<span class="cstat-no" title="statement not covered" >throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");<span class="cstat-no" title="statement not covered" >i</span></span>f(r.length&lt;n.length+i.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et s=<span class="cstat-no" title="statement not covered" >r.slice(0,n.length),a</span>=<span class="cstat-no" title="statement not covered" >i.length===0?[]:r.slice(-i.length),l</span>=<span class="cstat-no" title="statement not covered" >r.slice(n.length,i.length===0?1/0:-i.length);<span class="cstat-no" title="statement not covered" >r</span>eturn n.every(<span class="fstat-no" title="function not covered" >(u</span>,c)=&gt;<span class="cstat-no" title="statement not covered" >Ee(u,s[c],t))&amp;&amp;i</span>.every(<span class="fstat-no" title="function not covered" >(u</span>,c)=&gt;<span class="cstat-no" title="statement not covered" >Ee(u,a[c],t))&amp;&amp;(o</span>.length===0||Ee(o[0],l,t))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.length===r.length&amp;&amp;e.every(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >Ee(s,r[a],t))}</span></span>return Reflect.ownKeys(e).every(n=&gt;{let i=e[n];return(n in r||<span class="branch-1 cbranch-no" title="branch not covered" >Qt(o=i)&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >o</span>[Oe]().matcherType==="optional"</span>)&amp;&amp;Ee(i,r[n],t);var o})}return Object.is(r,e)},Ge=<span class="fstat-no" title="function not covered" >e=&gt;{v</span>ar r,t,n;<span class="cstat-no" title="statement not covered" >return ci(e)?Qt(e)?(r=(t=(n=e[Oe]()).getSelectionKeys)==null?void 0:t.call(n))!=null?r:[]:Array.isArray(e)?Zr(e,Ge):Zr(Object.values(e),Ge):[]},Z</span>r=<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.reduce(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >t.concat(r(n)),[</span>]);f</span>unction pe(e){return Object.assign(e,{optional:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >K</span>u(e),a</span>nd:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >q</span>(e,r),o</span>r:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >Y</span>u(e,r),s</span>elect:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>===void 0?Jo(e):Jo(r,e)}</span>)}function <span class="fstat-no" title="function not covered" >Ku(e</span>){<span class="cstat-no" title="statement not covered" >return pe({[Oe]:<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >{</span>match:<span class="fstat-no" title="function not covered" >r=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >{},n</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;{<span class="cstat-no" title="statement not covered" >t[i]=o}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn r===void 0?(Ge(e).forEach(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >n</span>(i,void 0)),{</span>matched:!0,selections:t}):{matched:Ee(e,r,n),selections:t}}</span>,getSelectionKeys:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >G</span>e(e),m</span>atcherType:"optional"})}</span>)}</span>function <span class="fstat-no" title="function not covered" >q(.</span>..e){<span class="cstat-no" title="statement not covered" >return pe({[Oe]:<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >{</span>match:<span class="fstat-no" title="function not covered" >r=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >{},n</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;{<span class="cstat-no" title="statement not covered" >t[i]=o}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn{matched:e.every(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >E</span>e(i,r,n)),s</span>elections:t}}</span>,getSelectionKeys:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >Z</span>r(e,Ge),m</span>atcherType:"and"})}</span>)}</span>function <span class="fstat-no" title="function not covered" >Yu(.</span>..e){<span class="cstat-no" title="statement not covered" >return pe({[Oe]:<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >{</span>match:<span class="fstat-no" title="function not covered" >r=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >{},n</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;{<span class="cstat-no" title="statement not covered" >t[i]=o}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn Zr(e,Ge).forEach(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >n</span>(i,void 0)),{</span>matched:e.some(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >E</span>e(i,r,n)),s</span>elections:t}}</span>,getSelectionKeys:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >Z</span>r(e,Ge),m</span>atcherType:"or"})}</span>)}</span>function I(e){return{[Oe]:<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >{</span>match:<span class="fstat-no" title="function not covered" >r=&gt;(<span class="cstat-no" title="statement not covered" >{</span>matched:!!e(r)})}</span>)}</span>}function <span class="fstat-no" title="function not covered" >Jo(.</span>..e){let r=<span class="cstat-no" title="statement not covered" >typeof e[0]=="string"?e[0]:void 0,t</span>=<span class="cstat-no" title="statement not covered" >e.length===2?e[1]:typeof e[0]=="string"?void 0:e[0];<span class="cstat-no" title="statement not covered" ></span>return pe({[Oe]:<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >{</span>match:<span class="fstat-no" title="function not covered" >n=&gt;{l</span>et i=<span class="cstat-no" title="statement not covered" >{[r??Wt]:n};<span class="cstat-no" title="statement not covered" >r</span>eturn{matched:t===void 0||Ee(t,n,<span class="fstat-no" title="function not covered" >(o</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >i[o]=s}</span>),selections:i}}</span>,getSelectionKeys:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >[</span>r??Wt].concat(t===void 0?[]:Ge(t))}</span>)}</span>)}</span>function <span class="fstat-no" title="function not covered" >ye(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="number"}</span>function <span class="fstat-no" title="function not covered" >je(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="string"}</span>function <span class="fstat-no" title="function not covered" >Ve(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="bigint"}</span>var ng=pe(I(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return!0}</span>));var Be=e=&gt;Object.assign(pe(e),{startsWith:<span class="fstat-no" title="function not covered" >r=&gt;{<span class="cstat-no" title="statement not covered" >r</span>eturn Be(q(e,(t=r,I(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >j</span>e(n)&amp;&amp;n.startsWith(t))</span>)));v</span>ar t},endsWith:<span class="fstat-no" title="function not covered" >r=&gt;{<span class="cstat-no" title="statement not covered" >r</span>eturn Be(q(e,(t=r,I(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >j</span>e(n)&amp;&amp;n.endsWith(t))</span>)));v</span>ar t},minLength:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >B</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >j</span>e(n)&amp;&amp;n.length&gt;=t)</span></span>)(r))),l</span>ength:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >B</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >j</span>e(n)&amp;&amp;n.length===t)</span></span>)(r))),m</span>axLength:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >B</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >j</span>e(n)&amp;&amp;n.length&lt;=t)</span></span>)(r))),i</span>ncludes:<span class="fstat-no" title="function not covered" >r=&gt;{<span class="cstat-no" title="statement not covered" >r</span>eturn Be(q(e,(t=r,I(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >j</span>e(n)&amp;&amp;n.includes(t))</span>)));v</span>ar t},regex:<span class="fstat-no" title="function not covered" >r=&gt;{<span class="cstat-no" title="statement not covered" >r</span>eturn Be(q(e,(t=r,I(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >j</span>e(n)&amp;&amp;!!n.match(t))</span>)));v</span>ar t}}),ig=Be(I(je)),be=e=&gt;Object.assign(pe(e),{between:<span class="fstat-no" title="function not covered" >(r</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >be(q(e,(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o)</span></span>)(r,t))),l</span>t:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >b</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(n)&amp;&amp;n&lt;t)</span></span>)(r))),g</span>t:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >b</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(n)&amp;&amp;n&gt;t)</span></span>)(r))),l</span>te:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >b</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(n)&amp;&amp;n&lt;=t)</span></span>)(r))),g</span>te:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >b</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(n)&amp;&amp;n&gt;=t)</span></span>)(r))),i</span>nt:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >b</span>e(q(e,I(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(r)&amp;&amp;Number.isInteger(r)))),f</span></span>inite:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >b</span>e(q(e,I(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(r)&amp;&amp;Number.isFinite(r)))),p</span></span>ositive:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >b</span>e(q(e,I(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(r)&amp;&amp;r&gt;0))),n</span></span>egative:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >b</span>e(q(e,I(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >y</span>e(r)&amp;&amp;r&lt;0)))}</span></span>),og=be(I(ye)),Ue=e=&gt;Object.assign(pe(e),{between:<span class="fstat-no" title="function not covered" >(r</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >Ue(q(e,(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >V</span>e(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o)</span></span>)(r,t))),l</span>t:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >U</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >V</span>e(n)&amp;&amp;n&lt;t)</span></span>)(r))),g</span>t:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >U</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >V</span>e(n)&amp;&amp;n&gt;t)</span></span>)(r))),l</span>te:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >U</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >V</span>e(n)&amp;&amp;n&lt;=t)</span></span>)(r))),g</span>te:<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >U</span>e(q(e,(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >I</span>(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >V</span>e(n)&amp;&amp;n&gt;=t)</span></span>)(r))),p</span>ositive:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >U</span>e(q(e,I(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >V</span>e(r)&amp;&amp;r&gt;0))),n</span></span>egative:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >U</span>e(q(e,I(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >V</span>e(r)&amp;&amp;r&lt;0)))}</span></span>),sg=Ue(I(Ve)),ag=pe(I(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="boolean"}</span>)),lg=pe(I(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="symbol"}</span>)),ug=pe(I(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return e==null}</span>)),cg=pe(I(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return e!=null}</span>));var pi=class extends Error{<span class="fstat-no" title="function not covered" >constructor(r</span>){let t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=JSON.stringify(r)}</span>catch{<span class="cstat-no" title="statement not covered" >t=r}<span class="cstat-no" title="statement not covered" ></span>s</span>uper(`Pattern matching error: no pattern matches value ${t}`),this.input=void 0,this.input=r}</span>},di={matched:!1,value:void 0};function hr(e){return new mi(e,di)}var mi=class e{constructor(r,t){this.input=void 0,this.state=void 0,this.input=r,this.state=t}with(...r){if(this.state.matched)return this;let t=r[r.length-1],n=[r[0]],i;r.length===3&amp;&amp;typeof r[1]=="function"?<span class="branch-0 cbranch-no" title="branch not covered" >i=r[1]:</span>r.length&gt;2&amp;&amp;n.push(...r.slice(1,r.length-1));let o=!1,s={},a=<span class="fstat-no" title="function not covered" >(u</span>,c)=&gt;{<span class="cstat-no" title="statement not covered" >o=!0,s[u]=c}</span>,l=!n.some(u=&gt;Ee(u,this.input,a))||i&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >!i(this.input)?d</span>i:{matched:!0,value:t(o?<span class="branch-0 cbranch-no" title="branch not covered" >Wt in s?s[Wt]:s:t</span>his.input,this.input)};return new e(this.input,l)}when(r,t){<span class="missing-if-branch" title="else path not taken" >E</span>if(this.state.matched)return this;let n=<span class="cstat-no" title="statement not covered" >!!r(this.input);<span class="cstat-no" title="statement not covered" >r</span>eturn new e(this.input,n?{matched:!0,value:t(this.input,this.input)}:di)}</span>otherwise(r){return this.state.matched?this.state.value:<span class="branch-1 cbranch-no" title="branch not covered" >r(this.input)}<span class="fstat-no" title="function not covered" ></span>exhaustive(){<span class="cstat-no" title="statement not covered" ></span>if(this.state.matched)<span class="cstat-no" title="statement not covered" >return this.state.value;<span class="cstat-no" title="statement not covered" >t</span></span>hrow new pi(this.input)}<span class="fstat-no" title="function not covered" ></span>run(){<span class="cstat-no" title="statement not covered" ></span>return this.exhaustive()}<span class="fstat-no" title="function not covered" ></span>returnType(){<span class="cstat-no" title="statement not covered" ></span>return this}}</span>;var zo=require("node:util");var zu={warn:ke("prisma:warn")},Zu={warn:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>process.env.PRISMA_DISABLE_WARNINGS}</span>;function <span class="fstat-no" title="function not covered" >Jt(e</span>,...r){<span class="cstat-no" title="statement not covered" >Zu.warn()&amp;&amp;console.warn(`${zu.warn} ${e}`,...r)}</span>var Xu=(0,zo.promisify)(Yo.default.exec),ee=gr("prisma:get-platform"),ec=["1.0.x","1.1.x","3.0.x"];async function Zo(){let e=Kt.default.platform(),r=process.arch;<span class="missing-if-branch" title="if path not taken" >I</span>if(e==="freebsd"){let s=<span class="cstat-no" title="statement not covered" >await Yt("freebsd-version");<span class="cstat-no" title="statement not covered" >i</span>f(s&amp;&amp;s.trim().length&gt;0){let l=<span class="cstat-no" title="statement not covered" >/^(\d+)\.?/.exec(s);<span class="cstat-no" title="statement not covered" >i</span>f(l)<span class="cstat-no" title="statement not covered" >return{platform:"freebsd",targetDistro:`freebsd${l[1]}`,arch:r}}</span></span>}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(e!=="linux")<span class="cstat-no" title="statement not covered" >return{platform:e,arch:r};l</span>et t=await tc(),n=await cc(),i=ic({arch:r,archFromUname:n,familyDistro:t.familyDistro}),{libssl:o}=await oc(i);return{platform:"linux",libssl:o,arch:r,archFromUname:n,...t}}function rc(e){let r=/^ID="?([^"\n]*)"?$/im,t=/^ID_LIKE="?([^"\n]*)"?$/im,n=r.exec(e),i=n&amp;&amp;n[1]&amp;&amp;n[1].toLowerCase()||<span class="branch-3 cbranch-no" title="branch not covered" >"",o</span>=t.exec(e),s=o&amp;&amp;o[1]&amp;&amp;o[1].toLowerCase()||<span class="branch-3 cbranch-no" title="branch not covered" >"",a</span>=hr({id:i,idLike:s}).with({id:"alpine"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"musl",familyDistro:l,originalDistro:l})).w</span>ith({id:"raspbian"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"arm",familyDistro:"debian",originalDistro:l})).w</span>ith({id:"nixos"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"nixos",originalDistro:l,familyDistro:"nixos"})).w</span>ith({id:"debian"},{id:"ubuntu"},({id:l})=&gt;({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).with({id:"rhel"},{id:"centos"},{id:"fedora"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).w</span>hen(<span class="fstat-no" title="function not covered" >({</span>idLike:l})=&gt;<span class="cstat-no" title="statement not covered" >l.includes("debian")||l.includes("ubuntu"),<span class="fstat-no" title="function not covered" >(</span>{</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"debian",familyDistro:"debian",originalDistro:l})).w</span>hen(<span class="fstat-no" title="function not covered" >({</span>idLike:l})=&gt;<span class="cstat-no" title="statement not covered" >i==="arch"||l.includes("arch"),<span class="fstat-no" title="function not covered" >(</span>{</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"debian",familyDistro:"arch",originalDistro:l})).w</span>hen(<span class="fstat-no" title="function not covered" >({</span>idLike:l})=&gt;<span class="cstat-no" title="statement not covered" >l.includes("centos")||l.includes("fedora")||l.includes("rhel")||l.includes("suse"),<span class="fstat-no" title="function not covered" >(</span>{</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).o</span>therwise(<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:void 0,familyDistro:void 0,originalDistro:l}));r</span>eturn ee(`Found distro info:
${JSON.stringify(a,null,2)}`),a}async function tc(){let e="/etc/os-release";try{let r=await fi.default.readFile(e,{encoding:"utf-8"});return rc(r)}catch{<span class="cstat-no" title="statement not covered" >return{targetDistro:void 0,familyDistro:void 0,originalDistro:void 0}}</span>}function <span class="fstat-no" title="function not covered" >nc(e</span>){let r=<span class="cstat-no" title="statement not covered" >/^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);<span class="cstat-no" title="statement not covered" >i</span>f(r){let t=<span class="cstat-no" title="statement not covered" >`${r[1]}.x`;<span class="cstat-no" title="statement not covered" ></span>return Xo(t)}</span>}</span>function Ho(e){let r=/libssl\.so\.(\d)(\.\d)?/.exec(e);<span class="missing-if-branch" title="else path not taken" >E</span>if(r){let t=`${r[1]}${r[2]??".0"}.x`;return Xo(t)}}function Xo(e){let r=(()=&gt;{<span class="missing-if-branch" title="if path not taken" >I</span>if(rs(e))<span class="cstat-no" title="statement not covered" >return e;l</span>et t=e.split(".");return t[1]="0",t.join(".")})();<span class="missing-if-branch" title="else path not taken" >E</span>if(ec.includes(r))return r}function ic(e){return hr(e).with({familyDistro:"musl"},<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >e</span>e('Trying platform-specific paths for "alpine"'),["/lib","/usr/lib"])).w</span>ith({familyDistro:"debian"},({archFromUname:r})=&gt;(ee('Trying platform-specific paths for "debian" (and "ubuntu")'),[`/usr/lib/${r}-linux-gnu`,`/lib/${r}-linux-gnu`])).with({familyDistro:"rhel"},<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >e</span>e('Trying platform-specific paths for "rhel"'),["/lib64","/usr/lib64"])).o</span>therwise(<span class="fstat-no" title="function not covered" >({</span>familyDistro:r,arch:t,archFromUname:n})=&gt;(<span class="cstat-no" title="statement not covered" >ee(`Don't know any platform-specific paths for "${r}" on ${t} (${n})`),[])</span>)}async function oc(e){let r='grep -v "libssl.so.0"',t=await Ko(e);<span class="missing-if-branch" title="else path not taken" >E</span>if(t){ee(`Found libssl.so file using platform-specific paths: ${t}`);let o=Ho(t);<span class="missing-if-branch" title="else path not taken" >E</span>if(ee(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"libssl-specific-path"}}<span class="cstat-no" title="statement not covered" >ee('Falling back to "ldconfig" and other generic paths');l</span>et n=<span class="cstat-no" title="statement not covered" >await Yt(`ldconfig -p | sed "s/.*=&gt;s*//" | sed "s|.*/||" | grep libssl | sort | ${r}`);<span class="cstat-no" title="statement not covered" >i</span>f(n||(n=await Ko(["/lib64","/usr/lib64","/lib","/usr/lib"])),n){<span class="cstat-no" title="statement not covered" >ee(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);l</span>et o=<span class="cstat-no" title="statement not covered" >Ho(n);<span class="cstat-no" title="statement not covered" >i</span>f(ee(`The parsed libssl version is: ${o}`),o)<span class="cstat-no" title="statement not covered" >return{libssl:o,strategy:"ldconfig"}}</span></span>l</span>et i=<span class="cstat-no" title="statement not covered" >await Yt("openssl version -v");<span class="cstat-no" title="statement not covered" >i</span>f(i){<span class="cstat-no" title="statement not covered" >ee(`Found openssl binary with version: ${i}`);l</span>et o=<span class="cstat-no" title="statement not covered" >nc(i);<span class="cstat-no" title="statement not covered" >i</span>f(ee(`The parsed openssl version is: ${o}`),o)<span class="cstat-no" title="statement not covered" >return{libssl:o,strategy:"openssl-binary"}}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn ee("Couldn't find any version of libssl or OpenSSL in the system"),{}}</span>async function Ko(e){for(let r of e){let t=await sc(r);<span class="missing-if-branch" title="else path not taken" >E</span>if(t)return t}}async function sc(e){try{return(await fi.default.readdir(e)).find(t=&gt;t.startsWith("libssl.so.")&amp;&amp;!t.startsWith("libssl.so.0"))}catch(r){<span class="cstat-no" title="statement not covered" >if(r.code==="ENOENT")<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>hrow r}</span>}async function ir(){let{binaryTarget:e}=await es();return e}function ac(e){return e.binaryTarget!==void 0}async function gi(){let{memoized:e,...r}=await es();return r}var Ht={};async function es(){if(ac(Ht))return Promise.resolve({...Ht,memoized:!0});let e=await Zo(),r=lc(e);return Ht={...e,binaryTarget:r},{...Ht,memoized:!1}}function lc(e){let{platform:r,arch:t,archFromUname:n,libssl:i,targetDistro:o,familyDistro:s,originalDistro:a}=e;r==="linux"&amp;&amp;!["x64","arm64"].includes(t)&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >Jt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${t}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);l</span>et l="1.1.x";<span class="missing-if-branch" title="if path not taken" >I</span>if(r==="linux"&amp;&amp;i===void 0){let c=<span class="cstat-no" title="statement not covered" >hr({familyDistro:s}).with({familyDistro:"debian"},<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>Please manually install OpenSSL via `apt-get update -y &amp;&amp; apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").o</span>therwise(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>Please manually install OpenSSL and try installing Prisma again.");<span class="cstat-no" title="statement not covered" >J</span></span>t(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".</span>
${c}`)}let u="debian";<span class="missing-if-branch" title="if path not taken" >I</span>if(r==="linux"&amp;&amp;o===void 0&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >ee(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`),r</span>==="darwin"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t==="arm64")<span class="cstat-no" title="statement not covered" >r</span>eturn"darwin-arm64";<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="darwin")<span class="cstat-no" title="statement not covered" >return"darwin";<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="win32")<span class="cstat-no" title="statement not covered" >return"windows";<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="freebsd")<span class="cstat-no" title="statement not covered" >return o;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="openbsd")<span class="cstat-no" title="statement not covered" >return"openbsd";<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="netbsd")<span class="cstat-no" title="statement not covered" >return"netbsd";<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="linux"&amp;&amp;o==="nixos")<span class="cstat-no" title="statement not covered" >return"linux-nixos";<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="linux"&amp;&amp;t==="arm64")<span class="cstat-no" title="statement not covered" >return`${o==="musl"?"linux-musl-arm64":"linux-arm64"}-openssl-${i||l}`;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="linux"&amp;&amp;t==="arm")<span class="cstat-no" title="statement not covered" >return`linux-arm-openssl-${i||l}`;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r==="linux"&amp;&amp;o==="musl"){let c=<span class="cstat-no" title="statement not covered" >"linux-musl";<span class="cstat-no" title="statement not covered" >r</span>eturn!i||rs(i)?c:`${c}-openssl-${i}`}r</span>eturn r==="linux"&amp;&amp;o&amp;&amp;i?`${o}-openssl-${i}`:(<span class="branch-1 cbranch-no" title="branch not covered" >r!=="linux"&amp;&amp;Jt(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`),i?`${u}-openssl-${i}`:o?`${o}-openssl-${l}`:`${u}-openssl-${l}`)</span>}async function <span class="fstat-no" title="function not covered" >uc(e</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await e()}</span>catch{<span class="cstat-no" title="statement not covered" >return}</span>}</span>function <span class="fstat-no" title="function not covered" >Yt(e</span>){<span class="cstat-no" title="statement not covered" >return uc(<span class="fstat-no" title="function not covered" >async()=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >await Xu(e);<span class="cstat-no" title="statement not covered" >r</span>eturn ee(`Command "${e}" successfully returned "${r.stdout}"`),r.stdout})}</span></span>async function cc(){return typeof Kt.default.machine=="function"?Kt.default.machine():(<span class="branch-1 cbranch-no" title="branch not covered" >await Yt("uname -m"))?.trim()}</span>function rs(e){return e.startsWith("1.")}var Xt={};tr(Xt,{beep:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >F</span>c,c</span>learScreen:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>c,c</span>learTerminal:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >_</span>c,c</span>ursorBackward:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >y</span>c,c</span>ursorDown:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>c,c</span>ursorForward:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >h</span>c,c</span>ursorGetPosition:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >w</span>c,c</span>ursorHide:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>c,c</span>ursorLeft:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>s,c</span>ursorMove:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >f</span>c,c</span>ursorNextLine:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >x</span>c,c</span>ursorPrevLine:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >v</span>c,c</span>ursorRestorePosition:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >E</span>c,c</span>ursorSavePosition:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >b</span>c,c</span>ursorShow:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >T</span>c,c</span>ursorTo:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >m</span>c,c</span>ursorUp:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>s,e</span>nterAlternativeScreen:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >N</span>c,e</span>raseDown:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >C</span>c,e</span>raseEndLine:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >R</span>c,e</span>raseLine:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >o</span>s,e</span>raseLines:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >S</span>c,e</span>raseScreen:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >h</span>i,e</span>raseStartLine:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >A</span>c,e</span>raseUp:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >I</span>c,e</span>xitAlternativeScreen:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >L</span>c,i</span>Term:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >q</span>c,i</span>mage:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >$</span>c,l</span>ink:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >M</span>c,s</span>crollDown:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >D</span>c,s</span>crollUp:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >k</span>c}</span>);var Zt=C(require("node:process"),1);var zt=globalThis.window?.document!==void 0,bg=globalThis.process?.versions?.node!==void 0,Eg=globalThis.process?.versions?.bun!==void 0,wg=globalThis.Deno?.version?.deno!==void 0,xg=globalThis.process?.versions?.electron!==void 0,vg=globalThis.navigator?.userAgent?.includes("jsdom")===!0,Pg=typeof WorkerGlobalScope&lt;"u"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >globalThis instanceof WorkerGlobalScope,T</span>g=typeof DedicatedWorkerGlobalScope&lt;"u"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >globalThis instanceof DedicatedWorkerGlobalScope,S</span>g=typeof SharedWorkerGlobalScope&lt;"u"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >globalThis instanceof SharedWorkerGlobalScope,R</span>g=typeof ServiceWorkerGlobalScope&lt;"u"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >globalThis instanceof ServiceWorkerGlobalScope,X</span>r=globalThis.navigator?.userAgentData?.platform,Ag=Xr==="macOS"||globalThis.navigator?.platform==="MacIntel"||globalThis.navigator?.userAgent?.includes(" Mac ")===!0||globalThis.process?.platform==="darwin",Cg=Xr==="Windows"||globalThis.navigator?.platform==="Win32"||globalThis.process?.platform==="win32",Ig=Xr==="Linux"||globalThis.navigator?.platform?.startsWith("Linux")===!0||globalThis.navigator?.userAgent?.includes(" Linux ")===!0||globalThis.process?.platform==="linux",kg=Xr==="iOS"||globalThis.navigator?.platform==="MacIntel"&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >globalThis.navigator?.maxTouchPoints&gt;1||/</span>iPad|iPhone|iPod/.test(globalThis.navigator?.platform),Dg=Xr==="Android"||globalThis.navigator?.platform==="Android"||globalThis.navigator?.userAgent?.includes(" Android ")===!0||globalThis.process?.platform==="android";var k="\x1B[",rt="\x1B]",yr="\x07",et=";",ts=!zt&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Zt.default.env.TERM_PROGRAM==="Apple_Terminal",p</span>c=!zt&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Zt.default.platform==="win32",d</span>c=zt?<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>hrow new Error("`process.cwd()` only works in Node.js, not the browser.")}</span>:<span class="branch-1 cbranch-no" title="branch not covered" >Zt.default.cwd,</span>mc=<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError("The `x` argument is required");<span class="cstat-no" title="statement not covered" >r</span></span>eturn typeof r!="number"?k+(e+1)+"G":k+(r+1)+et+(e+1)+"H"}</span>,fc=<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError("The `x` argument is required");l</span></span>et t=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" >r</span>eturn e&lt;0?t+=k+-e+"D":e&gt;0&amp;&amp;(t+=k+e+"C"),r&lt;0?t+=k+-r+"A":r&gt;0&amp;&amp;(t+=k+r+"B"),t}</span>,ns=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >k+e+"A",g</span>c=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >k+e+"B",h</span>c=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >k+e+"C",y</span>c=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >k+e+"D",i</span>s=k+"G",bc=ts?<span class="branch-0 cbranch-no" title="branch not covered" >"\x1B7":k</span>+"s",Ec=ts?<span class="branch-0 cbranch-no" title="branch not covered" >"\x1B8":k</span>+"u",wc=k+"6n",xc=k+"E",vc=k+"F",Pc=k+"?25l",Tc=k+"?25h",Sc=<span class="fstat-no" title="function not covered" >e=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;t</span>&lt;e;t++)<span class="cstat-no" title="statement not covered" >r+=os+(t&lt;e-1?ns():"");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e&amp;&amp;(r+=is),r}</span>,Rc=k+"K",Ac=k+"1K",os=k+"2K",Cc=k+"J",Ic=k+"1J",hi=k+"2J",kc=k+"S",Dc=k+"T",Oc="\x1Bc",_c=pc?<span class="branch-0 cbranch-no" title="branch not covered" >`${hi}${k}0f`:</span>`${hi}${k}3J${k}H`,Nc=k+"?1049h",Lc=k+"?1049l",Fc=yr,Mc=<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >[rt,"8",et,et,r,yr,e,rt,"8",et,et,yr].join(""),$</span>c=<span class="fstat-no" title="function not covered" >(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >`${rt}1337;File=inline=1`;<span class="cstat-no" title="statement not covered" ></span>return r.width&amp;&amp;(t+=`;width=${r.width}`),r.height&amp;&amp;(t+=`;height=${r.height}`),r.preserveAspectRatio===!1&amp;&amp;(t+=";preserveAspectRatio=0"),t+":"+Buffer.from(e).toString("base64")+yr}</span>,qc={setCwd:<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >dc())</span>=&gt;<span class="cstat-no" title="statement not covered" >`${rt}50;CurrentDir=${e}${yr}`,<span class="fstat-no" title="function not covered" ></span>annotation(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let t=<span class="cstat-no" title="statement not covered" >`${rt}1337;`,</span>n=<span class="cstat-no" title="statement not covered" >r.x!==void 0,i</span>=<span class="cstat-no" title="statement not covered" >r.y!==void 0;<span class="cstat-no" title="statement not covered" >i</span>f((n||i)&amp;&amp;!(n&amp;&amp;i&amp;&amp;r.length!==void 0))<span class="cstat-no" title="statement not covered" >throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e=e.replaceAll("|",""),t+=r.isHidden?"AddHiddenAnnotation=":"AddAnnotation=",r.length&gt;0?t+=(n?[e,r.length,r.x,r.y]:[r.length,e]).join("|"):t+=e,t+yr}</span>};var en=C(ds(),1);function <span class="fstat-no" title="function not covered" >or(e</span>,r,{target:t=<span class="branch-0 cbranch-no" title="branch not covered" >"stdout",</span>...n}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return en.default[t]?Xt.link(e,r):n.fallback===!1?e:typeof n.fallback=="function"?n.fallback(e,r):`${e} (\u200B${r}\u200B)`}o</span>r.isSupported=en.default.stdout;or.stderr=<span class="fstat-no" title="function not covered" >(e</span>,r,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >or(e,r,{target:"stderr",...t});o</span>r.stderr.isSupported=en.default.stderr;function <span class="fstat-no" title="function not covered" >xi(e</span>){<span class="cstat-no" title="statement not covered" >return or(e,e,{fallback:Y})}</span>var Gc=ms(),vi=Gc.version;function Er(e){let r=Qc();return r||(e?.config.engineType==="library"?"library":<span class="branch-1 cbranch-no" title="branch not covered" >e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":Wc(e)</span>)}function Qc(){let e=process.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"?<span class="branch-0 cbranch-no" title="branch not covered" >"library":e</span>==="binary"?<span class="branch-0 cbranch-no" title="branch not covered" >"binary":e</span>==="client"?<span class="branch-0 cbranch-no" title="branch not covered" >"client":v</span>oid 0}function <span class="fstat-no" title="function not covered" >Wc(e</span>){<span class="cstat-no" title="statement not covered" >return e?.previewFeatures.includes("queryCompiler")?"client":"library"}</span>function <span class="fstat-no" title="function not covered" >Pi(e</span>){<span class="cstat-no" title="statement not covered" >return e.name==="DriverAdapterError"&amp;&amp;typeof e.cause=="object"}</span>function <span class="fstat-no" title="function not covered" >rn(e</span>){<span class="cstat-no" title="statement not covered" >return{ok:!0,value:e,<span class="fstat-no" title="function not covered" >map(r</span>){<span class="cstat-no" title="statement not covered" >return rn(r(e))}</span>,<span class="fstat-no" title="function not covered" >flatMap(r</span>){<span class="cstat-no" title="statement not covered" >return r(e)}</span>}}</span>function <span class="fstat-no" title="function not covered" >sr(e</span>){<span class="cstat-no" title="statement not covered" >return{ok:!1,error:e,<span class="fstat-no" title="function not covered" >map(){<span class="cstat-no" title="statement not covered" >r</span>eturn sr(e)}</span>,<span class="fstat-no" title="function not covered" >flatMap(){<span class="cstat-no" title="statement not covered" >r</span>eturn sr(e)}</span>}}</span>var fs=N("driver-adapter-utils"),Ti=class{<span class="cstat-no" title="statement not covered" >registeredErrors=[];<span class="fstat-no" title="function not covered" >c</span>onsumeError(r</span>){<span class="cstat-no" title="statement not covered" >return this.registeredErrors[r]}<span class="fstat-no" title="function not covered" >r</span>egisterNewError(r</span>){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;this.registeredErrors[t]!==void 0;)<span class="cstat-no" title="statement not covered" >t++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.registeredErrors[t]={error:r},t}</span>};var tn=<span class="fstat-no" title="function not covered" >(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >new Ti)</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >{adapterName:e.adapterName,errorRegistry:r,queryRaw:_e(r,e.queryRaw.bind(e)),executeRaw:_e(r,e.executeRaw.bind(e)),executeScript:_e(r,e.executeScript.bind(e)),dispose:_e(r,e.dispose.bind(e)),provider:e.provider,startTransaction:<span class="fstat-no" title="function not covered" >async(.</span>..n)=&gt;<span class="cstat-no" title="statement not covered" >(await _e(r,e.startTransaction.bind(e))(...n)).map(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >J</span>c(r,o))}</span></span>;<span class="cstat-no" title="statement not covered" >r</span>eturn e.getConnectionInfo&amp;&amp;(t.getConnectionInfo=Hc(r,e.getConnectionInfo.bind(e))),t}</span>,Jc=<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;(<span class="cstat-no" title="statement not covered" >{adapterName:r.adapterName,provider:r.provider,options:r.options,queryRaw:_e(e,r.queryRaw.bind(r)),executeRaw:_e(e,r.executeRaw.bind(r)),commit:_e(e,r.commit.bind(r)),rollback:_e(e,r.rollback.bind(r))});f</span>unction <span class="fstat-no" title="function not covered" >_e(e</span>,r){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >async(.</span>..t)=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return rn(await r(...t))}</span>catch(n){<span class="cstat-no" title="statement not covered" >if(fs("[error@wrapAsync]",n),Pi(n))<span class="cstat-no" title="statement not covered" >return sr(n.cause);l</span></span>et i=<span class="cstat-no" title="statement not covered" >e.registerNewError(n);<span class="cstat-no" title="statement not covered" >r</span>eturn sr({kind:"GenericJs",id:i})}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >Hc(e</span>,r){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return rn(r(...t))}</span>catch(n){<span class="cstat-no" title="statement not covered" >if(fs("[error@wrapSync]",n),Pi(n))<span class="cstat-no" title="statement not covered" >return sr(n.cause);l</span></span>et i=<span class="cstat-no" title="statement not covered" >e.registerNewError(n);<span class="cstat-no" title="statement not covered" >r</span>eturn sr({kind:"GenericJs",id:i})}</span>}</span>}</span>var Yc=C(on());var M=C(require("node:path")),zc=C(on()),Ph=N("prisma:engines");function <span class="fstat-no" title="function not covered" >gs(){<span class="cstat-no" title="statement not covered" >r</span>eturn M.default.join(__dirname,"../")}</span>var Th="libquery-engine";M.default.join(__dirname,"../query-engine-darwin");M.default.join(__dirname,"../query-engine-darwin-arm64");M.default.join(__dirname,"../query-engine-debian-openssl-1.0.x");M.default.join(__dirname,"../query-engine-debian-openssl-1.1.x");M.default.join(__dirname,"../query-engine-debian-openssl-3.0.x");M.default.join(__dirname,"../query-engine-linux-static-x64");M.default.join(__dirname,"../query-engine-linux-static-arm64");M.default.join(__dirname,"../query-engine-rhel-openssl-1.0.x");M.default.join(__dirname,"../query-engine-rhel-openssl-1.1.x");M.default.join(__dirname,"../query-engine-rhel-openssl-3.0.x");M.default.join(__dirname,"../libquery_engine-darwin.dylib.node");M.default.join(__dirname,"../libquery_engine-darwin-arm64.dylib.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-musl.so.node");M.default.join(__dirname,"../libquery_engine-linux-musl-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-3.0.x.so.node");M.default.join(__dirname,"../query_engine-windows.dll.node");var Ri=C(require("node:fs")),hs=gr("chmodPlusX");function <span class="fstat-no" title="function not covered" >Ai(e</span>){<span class="cstat-no" title="statement not covered" >if(process.platform==="win32")<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >Ri.default.statSync(e),t</span>=<span class="cstat-no" title="statement not covered" >r.mode|64|8|1;<span class="cstat-no" title="statement not covered" >i</span>f(r.mode===t){<span class="cstat-no" title="statement not covered" >hs(`Execution permissions of ${e} are fine`);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>l</span>et n=<span class="cstat-no" title="statement not covered" >t.toString(8).slice(-3);<span class="cstat-no" title="statement not covered" >h</span>s(`Have to call chmodPlusX on ${e}`),Ri.default.chmodSync(e,n)}</span>function <span class="fstat-no" title="function not covered" >Ci(e</span>){let r=<span class="cstat-no" title="statement not covered" >e.e,</span>t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >`</span>Prisma cannot find the required \`${a}\` system library in your system`,</span></span>n=<span class="cstat-no" title="statement not covered" >r.message.includes("cannot open shared object file"),i</span>=<span class="cstat-no" title="statement not covered" >`Please refer to the documentation about Prisma's system requirements: ${xi("https://pris.ly/d/system-requirements")}`,</span>o=<span class="cstat-no" title="statement not covered" >`Unable to require(\`${Ie(e.id)}\`).`,</span>s=<span class="cstat-no" title="statement not covered" >hr({message:r.message,code:r.code}).with({code:"ENOENT"},<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>File does not exist.").w</span>hen(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >n&amp;&amp;a.includes("libz"),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >`</span>${t("libz")}. Please install it and try again.`)</span>.when(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >n&amp;&amp;a.includes("libgcc_s"),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >`</span>${t("libgcc_s")}. Please install it and try again.`)</span>.when(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >n&amp;&amp;a.includes("libssl"),<span class="fstat-no" title="function not covered" >(</span>)=&gt;{l</span>et a=<span class="cstat-no" title="statement not covered" >e.platformInfo.libssl?`openssl-${e.platformInfo.libssl}`:"openssl";<span class="cstat-no" title="statement not covered" >r</span>eturn`${t("libssl")}. Please install ${a} and try again.`}).w</span>hen(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >a.includes("GLIBC"),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >`</span>Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`)</span>.when(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >e.platformInfo.platform==="linux"&amp;&amp;a.includes("symbol not found"),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >`</span>The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`)</span>.otherwise(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>The Prisma engines do not seem to be compatible with your system. ${i}`)</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn`${o}</span>
${s}
&nbsp;
Details: ${r.message}`}var Es=C(bs(),1);function <span class="fstat-no" title="function not covered" >Ii(e</span>){let r=<span class="cstat-no" title="statement not covered" >(0,Es.default)(e);<span class="cstat-no" title="statement not covered" >i</span>f(r===0)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et t=<span class="cstat-no" title="statement not covered" >new RegExp(`^[ \\t]{${r}}`,"gm");<span class="cstat-no" title="statement not covered" >r</span>eturn e.replace(t,"")}</span>var ws="prisma+postgres",sn=`${ws}:`;function an(e){return e?.toString().startsWith(`${sn}//`)??<span class="branch-1 cbranch-no" title="branch not covered" >!1}</span>function <span class="fstat-no" title="function not covered" >ki(e</span>){<span class="cstat-no" title="statement not covered" >if(!an(e))<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et{host:r}=<span class="cstat-no" title="statement not covered" >new URL(e);<span class="cstat-no" title="statement not covered" >r</span>eturn r.includes("localhost")||r.includes("127.0.0.1")||r.includes("[::1]")}</span>var vs=C(Di());function <span class="fstat-no" title="function not covered" >_i(e</span>){<span class="cstat-no" title="statement not covered" >return String(new Oi(e))}</span>var Oi=class{<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >this.config=r}<span class="fstat-no" title="function not covered" ></span>toString(){</span>let{config:r}=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >r.provider.fromEnvVar?`env("${r.provider.fromEnvVar}")`:r.provider.value,</span>n=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify({provider:t,binaryTargets:Zc(r.binaryTargets)}));<span class="cstat-no" title="statement not covered" >r</span>eturn`generator ${r.name} {</span>
${(0,vs.default)(Xc(n),2)}
}`}};function <span class="fstat-no" title="function not covered" >Zc(e</span>){let r;<span class="cstat-no" title="statement not covered" >if(e.length&gt;0){let t=<span class="cstat-no" title="statement not covered" >e.find(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.fromEnvVar!==null);<span class="cstat-no" title="statement not covered" >t</span></span>?r=`env("${t.fromEnvVar}")`:r=e.map(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.native?"native":n.value)</span>}</span>else <span class="cstat-no" title="statement not covered" >r=void 0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Xc(e</span>){let r=<span class="cstat-no" title="statement not covered" >Object.keys(e).reduce(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,n.length),0</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn Object.entries(e).map(<span class="fstat-no" title="function not covered" >([</span>t,n])=&gt;<span class="cstat-no" title="statement not covered" >`${t.padEnd(r)} = ${ep(n)}`)</span>.join(`</span>
`)}function <span class="fstat-no" title="function not covered" >ep(e</span>){<span class="cstat-no" title="statement not covered" >return JSON.parse(JSON.stringify(e,<span class="fstat-no" title="function not covered" >(r</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >Array.isArray(t)?`[${t.map(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >J</span>SON.stringify(n)).j</span>oin(", ")}]`:JSON.stringify(t)))}</span></span>var nt={};tr(nt,{error:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>p,i</span>nfo:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>p,l</span>og:()=&gt;rp,query:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>p,s</span>hould:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>s,t</span>ags:()=&gt;tt,warn:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >N</span>i}</span>);var tt={error:ce("prisma:error"),warn:ke("prisma:warn"),info:De("prisma:info"),query:nr("prisma:query")},Ps={warn:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>process.env.PRISMA_DISABLE_WARNINGS}</span>;function rp(...e){console.log(...e)}function <span class="fstat-no" title="function not covered" >Ni(e</span>,...r){<span class="cstat-no" title="statement not covered" >Ps.warn()&amp;&amp;console.warn(`${tt.warn} ${e}`,...r)}</span>function <span class="fstat-no" title="function not covered" >tp(e</span>,...r){<span class="cstat-no" title="statement not covered" >console.info(`${tt.info} ${e}`,...r)}</span>function <span class="fstat-no" title="function not covered" >np(e</span>,...r){<span class="cstat-no" title="statement not covered" >console.error(`${tt.error} ${e}`,...r)}</span>function <span class="fstat-no" title="function not covered" >ip(e</span>,...r){<span class="cstat-no" title="statement not covered" >console.log(`${tt.query} ${e}`,...r)}</span>function <span class="fstat-no" title="function not covered" >ln(e</span>,r){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}</span></span>function <span class="fstat-no" title="function not covered" >Ne(e</span>,r){<span class="cstat-no" title="statement not covered" >throw new Error(r)}</span>var it=C(require("node:path"));function <span class="fstat-no" title="function not covered" >Fi(e</span>){<span class="cstat-no" title="statement not covered" >return it.default.sep===it.default.posix.sep?e:e.split(it.default.sep).join(it.default.posix.sep)}</span>var ji=C(Os()),un=C(require("node:fs"));var wr=C(require("node:path"));function _s(e){let r=e.ignoreProcessEnv?<span class="branch-0 cbranch-no" title="branch not covered" >{}:p</span>rocess.env,t=n=&gt;n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(<span class="fstat-no" title="function not covered" >function(o</span>,s){let a=<span class="cstat-no" title="statement not covered" >/(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);<span class="cstat-no" title="statement not covered" >i</span>f(!a)<span class="cstat-no" title="statement not covered" >return o;l</span></span>et l=<span class="cstat-no" title="statement not covered" >a[1],</span>u,c;<span class="cstat-no" title="statement not covered" >if(l==="\\")<span class="cstat-no" title="statement not covered" >c=a[0],u=c.replace("\\$","$");else{</span>let p=<span class="cstat-no" title="statement not covered" >a[2];<span class="cstat-no" title="statement not covered" ></span>c=a[0].substring(l.length),u=Object.hasOwnProperty.call(r,p)?r[p]:e.parsed[p]||"",u=t(u)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.replace(c,u)}</span>,n)??n;for(let n in e.parsed){let i=Object.hasOwnProperty.call(r,n)?r[n]:<span class="branch-1 cbranch-no" title="branch not covered" >e.parsed[n];</span>e.parsed[n]=t(i)}for(let n in e.parsed)r[n]=e.parsed[n];return e}var qi=gr("prisma:tryLoadEnv");function st({rootEnvPath:e,schemaEnvPath:r},t=<span class="branch-0 cbranch-no" title="branch not covered" >{conflictCheck:"none"})</span>{let n=Ns(e);t.conflictCheck!=="none"&amp;&amp;wp(n,r,t.conflictCheck);let i=null;return Ls(n?.path,r)||(i=Ns(r)),!n&amp;&amp;!i&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >qi("No Environment variables loaded"),i</span>?.dotenvResult.error?<span class="branch-0 cbranch-no" title="branch not covered" >console.error(ce(W("Schema Env Error: "))+i.dotenvResult.error):{</span>message:[n?.message,i?.message].filter(Boolean).join(`
`),parsed:{...n?.dotenvResult?.parsed,...i?.dotenvResult?.parsed}}}function wp(e,r,t){let n=e?.dotenvResult.parsed,i=!Ls(e?.path,r);<span class="missing-if-branch" title="if path not taken" >I</span>if(n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >i</span>&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >u</span>n.default.existsSync(r)){</span>let o=<span class="cstat-no" title="statement not covered" >ji.default.parse(un.default.readFileSync(r)),s</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let a in o)<span class="cstat-no" title="statement not covered" >n[a]===o[a]&amp;&amp;s.push(a);<span class="cstat-no" title="statement not covered" >i</span></span>f(s.length&gt;0){let a=<span class="cstat-no" title="statement not covered" >wr.default.relative(process.cwd(),e.path),l</span>=<span class="cstat-no" title="statement not covered" >wr.default.relative(process.cwd(),r);<span class="cstat-no" title="statement not covered" >i</span>f(t==="error"){let u=<span class="cstat-no" title="statement not covered" >`There is a conflict between env var${s.length&gt;1?"s":""} in ${Y(a)} and ${Y(l)}</span></span></span>
Conflicting env vars:
${s.map(<span class="fstat-no" title="function not covered" >c=&gt;<span class="cstat-no" title="statement not covered" >`</span>  ${W(c)}`)</span>.join(`
`)}
&nbsp;
We suggest to move the contents of ${Y(l)} to ${Y(a)} to consolidate your env vars.
`;<span class="cstat-no" title="statement not covered" >throw new Error(u)}</span>else <span class="cstat-no" title="statement not covered" >if(t==="warn"){let u=<span class="cstat-no" title="statement not covered" >`Conflict for env var${s.length&gt;1?"s":""} ${s.map(<span class="fstat-no" title="function not covered" >c=&gt;<span class="cstat-no" title="statement not covered" >W</span>(c)).j</span>oin(", ")} in ${Y(a)} and ${Y(l)}</span></span>
Env vars from ${Y(l)} overwrite the ones from ${Y(a)}
      `;<span class="cstat-no" title="statement not covered" >console.warn(`${ke("warn(prisma)")} ${u}`)}</span>}}}function Ns(e){if(xp(e)){qi(`Environment variables loaded from ${e}`);let r=ji.default.config({path:e,debug:process.env.DOTENV_CONFIG_DEBUG?<span class="branch-0 cbranch-no" title="branch not covered" >!0:v</span>oid 0});return{dotenvResult:_s(r),message:Ie(`Environment variables loaded from ${wr.default.relative(process.cwd(),e)}`),path:e}}else qi(`Environment variables not found at ${e}`);return null}function Ls(e,r){return e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >w</span>r.default.resolve(e)===wr.default.resolve(r)}</span>function xp(e){return!!(e&amp;&amp;un.default.existsSync(e))}function <span class="fstat-no" title="function not covered" >Vi(e</span>,r){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(e,r)}</span>function xr(e,r){let t={};for(let n of Object.keys(e))t[n]=r(e[n],n);return t}function Bi(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.length===0)<span class="cstat-no" title="statement not covered" >return;l</span>et t=e[0];for(let n=1;n&lt;e.length;n++)r(t,e[n])&lt;0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t=e[n])</span>;return t}function x(e,r){Object.defineProperty(e,"name",{value:r,configurable:!0})}var Ms=new Set,at=<span class="fstat-no" title="function not covered" >(e</span>,r,...t)=&gt;{<span class="cstat-no" title="statement not covered" >Ms.has(e)||(Ms.add(e),Ni(r,...t))}</span>;var T=class e extends Error{clientVersion;errorCode;retryable;<span class="fstat-no" title="function not covered" >constructor(r</span>,t,n){<span class="cstat-no" title="statement not covered" >super(r),this.name="PrismaClientInitializationError",this.clientVersion=t,this.errorCode=n,Error.captureStackTrace(e)}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientInitializationError"}</span>};x(T,"PrismaClientInitializationError");var z=class extends Error{code;meta;clientVersion;batchRequestIdx;constructor(r,{code:t,clientVersion:n,meta:i,batchRequestIdx:o}){super(r),this.name="PrismaClientKnownRequestError",this.code=t,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}<span class="fstat-no" title="function not covered" >get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientKnownRequestError"}</span>};x(z,"PrismaClientKnownRequestError");var le=class extends Error{clientVersion;<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >super(r),this.name="PrismaClientRustPanicError",this.clientVersion=t}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientRustPanicError"}</span>};x(le,"PrismaClientRustPanicError");var j=class extends Error{clientVersion;batchRequestIdx;<span class="fstat-no" title="function not covered" >constructor(r</span>,{clientVersion:t,batchRequestIdx:n}){<span class="cstat-no" title="statement not covered" >super(r),this.name="PrismaClientUnknownRequestError",this.clientVersion=t,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientUnknownRequestError"}</span>};x(j,"PrismaClientUnknownRequestError");var Z=class extends Error{name="PrismaClientValidationError";clientVersion;constructor(r,{clientVersion:t}){super(r),this.clientVersion=t}<span class="fstat-no" title="function not covered" >get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientValidationError"}</span>};x(Z,"PrismaClientValidationError");var vr=9e15,Ke=1e9,Ui="0123456789abcdef",fn="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",gn="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Gi={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-vr,maxE:vr,crypto:!1},Vs,Fe,w=!0,yn="[DecimalError] ",He=yn+"Invalid argument: ",Bs=yn+"Precision limit exceeded",Us=yn+"crypto unavailable",Gs="[object Decimal]",X=Math.floor,U=Math.pow,vp=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,Pp=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,Tp=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Qs=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,fe=1e7,E=7,Sp=9007199254740991,Rp=fn.length-1,Qi=gn.length-1,m={toStringTag:Gs};m.absoluteValue=m.abs=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" >r</span>eturn e.s&lt;0&amp;&amp;(e.s=1),y(e)}</span>;m.ceil=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn y(new this.constructor(this),this.e+1,2)}</span>;m.clampedTo=m.clamp=<span class="fstat-no" title="function not covered" >function(e</span>,r){var t,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>if(e=new i(e),r=new i(r),!e.s||!r.s)<span class="cstat-no" title="statement not covered" >return new i(NaN);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.gt(r))<span class="cstat-no" title="statement not covered" >throw Error(He+r);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t=n.cmp(e),t&lt;0?e:n.cmp(r)&gt;0?r:new i(n)}</span>;m.comparedTo=m.cmp=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t,n,i,o=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >o.d,</span>a=<span class="cstat-no" title="statement not covered" >(e=new o.constructor(e)).d,</span>l=<span class="cstat-no" title="statement not covered" >o.s,</span>u=<span class="cstat-no" title="statement not covered" >e.s;<span class="cstat-no" title="statement not covered" ></span>if(!s||!a)<span class="cstat-no" title="statement not covered" >return!l||!u?NaN:l!==u?l:s===a?0:!s^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!s[0]||!a[0])<span class="cstat-no" title="statement not covered" >return s[0]?l:a[0]?-u:0;<span class="cstat-no" title="statement not covered" >i</span></span>f(l!==u)<span class="cstat-no" title="statement not covered" >return l;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.e!==e.e)<span class="cstat-no" title="statement not covered" >return o.e&gt;e.e^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=s.length,i=a.length,r=0,t=n&lt;i?n:i;r&lt;t;++r)<span class="cstat-no" title="statement not covered" >if(s[r]!==a[r])<span class="cstat-no" title="statement not covered" >return s[r]&gt;a[r]^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n===i?0:n&gt;i^l&lt;0?1:-1}</span>;m.cosine=m.cos=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return t.d?t.d[0]?(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=Ap(n,Ys(n,t)),n.precision=e,n.rounding=r,y(Fe==2||Fe==3?t.neg():t,e,r,!0)):new n(1):new n(NaN)}</span>;m.cubeRoot=m.cbrt=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t,n,i,o,s,a,l,u,c=<span class="cstat-no" title="statement not covered" >this,</span>p=<span class="cstat-no" title="statement not covered" >c.constructor;<span class="cstat-no" title="statement not covered" ></span>if(!c.isFinite()||c.isZero())<span class="cstat-no" title="statement not covered" >return new p(c);<span class="cstat-no" title="statement not covered" >f</span></span>or(w=!1,o=c.s*U(c.s*c,1/3),!o||Math.abs(o)==1/0?(t=J(c.d),e=c.e,(o=(e-t.length+1)%3)&amp;&amp;(t+=o==1||o==-2?"0":"00"),o=U(t,1/3),e=X((e+1)/3)-(e%3==(e&lt;0?-1:2)),o==1/0?t="5e"+e:(t=o.toExponential(),t=t.slice(0,t.indexOf("e")+1)+e),n=new p(t),n.s=c.s):n=new p(o.toString()),s=(e=p.precision)+3;;)<span class="cstat-no" title="statement not covered" >if(a=n,l=a.times(a).times(a),u=l.plus(c),n=L(u.plus(c).times(a),u.plus(l),s+2,1),J(a.d).slice(0,s)===(t=J(n.d)).slice(0,s))<span class="cstat-no" title="statement not covered" >if(t=t.slice(s-3,s+1),t=="9999"||!i&amp;&amp;t=="4999"){<span class="cstat-no" title="statement not covered" >if(!i&amp;&amp;(y(a,e+1,0),a.times(a).times(a).eq(c))){<span class="cstat-no" title="statement not covered" >n=a;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>+=4,i=1}</span>else{(<span class="cstat-no" title="statement not covered" >!+t||!+t.slice(1)&amp;&amp;t.charAt(0)=="5")&amp;&amp;(y(n,e+1,1),r=!n.times(n).times(n).eq(c));<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn w=!0,y(n,e,p.rounding,r)}</span>;m.decimalPlaces=m.dp=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r=<span class="cstat-no" title="statement not covered" >this.d,</span>t=<span class="cstat-no" title="statement not covered" >NaN;<span class="cstat-no" title="statement not covered" >i</span>f(r){<span class="cstat-no" title="statement not covered" >if(e=r.length-1,t=(e-X(this.e/E))*E,e=r[e],e)<span class="cstat-no" title="statement not covered" >for(;e%10==0;e/=10)<span class="cstat-no" title="statement not covered" >t--;<span class="cstat-no" title="statement not covered" >t</span></span></span>&lt;0&amp;&amp;(t=0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>;m.dividedBy=m.div=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return L(this,new this.constructor(e))}</span>;m.dividedToIntegerBy=m.divToInt=<span class="fstat-no" title="function not covered" >function(e</span>){var r=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return y(L(r,new t(e),0,1,1),t.precision,t.rounding)}</span>;m.equals=m.eq=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(e)===0}</span>;m.floor=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn y(new this.constructor(this),this.e+1,3)}</span>;m.greaterThan=m.gt=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&gt;0}</span>;m.greaterThanOrEqualTo=m.gte=<span class="fstat-no" title="function not covered" >function(e</span>){var r=<span class="cstat-no" title="statement not covered" >this.cmp(e);<span class="cstat-no" title="statement not covered" >r</span>eturn r==1||r===0}</span>;m.hyperbolicCosine=m.cosh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t,n,i,o=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >o.constructor,</span>a=<span class="cstat-no" title="statement not covered" >new s(1);<span class="cstat-no" title="statement not covered" >i</span>f(!o.isFinite())<span class="cstat-no" title="statement not covered" >return new s(o.s?1/0:NaN);<span class="cstat-no" title="statement not covered" >i</span></span>f(o.isZero())<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >t</span></span>=s.precision,n=s.rounding,s.precision=t+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i&lt;32?(e=Math.ceil(i/3),r=(1/En(4,e)).toString()):(e=16,r="2.3283064365386962890625e-10"),o=Pr(s,1,o.times(r),new s(1),!0);<span class="cstat-no" title="statement not covered" >f</span>or(var l,u=<span class="cstat-no" title="statement not covered" >e,c</span>=<span class="cstat-no" title="statement not covered" >new s(8);u</span>--;)<span class="cstat-no" title="statement not covered" >l=o.times(o),o=a.minus(l.times(c.minus(l.times(c))));<span class="cstat-no" title="statement not covered" >r</span></span>eturn y(o,s.precision=t,s.rounding=n,!0)}</span>;m.hyperbolicSine=m.sinh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>if(!i.isFinite()||i.isZero())<span class="cstat-no" title="statement not covered" >return new o(i);<span class="cstat-no" title="statement not covered" >i</span></span>f(r=o.precision,t=o.rounding,o.precision=r+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n&lt;3)<span class="cstat-no" title="statement not covered" >i=Pr(o,2,i,i,!0);else{<span class="cstat-no" title="statement not covered" ></span>e=1.4*Math.sqrt(n),e=e&gt;16?16:e|0,i=i.times(1/En(5,e)),i=Pr(o,2,i,i,!0);<span class="cstat-no" title="statement not covered" >f</span>or(var s,a=<span class="cstat-no" title="statement not covered" >new o(5),l</span>=<span class="cstat-no" title="statement not covered" >new o(16),u</span>=<span class="cstat-no" title="statement not covered" >new o(20);e</span>--;)<span class="cstat-no" title="statement not covered" >s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(u))))}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn o.precision=r,o.rounding=t,y(i,r,t,!0)}</span>;m.hyperbolicTangent=m.tanh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+7,n.rounding=1,L(t.sinh(),t.cosh(),n.precision=e,n.rounding=r)):new n(t.s)}</span>;m.inverseCosine=m.acos=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >e.constructor,</span>t=<span class="cstat-no" title="statement not covered" >e.abs().cmp(1),n</span>=<span class="cstat-no" title="statement not covered" >r.precision,</span>i=<span class="cstat-no" title="statement not covered" >r.rounding;<span class="cstat-no" title="statement not covered" ></span>return t!==-1?t===0?e.isNeg()?we(r,n,i):new r(0):new r(NaN):e.isZero()?we(r,n+4,i).times(.5):(r.precision=n+6,r.rounding=1,e=new r(1).minus(e).div(e.plus(1)).sqrt().atan(),r.precision=n,r.rounding=i,e.times(2))}</span>;m.inverseHyperbolicCosine=m.acosh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return t.lte(1)?new n(t.eq(1)?0:NaN):t.isFinite()?(e=n.precision,r=n.rounding,n.precision=e+Math.max(Math.abs(t.e),t.sd())+4,n.rounding=1,w=!1,t=t.times(t).minus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln()):new n(t)}</span>;m.inverseHyperbolicSine=m.asinh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return!t.isFinite()||t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+2*Math.max(Math.abs(t.e),t.sd())+6,n.rounding=1,w=!1,t=t.times(t).plus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln())}</span>;m.inverseHyperbolicTangent=m.atanh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return i.isFinite()?i.e&gt;=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,r=o.rounding,n=i.sd(),Math.max(n,e)&lt;2*-i.e-1?y(new o(i),e,r,!0):(o.precision=t=n-i.e,i=L(i.plus(1),new o(1).minus(i),t+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=r,i.times(.5))):new o(NaN)}</span>;m.inverseSine=m.asin=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return i.isZero()?new o(i):(r=i.abs().cmp(1),t=o.precision,n=o.rounding,r!==-1?r===0?(e=we(o,t+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=t+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=t,o.rounding=n,i.times(2)))}</span>;m.inverseTangent=m.atan=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t,n,i,o,s,a,l,u=<span class="cstat-no" title="statement not covered" >this,</span>c=<span class="cstat-no" title="statement not covered" >u.constructor,</span>p=<span class="cstat-no" title="statement not covered" >c.precision,</span>d=<span class="cstat-no" title="statement not covered" >c.rounding;<span class="cstat-no" title="statement not covered" ></span>if(u.isFinite()){<span class="cstat-no" title="statement not covered" >if(u.isZero())<span class="cstat-no" title="statement not covered" >return new c(u);<span class="cstat-no" title="statement not covered" >i</span></span>f(u.abs().eq(1)&amp;&amp;p+4&lt;=Qi)<span class="cstat-no" title="statement not covered" >return s=we(c,p+4,d).times(.25),s.s=u.s,s}</span></span>else{<span class="cstat-no" title="statement not covered" >if(!u.s)<span class="cstat-no" title="statement not covered" >return new c(NaN);<span class="cstat-no" title="statement not covered" >i</span></span>f(p+4&lt;=Qi)<span class="cstat-no" title="statement not covered" >return s=we(c,p+4,d).times(.5),s.s=u.s,s}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(c.precision=a=p+10,c.rounding=1,t=Math.min(28,a/E+2|0),e=t;e;--e)<span class="cstat-no" title="statement not covered" >u=u.div(u.times(u).plus(1).sqrt().plus(1));<span class="cstat-no" title="statement not covered" >f</span></span>or(w=!1,r=Math.ceil(a/E),n=1,l=u.times(u),s=new c(u),i=u;e!==-1;)<span class="cstat-no" title="statement not covered" >if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[r]!==void 0)<span class="cstat-no" title="statement not covered" >for(e=r;s.d[e]===o.d[e]&amp;&amp;e--;);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t&amp;&amp;(s=s.times(2&lt;&lt;t-1)),w=!0,y(s,c.precision=p,c.rounding=d,!0)}</span>;m.isFinite=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn!!this.d};m</span>.isInteger=m.isInt=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn!!this.d&amp;&amp;X(this.e/E)&gt;this.d.length-2}</span>;m.isNaN=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn!this.s};m</span>.isNegative=m.isNeg=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn this.s&lt;0}</span>;m.isPositive=m.isPos=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn this.s&gt;0}</span>;m.isZero=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn!!this.d&amp;&amp;this.d[0]===0}</span>;m.lessThan=m.lt=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&lt;0}</span>;m.lessThanOrEqualTo=m.lte=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&lt;1}</span>;m.logarithm=m.log=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t,n,i,o,s,a,l,u=<span class="cstat-no" title="statement not covered" >this,</span>c=<span class="cstat-no" title="statement not covered" >u.constructor,</span>p=<span class="cstat-no" title="statement not covered" >c.precision,</span>d=<span class="cstat-no" title="statement not covered" >c.rounding,</span>f=<span class="cstat-no" title="statement not covered" >5;<span class="cstat-no" title="statement not covered" >i</span>f(e==null)<span class="cstat-no" title="statement not covered" >e=new c(10),r=!0;else{<span class="cstat-no" title="statement not covered" ></span>if(e=new c(e),t=e.d,e.s&lt;0||!t||!t[0]||e.eq(1))<span class="cstat-no" title="statement not covered" >return new c(NaN);<span class="cstat-no" title="statement not covered" >r</span></span>=e.eq(10)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t=u.d,u.s&lt;0||!t||!t[0]||u.eq(1))<span class="cstat-no" title="statement not covered" >return new c(t&amp;&amp;!t[0]?-1/0:u.s!=1?NaN:t?0:1/0);<span class="cstat-no" title="statement not covered" >i</span></span>f(r)<span class="cstat-no" title="statement not covered" >if(t.length&gt;1)<span class="cstat-no" title="statement not covered" >o=!0;else{<span class="cstat-no" title="statement not covered" ></span>for(i=t[0];i%10===0;)<span class="cstat-no" title="statement not covered" >i/=10;<span class="cstat-no" title="statement not covered" >o</span></span>=i!==1}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(w=!1,a=p+f,s=Je(u,a),n=r?hn(c,a+10):Je(e,a),l=L(s,n,a,1),lt(l.d,i=p,d))<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >if(a+=10,s=Je(u,a),n=r?hn(c,a+10):Je(e,a),l=L(s,n,a,1),!o){<span class="cstat-no" title="statement not covered" >+J(l.d).slice(i+1,i+15)+1==1e14&amp;&amp;(l=y(l,p+1,0));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>while(l</span>t(l.d,i+=10,d));<span class="cstat-no" title="statement not covered" >r</span></span>eturn w=!0,y(l,p,d)}</span>;m.minus=m.sub=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t,n,i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >f.constructor;<span class="cstat-no" title="statement not covered" ></span>if(e=new h(e),!f.d||!e.d)<span class="cstat-no" title="statement not covered" >return!f.s||!e.s?e=new h(NaN):f.d?e.s=-e.s:e=new h(e.d||f.s!==e.s?f:NaN),e;<span class="cstat-no" title="statement not covered" >i</span></span>f(f.s!=e.s)<span class="cstat-no" title="statement not covered" >return e.s=-e.s,f.plus(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(u=f.d,d=e.d,a=h.precision,l=h.rounding,!u[0]||!d[0]){<span class="cstat-no" title="statement not covered" >if(d[0])<span class="cstat-no" title="statement not covered" >e.s=-e.s;else <span class="cstat-no" title="statement not covered" >i</span>f(u[0])<span class="cstat-no" title="statement not covered" >e=new h(f);else <span class="cstat-no" title="statement not covered" >r</span>eturn new h(l===3?-0:0);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn w?y(e,a,l):e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t=X(e.e/E),c=X(f.e/E),u=u.slice(),o=c-t,o){<span class="cstat-no" title="statement not covered" >for(p=o&lt;0,p?(r=u,o=-o,s=d.length):(r=d,t=c,s=u.length),n=Math.max(Math.ceil(a/E),s)+2,o&gt;n&amp;&amp;(o=n,r.length=1),r.reverse(),n=o;n--;)<span class="cstat-no" title="statement not covered" >r.push(0);<span class="cstat-no" title="statement not covered" >r</span></span>.reverse()}</span>else{<span class="cstat-no" title="statement not covered" >for(n=u.length,s=d.length,p=n&lt;s,p&amp;&amp;(s=n),n=0;n&lt;s;n++)<span class="cstat-no" title="statement not covered" >if(u[n]!=d[n]){<span class="cstat-no" title="statement not covered" >p=u[n]&lt;d[n];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>o</span></span>=0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(p&amp;&amp;(r=u,u=d,d=r,e.s=-e.s),s=u.length,n=d.length-s;n&gt;0;--n)<span class="cstat-no" title="statement not covered" >u[s++]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=d.length;n&gt;o;){<span class="cstat-no" title="statement not covered" >if(u[--n]&lt;d[n]){<span class="cstat-no" title="statement not covered" >for(i=n;i&amp;&amp;u[--i]===0;)<span class="cstat-no" title="statement not covered" >u[i]=fe-1;<span class="cstat-no" title="statement not covered" >-</span></span>-u[i],u[n]+=fe}<span class="cstat-no" title="statement not covered" ></span>u</span>[n]-=d[n]}<span class="cstat-no" title="statement not covered" >f</span></span>or(;u[--s]===0;)<span class="cstat-no" title="statement not covered" >u.pop();<span class="cstat-no" title="statement not covered" >f</span></span>or(;u[0]===0;u.shift())<span class="cstat-no" title="statement not covered" >--t;<span class="cstat-no" title="statement not covered" >r</span></span>eturn u[0]?(e.d=u,e.e=bn(u,t),w?y(e,a,l):e):new h(l===3?-0:0)}</span>;m.modulo=m.mod=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return e=new n(e),!t.d||!e.s||e.d&amp;&amp;!e.d[0]?new n(NaN):!e.d||t.d&amp;&amp;!t.d[0]?y(new n(t),n.precision,n.rounding):(w=!1,n.modulo==9?(r=L(t,e.abs(),0,3,1),r.s*=e.s):r=L(t,e,0,n.modulo,1),r=r.times(e),w=!0,t.minus(r))}</span>;m.naturalExponential=m.exp=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn Wi(this)}</span>;m.naturalLogarithm=m.ln=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn Je(this)}</span>;m.negated=m.neg=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" >r</span>eturn e.s=-e.s,y(e)}</span>;m.plus=m.add=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t,n,i,o,s,a,l,u,c,p=<span class="cstat-no" title="statement not covered" >this,</span>d=<span class="cstat-no" title="statement not covered" >p.constructor;<span class="cstat-no" title="statement not covered" ></span>if(e=new d(e),!p.d||!e.d)<span class="cstat-no" title="statement not covered" >return!p.s||!e.s?e=new d(NaN):p.d||(e=new d(e.d||p.s===e.s?p:NaN)),e;<span class="cstat-no" title="statement not covered" >i</span></span>f(p.s!=e.s)<span class="cstat-no" title="statement not covered" >return e.s=-e.s,p.minus(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(u=p.d,c=e.d,a=d.precision,l=d.rounding,!u[0]||!c[0])<span class="cstat-no" title="statement not covered" >return c[0]||(e=new d(p)),w?y(e,a,l):e;<span class="cstat-no" title="statement not covered" >i</span></span>f(o=X(p.e/E),n=X(e.e/E),u=u.slice(),i=o-n,i){<span class="cstat-no" title="statement not covered" >for(i&lt;0?(t=u,i=-i,s=c.length):(t=c,n=o,s=u.length),o=Math.ceil(a/E),s=o&gt;s?o+1:s+1,i&gt;s&amp;&amp;(i=s,t.length=1),t.reverse();i--;)<span class="cstat-no" title="statement not covered" >t.push(0);<span class="cstat-no" title="statement not covered" >t</span></span>.reverse()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(s=u.length,i=c.length,s-i&lt;0&amp;&amp;(i=s,t=c,c=u,u=t),r=0;i;)<span class="cstat-no" title="statement not covered" >r=(u[--i]=u[i]+c[i]+r)/fe|0,u[i]%=fe;<span class="cstat-no" title="statement not covered" >f</span></span>or(r&amp;&amp;(u.unshift(r),++n),s=u.length;u[--s]==0;)<span class="cstat-no" title="statement not covered" >u.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.d=u,e.e=bn(u,n),w?y(e,a,l):e}</span>;m.precision=m.sd=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(e!==void 0&amp;&amp;e!==!!e&amp;&amp;e!==1&amp;&amp;e!==0)<span class="cstat-no" title="statement not covered" >throw Error(He+e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.d?(r=Ws(t.d),e&amp;&amp;t.e+1&gt;r&amp;&amp;(r=t.e+1)):r=NaN,r}</span>;m.round=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>return y(new r(e),e.e+1,r.rounding)}</span>;m.sine=m.sin=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=Ip(n,Ys(n,t)),n.precision=e,n.rounding=r,y(Fe&gt;2?t.neg():t,e,r,!0)):new n(NaN)}</span>;m.squareRoot=m.sqrt=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t,n,i,o,s=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >s.d,</span>l=<span class="cstat-no" title="statement not covered" >s.e,</span>u=<span class="cstat-no" title="statement not covered" >s.s,</span>c=<span class="cstat-no" title="statement not covered" >s.constructor;<span class="cstat-no" title="statement not covered" ></span>if(u!==1||!a||!a[0])<span class="cstat-no" title="statement not covered" >return new c(!u||u&lt;0&amp;&amp;(!a||a[0])?NaN:a?s:1/0);<span class="cstat-no" title="statement not covered" >f</span></span>or(w=!1,u=Math.sqrt(+s),u==0||u==1/0?(r=J(a),(r.length+l)%2==0&amp;&amp;(r+="0"),u=Math.sqrt(r),l=X((l+1)/2)-(l&lt;0||l%2),u==1/0?r="5e"+l:(r=u.toExponential(),r=r.slice(0,r.indexOf("e")+1)+l),n=new c(r)):n=new c(u.toString()),t=(l=c.precision)+3;;)<span class="cstat-no" title="statement not covered" >if(o=n,n=o.plus(L(s,o,t+2,1)).times(.5),J(o.d).slice(0,t)===(r=J(n.d)).slice(0,t))<span class="cstat-no" title="statement not covered" >if(r=r.slice(t-3,t+1),r=="9999"||!i&amp;&amp;r=="4999"){<span class="cstat-no" title="statement not covered" >if(!i&amp;&amp;(y(o,l+1,0),o.times(o).eq(s))){<span class="cstat-no" title="statement not covered" >n=o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span>+=4,i=1}</span>else{(<span class="cstat-no" title="statement not covered" >!+r||!+r.slice(1)&amp;&amp;r.charAt(0)=="5")&amp;&amp;(y(n,l+1,1),e=!n.times(n).eq(s));<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn w=!0,y(n,l,c.rounding,e)}</span>;m.tangent=m.tan=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,r,t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+10,n.rounding=1,t=t.sin(),t.s=1,t=L(t,new n(1).minus(t.times(t)).sqrt(),e+10,0),n.precision=e,n.rounding=r,y(Fe==2||Fe==4?t.neg():t,e,r,!0)):new n(NaN)}</span>;m.times=m.mul=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t,n,i,o,s,a,l,u,c=<span class="cstat-no" title="statement not covered" >this,</span>p=<span class="cstat-no" title="statement not covered" >c.constructor,</span>d=<span class="cstat-no" title="statement not covered" >c.d,</span>f=<span class="cstat-no" title="statement not covered" >(e=new p(e)).d;<span class="cstat-no" title="statement not covered" ></span>if(e.s*=c.s,!d||!d[0]||!f||!f[0])<span class="cstat-no" title="statement not covered" >return new p(!e.s||d&amp;&amp;!d[0]&amp;&amp;!f||f&amp;&amp;!f[0]&amp;&amp;!d?NaN:!d||!f?e.s/0:e.s*0);<span class="cstat-no" title="statement not covered" >f</span></span>or(t=X(c.e/E)+X(e.e/E),l=d.length,u=f.length,l&lt;u&amp;&amp;(o=d,d=f,f=o,s=l,l=u,u=s),o=[],s=l+u,n=s;n--;)<span class="cstat-no" title="statement not covered" >o.push(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(n=u;--n&gt;=0;){<span class="cstat-no" title="statement not covered" >for(r=0,i=l+n;i&gt;n;)<span class="cstat-no" title="statement not covered" >a=o[i]+f[n]*d[i-n-1]+r,o[i--]=a%fe|0,r=a/fe|0;<span class="cstat-no" title="statement not covered" >o</span></span>[i]=(o[i]+r)%fe|0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;!o[--s];)<span class="cstat-no" title="statement not covered" >o.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn r?++t:o.shift(),e.d=o,e.e=bn(o,t),w?y(e,p.precision,p.rounding):e}</span>;m.toBinary=<span class="fstat-no" title="function not covered" >function(e</span>,r){<span class="cstat-no" title="statement not covered" >return Ji(this,2,e,r)}</span>;m.toDecimalPlaces=m.toDP=<span class="fstat-no" title="function not covered" >function(e</span>,r){var t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return t=new n(t),e===void 0?t:(ie(e,0,Ke),r===void 0?r=n.rounding:ie(r,0,8),y(t,e+t.e+1,r))}</span>;m.toExponential=<span class="fstat-no" title="function not covered" >function(e</span>,r){var t,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?t=xe(n,!0):(ie(e,0,Ke),r===void 0?r=i.rounding:ie(r,0,8),n=y(new i(n),e+1,r),t=xe(n,!0,e+1)),n.isNeg()&amp;&amp;!n.isZero()?"-"+t:t}</span>;m.toFixed=<span class="fstat-no" title="function not covered" >function(e</span>,r){var t,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?t=xe(i):(ie(e,0,Ke),r===void 0?r=o.rounding:ie(r,0,8),n=y(new o(i),e+i.e+1,r),t=xe(n,!1,e+n.e+1)),i.isNeg()&amp;&amp;!i.isZero()?"-"+t:t}</span>;m.toFraction=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t,n,i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >f.d,</span>g=<span class="cstat-no" title="statement not covered" >f.constructor;<span class="cstat-no" title="statement not covered" ></span>if(!h)<span class="cstat-no" title="statement not covered" >return new g(f);<span class="cstat-no" title="statement not covered" >i</span></span>f(u=t=new g(1),n=l=new g(0),r=new g(n),o=r.e=Ws(h)-f.e-1,s=o%E,r.d[0]=U(10,s&lt;0?E+s:s),e==null)<span class="cstat-no" title="statement not covered" >e=o&gt;0?r:u;else{<span class="cstat-no" title="statement not covered" ></span>if(a=new g(e),!a.isInt()||a.lt(u))<span class="cstat-no" title="statement not covered" >throw Error(He+a);<span class="cstat-no" title="statement not covered" >e</span></span>=a.gt(r)?o&gt;0?r:u:a}<span class="cstat-no" title="statement not covered" ></span>f</span>or(w=!1,a=new g(J(h)),c=g.precision,g.precision=o=h.length*E*2;p=L(a,r,0,1,1),i=t.plus(p.times(n)),i.cmp(e)!=1;)<span class="cstat-no" title="statement not covered" >t=n,n=i,i=u,u=l.plus(p.times(i)),l=i,i=r,r=a.minus(p.times(i)),a=i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i=L(e.minus(t),n,0,1,1),l=l.plus(i.times(u)),t=t.plus(i.times(n)),l.s=u.s=f.s,d=L(u,n,o,1).minus(f).abs().cmp(L(l,t,o,1).minus(f).abs())&lt;1?[u,n]:[l,t],g.precision=c,w=!0,d}</span>;m.toHexadecimal=m.toHex=<span class="fstat-no" title="function not covered" >function(e</span>,r){<span class="cstat-no" title="statement not covered" >return Ji(this,16,e,r)}</span>;m.toNearest=<span class="fstat-no" title="function not covered" >function(e</span>,r){var t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>if(t=new n(t),e==null){<span class="cstat-no" title="statement not covered" >if(!t.d)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >e</span></span>=new n(1),r=n.rounding}else{<span class="cstat-no" title="statement not covered" ></span>if(e=new n(e),r===void 0?r=n.rounding:ie(r,0,8),!t.d)<span class="cstat-no" title="statement not covered" >return e.s?t:e;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.d)<span class="cstat-no" title="statement not covered" >return e.s&amp;&amp;(e.s=t.s),e}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e.d[0]?(w=!1,t=L(t,e,0,r,1).times(e),w=!0,y(t)):(e.s=t.s,t=e),t}</span>;m.toNumber=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn+this};m</span>.toOctal=<span class="fstat-no" title="function not covered" >function(e</span>,r){<span class="cstat-no" title="statement not covered" >return Ji(this,8,e,r)}</span>;m.toPower=m.pow=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t,n,i,o,s,a=<span class="cstat-no" title="statement not covered" >this,</span>l=<span class="cstat-no" title="statement not covered" >a.constructor,</span>u=<span class="cstat-no" title="statement not covered" >+(e=new l(e));<span class="cstat-no" title="statement not covered" >i</span>f(!a.d||!e.d||!a.d[0]||!e.d[0])<span class="cstat-no" title="statement not covered" >return new l(U(+a,u));<span class="cstat-no" title="statement not covered" >i</span></span>f(a=new l(a),a.eq(1))<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >i</span></span>f(n=l.precision,o=l.rounding,e.eq(1))<span class="cstat-no" title="statement not covered" >return y(a,n,o);<span class="cstat-no" title="statement not covered" >i</span></span>f(r=X(e.e/E),r&gt;=e.d.length-1&amp;&amp;(t=u&lt;0?-u:u)&lt;=Sp)<span class="cstat-no" title="statement not covered" >return i=Js(l,a,t,n),e.s&lt;0?new l(1).div(i):y(i,n,o);<span class="cstat-no" title="statement not covered" >i</span></span>f(s=a.s,s&lt;0){<span class="cstat-no" title="statement not covered" >if(r&lt;e.d.length-1)<span class="cstat-no" title="statement not covered" >return new l(NaN);<span class="cstat-no" title="statement not covered" >i</span></span>f((e.d[r]&amp;1)==0&amp;&amp;(s=1),a.e==0&amp;&amp;a.d[0]==1&amp;&amp;a.d.length==1)<span class="cstat-no" title="statement not covered" >return a.s=s,a}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t=U(+a,u),r=t==0||!isFinite(t)?X(u*(Math.log("0."+J(a.d))/Math.LN10+a.e+1)):new l(t+"").e,r&gt;l.maxE+1||r&lt;l.minE-1?new l(r&gt;0?s/0:0):(w=!1,l.rounding=a.s=1,t=Math.min(12,(r+"").length),i=Wi(e.times(Je(a,n+t)),n),i.d&amp;&amp;(i=y(i,n+5,1),lt(i.d,n,o)&amp;&amp;(r=n+10,i=y(Wi(e.times(Je(a,r+t)),r),r+5,1),+J(i.d).slice(n+1,n+15)+1==1e14&amp;&amp;(i=y(i,n+1,0)))),i.s=s,w=!0,l.rounding=o,y(i,n,o))}</span>;m.toPrecision=<span class="fstat-no" title="function not covered" >function(e</span>,r){var t,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?t=xe(n,n.e&lt;=i.toExpNeg||n.e&gt;=i.toExpPos):(ie(e,1,Ke),r===void 0?r=i.rounding:ie(r,0,8),n=y(new i(n),e,r),t=xe(n,e&lt;=n.e||n.e&lt;=i.toExpNeg,e)),n.isNeg()&amp;&amp;!n.isZero()?"-"+t:t}</span>;m.toSignificantDigits=m.toSD=<span class="fstat-no" title="function not covered" >function(e</span>,r){var t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?(e=n.precision,r=n.rounding):(ie(e,1,Ke),r===void 0?r=n.rounding:ie(r,0,8)),y(new n(t),e,r)}</span>;m.toString=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >e.constructor,</span>t=<span class="cstat-no" title="statement not covered" >xe(e,e.e&lt;=r.toExpNeg||e.e&gt;=r.toExpPos);<span class="cstat-no" title="statement not covered" >r</span>eturn e.isNeg()&amp;&amp;!e.isZero()?"-"+t:t}</span>;m.truncated=m.trunc=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn y(new this.constructor(this),this.e+1,1)}</span>;m.valueOf=m.toJSON=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >e.constructor,</span>t=<span class="cstat-no" title="statement not covered" >xe(e,e.e&lt;=r.toExpNeg||e.e&gt;=r.toExpPos);<span class="cstat-no" title="statement not covered" >r</span>eturn e.isNeg()?"-"+t:t}</span>;function <span class="fstat-no" title="function not covered" >J(e</span>){var r,t,n,i=<span class="cstat-no" title="statement not covered" >e.length-1,o</span>=<span class="cstat-no" title="statement not covered" >"",s</span>=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>if(i&gt;0){<span class="cstat-no" title="statement not covered" >for(o+=s,r=1;r&lt;i;r++)<span class="cstat-no" title="statement not covered" >n=e[r]+"",t=E-n.length,t&amp;&amp;(o+=We(t)),o+=n;<span class="cstat-no" title="statement not covered" >s</span></span>=e[r],n=s+"",t=E-n.length,t&amp;&amp;(o+=We(t))}</span>else <span class="cstat-no" title="statement not covered" >if(s===0)<span class="cstat-no" title="statement not covered" >return"0";<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;s%10===0;)<span class="cstat-no" title="statement not covered" >s/=10;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o+s}</span>function <span class="fstat-no" title="function not covered" >ie(e</span>,r,t){<span class="cstat-no" title="statement not covered" >if(e!==~~e||e&lt;r||e&gt;t)<span class="cstat-no" title="statement not covered" >throw Error(He+e)}</span></span>function <span class="fstat-no" title="function not covered" >lt(e</span>,r,t,n){var i,o,s,a;<span class="cstat-no" title="statement not covered" >for(o=e[0];o&gt;=10;o/=10)<span class="cstat-no" title="statement not covered" >--r;<span class="cstat-no" title="statement not covered" >r</span></span>eturn--r&lt;0?(r+=E,i=0):(i=Math.ceil((r+1)/E),r%=E),o=U(10,E-r),a=e[i]%o|0,n==null?r&lt;3?(r==0?a=a/100|0:r==1&amp;&amp;(a=a/10|0),s=t&lt;4&amp;&amp;a==99999||t&gt;3&amp;&amp;a==49999||a==5e4||a==0):s=(t&lt;4&amp;&amp;a+1==o||t&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/100|0)==U(10,r-2)-1||(a==o/2||a==0)&amp;&amp;(e[i+1]/o/100|0)==0:r&lt;4?(r==0?a=a/1e3|0:r==1?a=a/100|0:r==2&amp;&amp;(a=a/10|0),s=(n||t&lt;4)&amp;&amp;a==9999||!n&amp;&amp;t&gt;3&amp;&amp;a==4999):s=((n||t&lt;4)&amp;&amp;a+1==o||!n&amp;&amp;t&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/1e3|0)==U(10,r-3)-1,s}</span>function <span class="fstat-no" title="function not covered" >dn(e</span>,r,t){<span class="cstat-no" title="statement not covered" >for(var n,i=<span class="cstat-no" title="statement not covered" >[0],o</span>,s=<span class="cstat-no" title="statement not covered" >0,a</span>=<span class="cstat-no" title="statement not covered" >e.length;</span>s&lt;a;){<span class="cstat-no" title="statement not covered" >for(o=i.length;o--;)<span class="cstat-no" title="statement not covered" >i[o]*=r;<span class="cstat-no" title="statement not covered" >f</span></span>or(i[0]+=Ui.indexOf(e.charAt(s++)),n=0;n&lt;i.length;n++)<span class="cstat-no" title="statement not covered" >i[n]&gt;t-1&amp;&amp;(i[n+1]===void 0&amp;&amp;(i[n+1]=0),i[n+1]+=i[n]/t|0,i[n]%=t)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn i.reverse()}</span>function <span class="fstat-no" title="function not covered" >Ap(e</span>,r){var t,n,i;<span class="cstat-no" title="statement not covered" >if(r.isZero())<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >n</span></span>=r.d.length,n&lt;32?(t=Math.ceil(n/3),i=(1/En(4,t)).toString()):(t=16,i="2.3283064365386962890625e-10"),e.precision+=t,r=Pr(e,1,r.times(i),new e(1));<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >t;o</span>--;){var s=<span class="cstat-no" title="statement not covered" >r.times(r);<span class="cstat-no" title="statement not covered" >r</span>=s.times(s).minus(s).times(8).plus(1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.precision-=t,r}</span>var L=function(){function <span class="fstat-no" title="function not covered" >e(n</span>,i,o){var s,a=<span class="cstat-no" title="statement not covered" >0,l</span>=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>for(n=n.slice();l--;)<span class="cstat-no" title="statement not covered" >s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a&amp;&amp;n.unshift(a),n}</span>function <span class="fstat-no" title="function not covered" >r(n</span>,i,o,s){var a,l;<span class="cstat-no" title="statement not covered" >if(o!=s)<span class="cstat-no" title="statement not covered" >l=o&gt;s?1:-1;else <span class="cstat-no" title="statement not covered" >f</span>or(a=l=0;a&lt;o;a++)<span class="cstat-no" title="statement not covered" >if(n[a]!=i[a]){<span class="cstat-no" title="statement not covered" >l=n[a]&gt;i[a]?1:-1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn l}</span>function <span class="fstat-no" title="function not covered" >t(n</span>,i,o,s){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;o</span>--;)<span class="cstat-no" title="statement not covered" >n[o]-=a,a=n[o]&lt;i[o]?1:0,n[o]=a*s+n[o]-i[o];<span class="cstat-no" title="statement not covered" >f</span></span>or(;!n[0]&amp;&amp;n.length&gt;1;)<span class="cstat-no" title="statement not covered" >n.shift()}</span></span>return <span class="fstat-no" title="function not covered" >function(n</span>,i,o,s,a,l){var u,c,p,d,f,h,g,S,P,R,b,D,me,ae,Hr,V,te,Ce,H,fr,jt=<span class="cstat-no" title="statement not covered" >n.constructor,</span>ni=<span class="cstat-no" title="statement not covered" >n.s==i.s?1:-1,K</span>=<span class="cstat-no" title="statement not covered" >n.d,</span>_=<span class="cstat-no" title="statement not covered" >i.d;<span class="cstat-no" title="statement not covered" ></span>if(!K||!K[0]||!_||!_[0])<span class="cstat-no" title="statement not covered" >return new jt(!n.s||!i.s||(K?_&amp;&amp;K[0]==_[0]:!_)?NaN:K&amp;&amp;K[0]==0||!_?ni*0:ni/0);<span class="cstat-no" title="statement not covered" >f</span></span>or(l?(f=1,c=n.e-i.e):(l=fe,f=E,c=X(n.e/f)-X(i.e/f)),H=_.length,te=K.length,P=new jt(ni),R=P.d=[],p=0;_[p]==(K[p]||0);p++);<span class="cstat-no" title="statement not covered" >i</span>f(_[p]&gt;(K[p]||0)&amp;&amp;c--,o==null?(ae=o=jt.precision,s=jt.rounding):a?ae=o+(n.e-i.e)+1:ae=o,ae&lt;0)<span class="cstat-no" title="statement not covered" >R.push(1),h=!0;else{<span class="cstat-no" title="statement not covered" ></span>if(ae=ae/f+2|0,p=0,H==1){<span class="cstat-no" title="statement not covered" >for(d=0,_=_[0],ae++;(p&lt;te||d)&amp;&amp;ae--;p++)<span class="cstat-no" title="statement not covered" >Hr=d*l+(K[p]||0),R[p]=Hr/_|0,d=Hr%_|0;<span class="cstat-no" title="statement not covered" >h</span></span>=d||p&lt;te}</span>else{<span class="cstat-no" title="statement not covered" >for(d=l/(_[0]+1)|0,d&gt;1&amp;&amp;(_=e(_,d,l),K=e(K,d,l),H=_.length,te=K.length),V=H,b=K.slice(0,H),D=b.length;D&lt;H;)<span class="cstat-no" title="statement not covered" >b[D++]=0;<span class="cstat-no" title="statement not covered" >f</span></span>r=_.slice(),fr.unshift(0),Ce=_[0],_[1]&gt;=l/2&amp;&amp;++Ce;<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >d=0,u=r(_,b,H,D),u&lt;0?(me=b[0],H!=D&amp;&amp;(me=me*l+(b[1]||0)),d=me/Ce|0,d&gt;1?(d&gt;=l&amp;&amp;(d=l-1),g=e(_,d,l),S=g.length,D=b.length,u=r(g,b,S,D),u==1&amp;&amp;(d--,t(g,H&lt;S?fr:_,S,l))):(d==0&amp;&amp;(u=d=1),g=_.slice()),S=g.length,S&lt;D&amp;&amp;g.unshift(0),t(b,g,D,l),u==-1&amp;&amp;(D=b.length,u=r(_,b,H,D),u&lt;1&amp;&amp;(d++,t(b,H&lt;D?fr:_,D,l))),D=b.length):u===0&amp;&amp;(d++,b=[0]),R[p++]=d,u&amp;&amp;b[0]?b[D++]=K[V]||0:(b=[K[V]],D=1);while((</span>V++&lt;te||b[0]!==void 0)&amp;&amp;ae--);<span class="cstat-no" title="statement not covered" >h</span>=b[0]!==void 0}<span class="cstat-no" title="statement not covered" ></span>R</span>[0]||R.shift()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(f==1)<span class="cstat-no" title="statement not covered" >P.e=c,Vs=h;else{<span class="cstat-no" title="statement not covered" ></span>for(p=1,d=R[0];d&gt;=10;d/=10)<span class="cstat-no" title="statement not covered" >p++;<span class="cstat-no" title="statement not covered" >P</span></span>.e=p+c*f-1,y(P,a?o+P.e+1:o,s,h)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn P}</span>}();function <span class="fstat-no" title="function not covered" >y(e</span>,r,t,n){var i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>e:<span class="cstat-no" title="statement not covered" >if(r!=null){<span class="cstat-no" title="statement not covered" >if(p=e.d,!p)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=1,a=p[0];a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >i</span></span>f(o=r-i,o&lt;0)<span class="cstat-no" title="statement not covered" >o+=E,s=r,c=p[d=0],l=c/U(10,i-s-1)%10|0;else <span class="cstat-no" title="statement not covered" >i</span>f(d=Math.ceil((o+1)/E),a=p.length,d&gt;=a)<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >for(;a++&lt;=d;)<span class="cstat-no" title="statement not covered" >p.push(0);<span class="cstat-no" title="statement not covered" >c</span></span>=l=0,i=1,o%=E,s=o-E+1}</span>else <span class="cstat-no" title="statement not covered" >break e;else{<span class="cstat-no" title="statement not covered" ></span></span>for(c=a=p[d],i=1;a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >o</span></span>%=E,s=o-E+i,l=s&lt;0?0:c/U(10,i-s-1)%10|0}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(n=n||r&lt;0||p[d+1]!==void 0||(s&lt;0?c:c%U(10,i-s-1)),u=t&lt;4?(l||n)&amp;&amp;(t==0||t==(e.s&lt;0?3:2)):l&gt;5||l==5&amp;&amp;(t==4||n||t==6&amp;&amp;(o&gt;0?s&gt;0?c/U(10,i-s):0:p[d-1])%10&amp;1||t==(e.s&lt;0?8:7)),r&lt;1||!p[0])<span class="cstat-no" title="statement not covered" >return p.length=0,u?(r-=e.e+1,p[0]=U(10,(E-r%E)%E),e.e=-r||0):p[0]=e.e=0,e;<span class="cstat-no" title="statement not covered" >i</span></span>f(o==0?(p.length=d,a=1,d--):(p.length=d+1,a=U(10,E-o),p[d]=s&gt;0?(c/U(10,i-s)%U(10,s)|0)*a:0),u)<span class="cstat-no" title="statement not covered" >for(;;)<span class="cstat-no" title="statement not covered" >if(d==0){<span class="cstat-no" title="statement not covered" >for(o=1,s=p[0];s&gt;=10;s/=10)<span class="cstat-no" title="statement not covered" >o++;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=p[0]+=a,a=1;s&gt;=10;s/=10)<span class="cstat-no" title="statement not covered" >a++;<span class="cstat-no" title="statement not covered" >o</span></span>!=a&amp;&amp;(e.e++,p[0]==fe&amp;&amp;(p[0]=1));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>else{<span class="cstat-no" title="statement not covered" >if(p[d]+=a,p[d]!=fe)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >p</span></span>[d--]=0,a=1}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(o=p.length;p[--o]===0;)<span class="cstat-no" title="statement not covered" >p.pop()}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn w&amp;&amp;(e.e&gt;f.maxE?(e.d=null,e.e=NaN):e.e&lt;f.minE&amp;&amp;(e.e=0,e.d=[0])),e}</span>function <span class="fstat-no" title="function not covered" >xe(e</span>,r,t){<span class="cstat-no" title="statement not covered" >if(!e.isFinite())<span class="cstat-no" title="statement not covered" >return Ks(e);v</span></span>ar n,i=<span class="cstat-no" title="statement not covered" >e.e,</span>o=<span class="cstat-no" title="statement not covered" >J(e.d),s</span>=<span class="cstat-no" title="statement not covered" >o.length;<span class="cstat-no" title="statement not covered" ></span>return r?(t&amp;&amp;(n=t-s)&gt;0?o=o.charAt(0)+"."+o.slice(1)+We(n):s&gt;1&amp;&amp;(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e&lt;0?"e":"e+")+e.e):i&lt;0?(o="0."+We(-i-1)+o,t&amp;&amp;(n=t-s)&gt;0&amp;&amp;(o+=We(n))):i&gt;=s?(o+=We(i+1-s),t&amp;&amp;(n=t-i-1)&gt;0&amp;&amp;(o=o+"."+We(n))):((n=i+1)&lt;s&amp;&amp;(o=o.slice(0,n)+"."+o.slice(n)),t&amp;&amp;(n=t-s)&gt;0&amp;&amp;(i+1===s&amp;&amp;(o+="."),o+=We(n))),o}</span>function <span class="fstat-no" title="function not covered" >bn(e</span>,r){var t=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>for(r*=E;t&gt;=10;t/=10)<span class="cstat-no" title="statement not covered" >r++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >hn(e</span>,r,t){<span class="cstat-no" title="statement not covered" >if(r&gt;Rp)<span class="cstat-no" title="statement not covered" >throw w=!0,t&amp;&amp;(e.precision=t),Error(Bs);<span class="cstat-no" title="statement not covered" >r</span></span>eturn y(new e(fn),r,1,!0)}</span>function <span class="fstat-no" title="function not covered" >we(e</span>,r,t){<span class="cstat-no" title="statement not covered" >if(r&gt;Qi)<span class="cstat-no" title="statement not covered" >throw Error(Bs);<span class="cstat-no" title="statement not covered" >r</span></span>eturn y(new e(gn),r,t,!0)}</span>function <span class="fstat-no" title="function not covered" >Ws(e</span>){var r=<span class="cstat-no" title="statement not covered" >e.length-1,t</span>=<span class="cstat-no" title="statement not covered" >r*E+1;<span class="cstat-no" title="statement not covered" >i</span>f(r=e[r],r){<span class="cstat-no" title="statement not covered" >for(;r%10==0;r/=10)<span class="cstat-no" title="statement not covered" >t--;<span class="cstat-no" title="statement not covered" >f</span></span>or(r=e[0];r&gt;=10;r/=10)<span class="cstat-no" title="statement not covered" >t++}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >We(e</span>){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >"";e</span>--;)<span class="cstat-no" title="statement not covered" >r+="0";<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Js(e</span>,r,t,n){var i,o=<span class="cstat-no" title="statement not covered" >new e(1),s</span>=<span class="cstat-no" title="statement not covered" >Math.ceil(n/E+4);<span class="cstat-no" title="statement not covered" >f</span>or(w=!1;;){<span class="cstat-no" title="statement not covered" >if(t%2&amp;&amp;(o=o.times(r),qs(o.d,s)&amp;&amp;(i=!0)),t=X(t/2),t===0){<span class="cstat-no" title="statement not covered" >t=o.d.length-1,i&amp;&amp;o.d[t]===0&amp;&amp;++o.d[t];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>=r.times(r),qs(r.d,s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn w=!0,o}</span>function <span class="fstat-no" title="function not covered" >$s(e</span>){<span class="cstat-no" title="statement not covered" >return e.d[e.d.length-1]&amp;1}</span>function <span class="fstat-no" title="function not covered" >Hs(e</span>,r,t){<span class="cstat-no" title="statement not covered" >for(var n,i,o=<span class="cstat-no" title="statement not covered" >new e(r[0]),s</span>=<span class="cstat-no" title="statement not covered" >0;+</span>+s&lt;r.length;){<span class="cstat-no" title="statement not covered" >if(i=new e(r[s]),!i.s){<span class="cstat-no" title="statement not covered" >o=i;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>n</span>=o.cmp(i),(n===t||n===0&amp;&amp;o.s===t)&amp;&amp;(o=i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>function <span class="fstat-no" title="function not covered" >Wi(e</span>,r){var t,n,i,o,s,a,l,u=<span class="cstat-no" title="statement not covered" >0,c</span>=<span class="cstat-no" title="statement not covered" >0,p</span>=<span class="cstat-no" title="statement not covered" >0,d</span>=<span class="cstat-no" title="statement not covered" >e.constructor,</span>f=<span class="cstat-no" title="statement not covered" >d.rounding,</span>h=<span class="cstat-no" title="statement not covered" >d.precision;<span class="cstat-no" title="statement not covered" ></span>if(!e.d||!e.d[0]||e.e&gt;17)<span class="cstat-no" title="statement not covered" >return new d(e.d?e.d[0]?e.s&lt;0?0:1/0:1:e.s?e.s&lt;0?0:e:NaN);<span class="cstat-no" title="statement not covered" >f</span></span>or(r==null?(w=!1,l=h):l=r,a=new d(.03125);e.e&gt;-2;)<span class="cstat-no" title="statement not covered" >e=e.times(a),p+=5;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=Math.log(U(2,p))/Math.LN10*2+5|0,l+=n,t=o=s=new d(1),d.precision=l;;){<span class="cstat-no" title="statement not covered" >if(o=y(o.times(e),l,1),t=t.times(++c),a=s.plus(L(o,t,l,1)),J(a.d).slice(0,l)===J(s.d).slice(0,l)){<span class="cstat-no" title="statement not covered" >for(i=p;i--;)<span class="cstat-no" title="statement not covered" >s=y(s.times(s),l,1);<span class="cstat-no" title="statement not covered" >i</span></span>f(r==null)<span class="cstat-no" title="statement not covered" >if(u&lt;3&amp;&amp;lt(s.d,l-n,f,u))<span class="cstat-no" title="statement not covered" >d.precision=l+=10,t=o=a=new d(1),c=0,u++;else <span class="cstat-no" title="statement not covered" >r</span>eturn y(s,d.precision=h,f,w=!0);else <span class="cstat-no" title="statement not covered" >r</span></span>eturn d.precision=h,s}<span class="cstat-no" title="statement not covered" ></span></span>s</span>=a}</span>}</span>function <span class="fstat-no" title="function not covered" >Je(e</span>,r){var t,n,i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >1,h</span>=<span class="cstat-no" title="statement not covered" >10,g</span>=<span class="cstat-no" title="statement not covered" >e,S</span>=<span class="cstat-no" title="statement not covered" >g.d,</span>P=<span class="cstat-no" title="statement not covered" >g.constructor,</span>R=<span class="cstat-no" title="statement not covered" >P.rounding,</span>b=<span class="cstat-no" title="statement not covered" >P.precision;<span class="cstat-no" title="statement not covered" ></span>if(g.s&lt;0||!S||!S[0]||!g.e&amp;&amp;S[0]==1&amp;&amp;S.length==1)<span class="cstat-no" title="statement not covered" >return new P(S&amp;&amp;!S[0]?-1/0:g.s!=1?NaN:S?0:g);<span class="cstat-no" title="statement not covered" >i</span></span>f(r==null?(w=!1,c=b):c=r,P.precision=c+=h,t=J(S),n=t.charAt(0),Math.abs(o=g.e)&lt;15e14){<span class="cstat-no" title="statement not covered" >for(;n&lt;7&amp;&amp;n!=1||n==1&amp;&amp;t.charAt(1)&gt;3;)<span class="cstat-no" title="statement not covered" >g=g.times(e),t=J(g.d),n=t.charAt(0),f++;<span class="cstat-no" title="statement not covered" >o</span></span>=g.e,n&gt;1?(g=new P("0."+t),o++):g=new P(n+"."+t.slice(1))}</span>else <span class="cstat-no" title="statement not covered" >return u=hn(P,c+2,b).times(o+""),g=Je(new P(n+"."+t.slice(1)),c-h).plus(u),P.precision=b,r==null?y(g,b,R,w=!0):g;<span class="cstat-no" title="statement not covered" >f</span></span>or(p=g,l=s=g=L(g.minus(1),g.plus(1),c,1),d=y(g.times(g),c,1),i=3;;){<span class="cstat-no" title="statement not covered" >if(s=y(s.times(d),c,1),u=l.plus(L(s,new P(i),c,1)),J(u.d).slice(0,c)===J(l.d).slice(0,c))<span class="cstat-no" title="statement not covered" >if(l=l.times(2),o!==0&amp;&amp;(l=l.plus(hn(P,c+2,b).times(o+""))),l=L(l,new P(f),c,1),r==null)<span class="cstat-no" title="statement not covered" >if(lt(l.d,c-h,R,a))<span class="cstat-no" title="statement not covered" >P.precision=c+=h,u=s=g=L(p.minus(1),p.plus(1),c,1),d=y(g.times(g),c,1),i=a=1;else <span class="cstat-no" title="statement not covered" >r</span>eturn y(l,P.precision=b,R,w=!0);else <span class="cstat-no" title="statement not covered" >r</span></span>eturn P.precision=b,l;<span class="cstat-no" title="statement not covered" >l</span></span></span>=u,i+=2}</span>}</span>function <span class="fstat-no" title="function not covered" >Ks(e</span>){<span class="cstat-no" title="statement not covered" >return String(e.s*e.s/0)}</span>function mn(e,r){var t,n,i;for((t=r.indexOf("."))&gt;-1&amp;&amp;(r=r.replace(".","")),(n=r.search(/e/i))&gt;0?(<span class="branch-0 cbranch-no" title="branch not covered" >t&lt;0&amp;&amp;(t=n),t+=+r.slice(n+1),r=r.substring(0,n)</span>):t&lt;0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t=r.length)</span>,n=0;r.charCodeAt(n)===48;n++);for(i=r.length;r.charCodeAt(i-1)===48;--i);if(r=r.slice(n,i),r){if(i-=n,e.e=t=t-n-1,e.d=[],n=(t+1)%E,t&lt;0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >n+=E),n</span>&lt;i){for(n&amp;&amp;e.d.push(+r.slice(0,n)),i-=E;n&lt;i;)e.d.push(+r.slice(n,n+=E));r=r.slice(n),n=E-r.length}else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>n-=i;f</span>or(;n--;)r+="0";e.d.push(+r),w&amp;&amp;(e.e&gt;e.constructor.maxE?(<span class="branch-0 cbranch-no" title="branch not covered" >e.d=null,e.e=NaN</span>):e.e&lt;e.constructor.minE&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.e=0,e.d=[0]))}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>e.e=0,e.d=[0];r</span>eturn e}function <span class="fstat-no" title="function not covered" >Cp(e</span>,r){var t,n,i,o,s,a,l,u,c;<span class="cstat-no" title="statement not covered" >if(r.indexOf("_")&gt;-1){<span class="cstat-no" title="statement not covered" >if(r=r.replace(/(\d)_(?=\d)/g,"$1"),Qs.test(r))<span class="cstat-no" title="statement not covered" >return mn(e,r)}</span></span>else <span class="cstat-no" title="statement not covered" >if(r==="Infinity"||r==="NaN")<span class="cstat-no" title="statement not covered" >return+r||(e.s=NaN),e.e=NaN,e.d=null,e;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(Pp.test(r))<span class="cstat-no" title="statement not covered" >t=16,r=r.toLowerCase();else <span class="cstat-no" title="statement not covered" >i</span>f(vp.test(r))<span class="cstat-no" title="statement not covered" >t=2;else <span class="cstat-no" title="statement not covered" >i</span>f(Tp.test(r))<span class="cstat-no" title="statement not covered" >t=8;else <span class="cstat-no" title="statement not covered" >t</span>hrow Error(He+r);<span class="cstat-no" title="statement not covered" >f</span></span></span></span>or(o=r.search(/p/i),o&gt;0?(l=+r.slice(o+1),r=r.substring(2,o)):r=r.slice(2),o=r.indexOf("."),s=o&gt;=0,n=e.constructor,s&amp;&amp;(r=r.replace(".",""),a=r.length,o=a-o,i=Js(n,new n(t),o,o*2)),u=dn(r,t,fe),c=u.length-1,o=c;u[o]===0;--o)<span class="cstat-no" title="statement not covered" >u.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn o&lt;0?new n(e.s*0):(e.e=bn(u,c),e.d=u,w=!1,s&amp;&amp;(e=L(e,i,a*4)),l&amp;&amp;(e=e.times(Math.abs(l)&lt;54?U(2,l):ar.pow(2,l))),w=!0,e)}</span>function <span class="fstat-no" title="function not covered" >Ip(e</span>,r){var t,n=<span class="cstat-no" title="statement not covered" >r.d.length;<span class="cstat-no" title="statement not covered" ></span>if(n&lt;3)<span class="cstat-no" title="statement not covered" >return r.isZero()?r:Pr(e,2,r,r);<span class="cstat-no" title="statement not covered" >t</span></span>=1.4*Math.sqrt(n),t=t&gt;16?16:t|0,r=r.times(1/En(5,t)),r=Pr(e,2,r,r);<span class="cstat-no" title="statement not covered" >f</span>or(var i,o=<span class="cstat-no" title="statement not covered" >new e(5),s</span>=<span class="cstat-no" title="statement not covered" >new e(16),a</span>=<span class="cstat-no" title="statement not covered" >new e(20);t</span>--;)<span class="cstat-no" title="statement not covered" >i=r.times(r),r=r.times(o.plus(i.times(s.times(i).minus(a))));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Pr(e</span>,r,t,n,i){var o,s,a,l,u=<span class="cstat-no" title="statement not covered" >1,c</span>=<span class="cstat-no" title="statement not covered" >e.precision,</span>p=<span class="cstat-no" title="statement not covered" >Math.ceil(c/E);<span class="cstat-no" title="statement not covered" >f</span>or(w=!1,l=t.times(t),a=new e(n);;){<span class="cstat-no" title="statement not covered" >if(s=L(a.times(l),new e(r++*r++),c,1),a=i?n.plus(s):n.minus(s),n=L(s.times(l),new e(r++*r++),c,1),s=a.plus(n),s.d[p]!==void 0){<span class="cstat-no" title="statement not covered" >for(o=p;s.d[o]===a.d[o]&amp;&amp;o--;);<span class="cstat-no" title="statement not covered" >i</span>f(o==-1)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>o</span>=a,a=n,n=s,s=o,u++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn w=!0,s.d.length=p+1,s}</span>function <span class="fstat-no" title="function not covered" >En(e</span>,r){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >e;-</span>-r;)<span class="cstat-no" title="statement not covered" >t*=e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Ys(e</span>,r){var t,n=<span class="cstat-no" title="statement not covered" >r.s&lt;0,i</span>=<span class="cstat-no" title="statement not covered" >we(e,e.precision,1),o</span>=<span class="cstat-no" title="statement not covered" >i.times(.5);<span class="cstat-no" title="statement not covered" >i</span>f(r=r.abs(),r.lte(o))<span class="cstat-no" title="statement not covered" >return Fe=n?4:1,r;<span class="cstat-no" title="statement not covered" >i</span></span>f(t=r.divToInt(i),t.isZero())<span class="cstat-no" title="statement not covered" >Fe=n?3:2;else{<span class="cstat-no" title="statement not covered" ></span>if(r=r.minus(t.times(i)),r.lte(o))<span class="cstat-no" title="statement not covered" >return Fe=$s(t)?n?2:3:n?4:1,r;<span class="cstat-no" title="statement not covered" >F</span></span>e=$s(t)?n?1:4:n?3:2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.minus(i).abs()}</span>function <span class="fstat-no" title="function not covered" >Ji(e</span>,r,t,n){var i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >e.constructor,</span>h=<span class="cstat-no" title="statement not covered" >t!==void 0;<span class="cstat-no" title="statement not covered" >i</span>f(h?(ie(t,1,Ke),n===void 0?n=f.rounding:ie(n,0,8)):(t=f.precision,n=f.rounding),!e.isFinite())<span class="cstat-no" title="statement not covered" >c=Ks(e);else{<span class="cstat-no" title="statement not covered" ></span>for(c=xe(e),s=c.indexOf("."),h?(i=2,r==16?t=t*4-3:r==8&amp;&amp;(t=t*3-2)):i=r,s&gt;=0&amp;&amp;(c=c.replace(".",""),d=new f(1),d.e=c.length-s,d.d=dn(xe(d),10,i),d.e=d.d.length),p=dn(c,10,i),o=l=p.length;p[--l]==0;)<span class="cstat-no" title="statement not covered" >p.pop();<span class="cstat-no" title="statement not covered" >i</span></span>f(!p[0])<span class="cstat-no" title="statement not covered" >c=h?"0p+0":"0";else{<span class="cstat-no" title="statement not covered" ></span>if(s&lt;0?o--:(e=new f(e),e.d=p,e.e=o,e=L(e,d,t,n,0,i),p=e.d,o=e.e,u=Vs),s=p[t],a=i/2,u=u||p[t+1]!==void 0,u=n&lt;4?(s!==void 0||u)&amp;&amp;(n===0||n===(e.s&lt;0?3:2)):s&gt;a||s===a&amp;&amp;(n===4||u||n===6&amp;&amp;p[t-1]&amp;1||n===(e.s&lt;0?8:7)),p.length=t,u)<span class="cstat-no" title="statement not covered" >for(;++p[--t]&gt;i-1;)<span class="cstat-no" title="statement not covered" >p[t]=0,t||(++o,p.unshift(1));<span class="cstat-no" title="statement not covered" >f</span></span></span>or(l=p.length;!p[l-1];--l);<span class="cstat-no" title="statement not covered" >f</span>or(s=0,c="";s&lt;l;s++)<span class="cstat-no" title="statement not covered" >c+=Ui.charAt(p[s]);<span class="cstat-no" title="statement not covered" >i</span></span>f(h){<span class="cstat-no" title="statement not covered" >if(l&gt;1)<span class="cstat-no" title="statement not covered" >if(r==16||r==8){<span class="cstat-no" title="statement not covered" >for(s=r==16?4:3,--l;l%s;l++)<span class="cstat-no" title="statement not covered" >c+="0";<span class="cstat-no" title="statement not covered" >f</span></span>or(p=dn(c,i,r),l=p.length;!p[l-1];--l);<span class="cstat-no" title="statement not covered" >f</span>or(s=1,c="1.";s&lt;l;s++)<span class="cstat-no" title="statement not covered" >c+=Ui.charAt(p[s])}</span></span>else <span class="cstat-no" title="statement not covered" >c=c.charAt(0)+"."+c.slice(1);<span class="cstat-no" title="statement not covered" >c</span></span></span>=c+(o&lt;0?"p":"p+")+o}</span>else <span class="cstat-no" title="statement not covered" >if(o&lt;0){<span class="cstat-no" title="statement not covered" >for(;++o;)<span class="cstat-no" title="statement not covered" >c="0"+c;<span class="cstat-no" title="statement not covered" >c</span></span>="0."+c}</span>else <span class="cstat-no" title="statement not covered" >if(++o&gt;l)<span class="cstat-no" title="statement not covered" >for(o-=l;o--;)<span class="cstat-no" title="statement not covered" >c+="0";else <span class="cstat-no" title="statement not covered" >o</span></span>&lt;l&amp;&amp;(c=c.slice(0,o)+"."+c.slice(o))}<span class="cstat-no" title="statement not covered" ></span></span></span></span>c</span>=(r==16?"0x":r==2?"0b":r==8?"0o":"")+c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.s&lt;0?"-"+c:c}</span>function <span class="fstat-no" title="function not covered" >qs(e</span>,r){<span class="cstat-no" title="statement not covered" >if(e.length&gt;r)<span class="cstat-no" title="statement not covered" >return e.length=r,!0}</span></span>function <span class="fstat-no" title="function not covered" >kp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).abs()}</span>function <span class="fstat-no" title="function not covered" >Dp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).acos()}</span>function <span class="fstat-no" title="function not covered" >Op(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).acosh()}</span>function <span class="fstat-no" title="function not covered" >_p(e</span>,r){<span class="cstat-no" title="statement not covered" >return new this(e).plus(r)}</span>function <span class="fstat-no" title="function not covered" >Np(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).asin()}</span>function <span class="fstat-no" title="function not covered" >Lp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).asinh()}</span>function <span class="fstat-no" title="function not covered" >Fp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).atan()}</span>function <span class="fstat-no" title="function not covered" >Mp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).atanh()}</span>function <span class="fstat-no" title="function not covered" >$p(e</span>,r){<span class="cstat-no" title="statement not covered" >e=new this(e),r=new this(r);v</span>ar t,n=<span class="cstat-no" title="statement not covered" >this.precision,</span>i=<span class="cstat-no" title="statement not covered" >this.rounding,</span>o=<span class="cstat-no" title="statement not covered" >n+4;<span class="cstat-no" title="statement not covered" >r</span>eturn!e.s||!r.s?t=new this(NaN):!e.d&amp;&amp;!r.d?(t=we(this,o,1).times(r.s&gt;0?.25:.75),t.s=e.s):!r.d||e.isZero()?(t=r.s&lt;0?we(this,n,i):new this(0),t.s=e.s):!e.d||r.isZero()?(t=we(this,o,1).times(.5),t.s=e.s):r.s&lt;0?(this.precision=o,this.rounding=1,t=this.atan(L(e,r,o,1)),r=we(this,o,1),this.precision=n,this.rounding=i,t=e.s&lt;0?t.minus(r):t.plus(r)):t=this.atan(L(e,r,o,1)),t}</span>function <span class="fstat-no" title="function not covered" >qp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).cbrt()}</span>function <span class="fstat-no" title="function not covered" >jp(e</span>){<span class="cstat-no" title="statement not covered" >return y(e=new this(e),e.e+1,2)}</span>function <span class="fstat-no" title="function not covered" >Vp(e</span>,r,t){<span class="cstat-no" title="statement not covered" >return new this(e).clamp(r,t)}</span>function Bp(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(!e||typeof e!="object")<span class="cstat-no" title="statement not covered" >throw Error(yn+"Object expected");v</span>ar r,t,n,i=e.defaults===!0,o=["precision",1,Ke,"rounding",0,8,"toExpNeg",-vr,0,"toExpPos",0,vr,"maxE",0,vr,"minE",-vr,0,"modulo",0,9];for(r=0;r&lt;o.length;r+=3)<span class="missing-if-branch" title="else path not taken" >E</span>if(t=o[r],i&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this[t]=Gi[t])</span>,(n=e[t])!==void 0)if(X(n)===n&amp;&amp;n&gt;=o[r+1]&amp;&amp;n&lt;=o[r+2])this[t]=n;else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>throw Error(He+t+": "+n);<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(t="crypto",i&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this[t]=Gi[t])</span>,(n=e[t])!==void 0)if(n===!0||n===!1||<span class="branch-2 cbranch-no" title="branch not covered" >n===0||<span class="branch-3 cbranch-no" title="branch not covered" >n</span>===1)<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n)<span class="cstat-no" title="statement not covered" >if(typeof crypto&lt;"u"&amp;&amp;crypto&amp;&amp;(crypto.getRandomValues||crypto.randomBytes))<span class="cstat-no" title="statement not covered" >this[t]=!0;else <span class="cstat-no" title="statement not covered" >t</span>hrow Error(Us);else t</span></span>his[t]=!1;else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>throw Error(He+t+": "+n);r</span>eturn this}function <span class="fstat-no" title="function not covered" >Up(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).cos()}</span>function <span class="fstat-no" title="function not covered" >Gp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).cosh()}</span>function zs(e){var r,t,n;function i(o){var s,a,l,u=this;<span class="missing-if-branch" title="if path not taken" >I</span>if(!(u instanceof i))<span class="cstat-no" title="statement not covered" >return new i(o);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(u.constructor=i,js(o)){<span class="cstat-no" title="statement not covered" >u.s=o.s,w?!o.d||o.e&gt;i.maxE?(u.e=NaN,u.d=null):o.e&lt;i.minE?(u.e=0,u.d=[0]):(u.e=o.e,u.d=o.d.slice()):(u.e=o.e,u.d=o.d?o.d.slice():o.d)</span>;<span class="cstat-no" title="statement not covered" >return}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(l=typeof o,l==="number"){<span class="cstat-no" title="statement not covered" >if(o===0){<span class="cstat-no" title="statement not covered" >u.s=1/o&lt;0?-1:1,u.e=0,u.d=[0];<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o&lt;0?(o=-o,u.s=-1):u.s=1,o===~~o&amp;&amp;o&lt;1e7){<span class="cstat-no" title="statement not covered" >for(s=0,a=o;a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >w</span></span>?s&gt;i.maxE?(u.e=NaN,u.d=null):s&lt;i.minE?(u.e=0,u.d=[0]):(u.e=s,u.d=[o]):(u.e=s,u.d=[o])</span>;<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o*0!==0){<span class="cstat-no" title="statement not covered" >o||(u.s=NaN),u.e=NaN,u.d=null;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn mn(u,o.toString())}<span class="missing-if-branch" title="else path not taken" >E</span></span>if(l==="string")return(a=o.charCodeAt(0))===45?(<span class="branch-0 cbranch-no" title="branch not covered" >o=o.slice(1),u.s=-1):(a</span>===43&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o=o.slice(1)</span>),u.s=1),Qs.test(o)?mn(u,o):<span class="branch-1 cbranch-no" title="branch not covered" >Cp(u,o);<span class="cstat-no" title="statement not covered" >i</span>f(l==="bigint")<span class="cstat-no" title="statement not covered" >return o&lt;0?(o=-o,u.s=-1):u.s=1,mn(u,o.toString());<span class="cstat-no" title="statement not covered" >t</span></span>hrow Error(He+o)}<span class="missing-if-branch" title="else path not taken" >E</span></span>if(i.prototype=m,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=Bp,i.clone=zs,i.isDecimal=js,i.abs=kp,i.acos=Dp,i.acosh=Op,i.add=_p,i.asin=Np,i.asinh=Lp,i.atan=Fp,i.atanh=Mp,i.atan2=$p,i.cbrt=qp,i.ceil=jp,i.clamp=Vp,i.cos=Up,i.cosh=Gp,i.div=Qp,i.exp=Wp,i.floor=Jp,i.hypot=Hp,i.ln=Kp,i.log=Yp,i.log10=Zp,i.log2=zp,i.max=Xp,i.min=ed,i.mod=rd,i.mul=td,i.pow=nd,i.random=id,i.round=od,i.sign=sd,i.sin=ad,i.sinh=ld,i.sqrt=ud,i.sub=cd,i.sum=pd,i.tan=dd,i.tanh=md,i.trunc=fd,e===void 0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e={}),e</span>&amp;&amp;e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],r=0;r&lt;n.length;)e.hasOwnProperty(t=n[r++])||(<span class="branch-1 cbranch-no" title="branch not covered" >e[t]=this[t])</span>;return i.config(e),i}function <span class="fstat-no" title="function not covered" >Qp(e</span>,r){<span class="cstat-no" title="statement not covered" >return new this(e).div(r)}</span>function <span class="fstat-no" title="function not covered" >Wp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).exp()}</span>function <span class="fstat-no" title="function not covered" >Jp(e</span>){<span class="cstat-no" title="statement not covered" >return y(e=new this(e),e.e+1,3)}</span>function <span class="fstat-no" title="function not covered" >Hp(){v</span>ar e,r,t=<span class="cstat-no" title="statement not covered" >new this(0);<span class="cstat-no" title="statement not covered" >f</span>or(w=!1,e=0;e&lt;arguments.length;)<span class="cstat-no" title="statement not covered" >if(r=new this(arguments[e++]),r.d)<span class="cstat-no" title="statement not covered" >t.d&amp;&amp;(t=t.plus(r.times(r)));else{<span class="cstat-no" title="statement not covered" ></span>if(r.s)<span class="cstat-no" title="statement not covered" >return w=!0,new this(1/0);<span class="cstat-no" title="statement not covered" >t</span></span>=r}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn w=!0,t.sqrt()}</span>function js(e){return e instanceof ar||e&amp;&amp;e.toStringTag===Gs||!1}function <span class="fstat-no" title="function not covered" >Kp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).ln()}</span>function <span class="fstat-no" title="function not covered" >Yp(e</span>,r){<span class="cstat-no" title="statement not covered" >return new this(e).log(r)}</span>function <span class="fstat-no" title="function not covered" >zp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).log(2)}</span>function <span class="fstat-no" title="function not covered" >Zp(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).log(10)}</span>function <span class="fstat-no" title="function not covered" >Xp(){<span class="cstat-no" title="statement not covered" >r</span>eturn Hs(this,arguments,-1)}</span>function <span class="fstat-no" title="function not covered" >ed(){<span class="cstat-no" title="statement not covered" >r</span>eturn Hs(this,arguments,1)}</span>function <span class="fstat-no" title="function not covered" >rd(e</span>,r){<span class="cstat-no" title="statement not covered" >return new this(e).mod(r)}</span>function <span class="fstat-no" title="function not covered" >td(e</span>,r){<span class="cstat-no" title="statement not covered" >return new this(e).mul(r)}</span>function <span class="fstat-no" title="function not covered" >nd(e</span>,r){<span class="cstat-no" title="statement not covered" >return new this(e).pow(r)}</span>function <span class="fstat-no" title="function not covered" >id(e</span>){var r,t,n,i,o=<span class="cstat-no" title="statement not covered" >0,s</span>=<span class="cstat-no" title="statement not covered" >new this(1),a</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e===void 0?e=this.precision:ie(e,1,Ke),n=Math.ceil(e/E),this.crypto)<span class="cstat-no" title="statement not covered" >if(crypto.getRandomValues)<span class="cstat-no" title="statement not covered" >for(r=crypto.getRandomValues(new Uint32Array(n));o&lt;n;)<span class="cstat-no" title="statement not covered" >i=r[o],i&gt;=429e7?r[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else <span class="cstat-no" title="statement not covered" >i</span></span>f(crypto.randomBytes){<span class="cstat-no" title="statement not covered" >for(r=crypto.randomBytes(n*=4);o&lt;n;)<span class="cstat-no" title="statement not covered" >i=r[o]+(r[o+1]&lt;&lt;8)+(r[o+2]&lt;&lt;16)+((r[o+3]&amp;127)&lt;&lt;24),i&gt;=214e7?crypto.randomBytes(4).copy(r,o):(a.push(i%1e7),o+=4);<span class="cstat-no" title="statement not covered" >o</span></span>=n/4}</span>else <span class="cstat-no" title="statement not covered" >throw Error(Us);else <span class="cstat-no" title="statement not covered" >f</span></span></span>or(;o&lt;n;)<span class="cstat-no" title="statement not covered" >a[o++]=Math.random()*1e7|0;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(n=a[--o],e%=E,n&amp;&amp;e&amp;&amp;(i=U(10,E-e),a[o]=(n/i|0)*i);a[o]===0;o--)<span class="cstat-no" title="statement not covered" >a.pop();<span class="cstat-no" title="statement not covered" >i</span></span>f(o&lt;0)<span class="cstat-no" title="statement not covered" >t=0,a=[0];else{<span class="cstat-no" title="statement not covered" ></span>for(t=-1;a[0]===0;t-=E)<span class="cstat-no" title="statement not covered" >a.shift();<span class="cstat-no" title="statement not covered" >f</span></span>or(n=1,i=a[0];i&gt;=10;i/=10)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >n</span></span>&lt;E&amp;&amp;(t-=E-n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.e=t,s.d=a,s}</span>function <span class="fstat-no" title="function not covered" >od(e</span>){<span class="cstat-no" title="statement not covered" >return y(e=new this(e),e.e+1,this.rounding)}</span>function <span class="fstat-no" title="function not covered" >sd(e</span>){<span class="cstat-no" title="statement not covered" >return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}</span>function <span class="fstat-no" title="function not covered" >ad(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).sin()}</span>function <span class="fstat-no" title="function not covered" >ld(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).sinh()}</span>function <span class="fstat-no" title="function not covered" >ud(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).sqrt()}</span>function <span class="fstat-no" title="function not covered" >cd(e</span>,r){<span class="cstat-no" title="statement not covered" >return new this(e).sub(r)}</span>function <span class="fstat-no" title="function not covered" >pd(){v</span>ar e=<span class="cstat-no" title="statement not covered" >0,r</span>=<span class="cstat-no" title="statement not covered" >arguments,t</span>=<span class="cstat-no" title="statement not covered" >new this(r[e]);<span class="cstat-no" title="statement not covered" >f</span>or(w=!1;t.s&amp;&amp;++e&lt;r.length;)<span class="cstat-no" title="statement not covered" >t=t.plus(r[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn w=!0,y(t,this.precision,this.rounding)}</span>function <span class="fstat-no" title="function not covered" >dd(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).tan()}</span>function <span class="fstat-no" title="function not covered" >md(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).tanh()}</span>function <span class="fstat-no" title="function not covered" >fd(e</span>){<span class="cstat-no" title="statement not covered" >return y(e=new this(e),e.e+1,1)}</span>m[Symbol.for("nodejs.util.inspect.custom")]=m.toString;m[Symbol.toStringTag]="Decimal";var ar=m.constructor=zs(Gi);fn=new ar(fn);gn=new ar(gn);var ve=ar;function Tr(e){return e===null?e:Array.isArray(e)?e.map(Tr):typeof e=="object"?gd(e)?hd(e):e.constructor!==null&amp;&amp;e.constructor.name!=="Object"?<span class="branch-0 cbranch-no" title="branch not covered" >e:x</span>r(e,Tr):e}function gd(e){return e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.$type=="string"}function hd({$type:e,value:r}){switch(e){<span class="branch-0 cbranch-no" title="branch not covered" >case"BigInt":<span class="cstat-no" title="statement not covered" >return BigInt(r);<span class="branch-1 cbranch-no" title="branch not covered" >c</span></span>ase"Bytes":{let{buffer:t,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >Buffer.from(r,"base64");<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(t,n,i)}</span>c</span>ase"DateTime":return new Date(r);<span class="branch-3 cbranch-no" title="branch not covered" >case"Decimal":<span class="cstat-no" title="statement not covered" >return new ve(r);<span class="branch-4 cbranch-no" title="branch not covered" >c</span></span>ase"Json":<span class="cstat-no" title="statement not covered" >return JSON.parse(r);<span class="branch-5 cbranch-no" title="branch not covered" >d</span></span>efault:<span class="cstat-no" title="statement not covered" >Ne(r,"Unknown tagged value")}</span></span>}var Pe=class{_map=new Map;<span class="fstat-no" title="function not covered" >get(r</span>){<span class="cstat-no" title="statement not covered" >return this._map.get(r)?.value}</span>set(r,t){this._map.set(r,{value:t})}getOrCreate(r,t){let n=this._map.get(r);if(n)return n.value;let i=t();return this.set(r,i),i}};function <span class="fstat-no" title="function not covered" >Ye(e</span>){<span class="cstat-no" title="statement not covered" >return e.substring(0,1).toLowerCase()+e.substring(1)}</span>function <span class="fstat-no" title="function not covered" >Zs(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let n of e){let i=<span class="cstat-no" title="statement not covered" >n[r];<span class="cstat-no" title="statement not covered" ></span>t[i]=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function ut(e){let r;return{<span class="fstat-no" title="function not covered" >get(){<span class="cstat-no" title="statement not covered" >r</span>eturn r||(r={value:e()}),r.value}}</span>}function <span class="fstat-no" title="function not covered" >Xs(e</span>){<span class="cstat-no" title="statement not covered" >return{models:Hi(e.models),enums:Hi(e.enums),types:Hi(e.types)}}</span>function <span class="fstat-no" title="function not covered" >Hi(e</span>){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let{name:t,...n}of e)<span class="cstat-no" title="statement not covered" >r[t]=n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function Sr(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function wn(e){return e.toString()!=="Invalid Date"}function Rr(e){return ar.isDecimal(e)?<span class="branch-0 cbranch-no" title="branch not covered" >!0:e</span>!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.s=="number"&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >typeof e.e=="number"&amp;&amp;<span class="branch-4 cbranch-no" title="branch not covered" >t</span>ypeof e.toFixed=="function"&amp;&amp;<span class="branch-5 cbranch-no" title="branch not covered" >A</span>rray.isArray(e.d)}</span>var ct={};tr(ct,{ModelAction:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >A</span>r,d</span>atamodelEnumToSchemaEnum:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >y</span>d}</span>);function <span class="fstat-no" title="function not covered" >yd(e</span>){<span class="cstat-no" title="statement not covered" >return{name:e.name,values:e.values.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.name)</span>}}</span>var Ar=(b=&gt;(b.findUnique="findUnique",b.findUniqueOrThrow="findUniqueOrThrow",b.findFirst="findFirst",b.findFirstOrThrow="findFirstOrThrow",b.findMany="findMany",b.create="create",b.createMany="createMany",b.createManyAndReturn="createManyAndReturn",b.update="update",b.updateMany="updateMany",b.updateManyAndReturn="updateManyAndReturn",b.upsert="upsert",b.delete="delete",b.deleteMany="deleteMany",b.groupBy="groupBy",b.count="count",b.aggregate="aggregate",b.findRaw="findRaw",b.aggregateRaw="aggregateRaw",b))(Ar||{});var ia=C(Di());var na=C(require("node:fs"));var ea={keyword:De,entity:De,value:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >W</span>(nr(e)),p</span>unctuation:nr,directive:De,function:De,variable:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >W</span>(nr(e)),s</span>tring:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >W</span>(qe(e)),b</span>oolean:ke,number:De,comment:Kr};var bd=<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,x</span>n={},Ed=0,v={manual:xn.Prism&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >xn.Prism.manual,</span>disableWorkerMessageHandler:xn.Prism&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >xn.Prism.disableWorkerMessageHandler,</span>util:{encode:<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >if(e instanceof ge){let r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn new ge(r.type,v.util.encode(r.content),r.alias)}</span>else <span class="cstat-no" title="statement not covered" >return Array.isArray(e)?e.map(v.util.encode):e.replace(/&amp;/g,"&amp;amp;").replace(/&lt;/g,"&amp;lt;").replace(/\u00a0/g," ")}</span></span>,type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++Ed}),e.__id},clone:function e(r,t){let n,i,o=v.util.type(r);switch(t=t||{},o){case"Object":if(i=v.util.objId(r),t[i])return t[i];n={},t[i]=n;for(let s in r)r.hasOwnProperty(s)&amp;&amp;(n[s]=e(r[s],t));return n;case"Array":return i=v.util.objId(r),t[i]?<span class="branch-0 cbranch-no" title="branch not covered" >t[i]:</span>(n=[],t[i]=n,r.forEach(function(s,a){n[a]=e(s,t)}),n);default:return r}}},languages:{extend:function(e,r){let t=v.util.clone(v.languages[e]);for(let n in r)t[n]=r[n];return t},insertBefore:function(e,r,t,n){n=n||v.languages;let i=n[e],o={};for(let a in i)<span class="missing-if-branch" title="else path not taken" >E</span>if(i.hasOwnProperty(a)){if(a==r)for(let l in t)t.hasOwnProperty(l)&amp;&amp;(o[l]=t[l]);t.hasOwnProperty(a)||(o[a]=i[a])}let s=n[e];return n[e]=o,v.languages.DFS(v.languages,function(a,l){l===s&amp;&amp;a!=e&amp;&amp;(this[a]=o)}),o},DFS:function e(r,t,n,i){i=i||{};let o=v.util.objId;for(let s in r)<span class="missing-if-branch" title="else path not taken" >E</span>if(r.hasOwnProperty(s)){t.call(r,s,r[s],n||s);let a=r[s],l=v.util.type(a);l==="Object"&amp;&amp;!i[o(a)]?(i[o(a)]=!0,e(a,t,null,i)):l==="Array"&amp;&amp;!i[o(a)]&amp;&amp;(i[o(a)]=!0,e(a,t,s,i))}}},plugins:{},highlight:<span class="fstat-no" title="function not covered" >function(e</span>,r,t){let n=<span class="cstat-no" title="statement not covered" >{code:e,grammar:r,language:t};<span class="cstat-no" title="statement not covered" >r</span>eturn v.hooks.run("before-tokenize",n),n.tokens=v.tokenize(n.code,n.grammar),v.hooks.run("after-tokenize",n),ge.stringify(v.util.encode(n.tokens),n.language)}</span>,matchGrammar:<span class="fstat-no" title="function not covered" >function(e</span>,r,t,n,i,o,s){<span class="cstat-no" title="statement not covered" >for(let g in t){<span class="cstat-no" title="statement not covered" >if(!t.hasOwnProperty(g)||!t[g])<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(g==s)<span class="cstat-no" title="statement not covered" >return;l</span></span>et S=<span class="cstat-no" title="statement not covered" >t[g];<span class="cstat-no" title="statement not covered" ></span>S=v.util.type(S)==="Array"?S:[S];<span class="cstat-no" title="statement not covered" >f</span>or(let P=<span class="cstat-no" title="statement not covered" >0;P</span>&lt;S.length;++P){let R=<span class="cstat-no" title="statement not covered" >S[P],</span>b=<span class="cstat-no" title="statement not covered" >R.inside,</span>D=<span class="cstat-no" title="statement not covered" >!!R.lookbehind,</span>me=<span class="cstat-no" title="statement not covered" >!!R.greedy,</span>ae=<span class="cstat-no" title="statement not covered" >0,H</span>r=<span class="cstat-no" title="statement not covered" >R.alias;<span class="cstat-no" title="statement not covered" ></span>if(me&amp;&amp;!R.pattern.global){let V=<span class="cstat-no" title="statement not covered" >R.pattern.toString().match(/[imuy]*$/)[0];<span class="cstat-no" title="statement not covered" ></span>R.pattern=RegExp(R.pattern.source,V+"g")}<span class="cstat-no" title="statement not covered" ></span>R</span>=R.pattern||R;<span class="cstat-no" title="statement not covered" >f</span>or(let V=<span class="cstat-no" title="statement not covered" >n,t</span>e=<span class="cstat-no" title="statement not covered" >i;V</span>&lt;r.length;te+=r[V].length,++V){let Ce=<span class="cstat-no" title="statement not covered" >r[V];<span class="cstat-no" title="statement not covered" ></span>if(r.length&gt;e.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(Ce instanceof ge)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(me&amp;&amp;V!=r.length-1){<span class="cstat-no" title="statement not covered" >R.lastIndex=te;v</span>ar p=<span class="cstat-no" title="statement not covered" >R.exec(e);<span class="cstat-no" title="statement not covered" >i</span>f(!p)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >p.index+(D?p[1].length:0),d</span>=<span class="cstat-no" title="statement not covered" >p.index+p[0].length,</span>a=<span class="cstat-no" title="statement not covered" >V,l</span>=<span class="cstat-no" title="statement not covered" >te;<span class="cstat-no" title="statement not covered" >f</span>or(let _=<span class="cstat-no" title="statement not covered" >r.length;</span>a&lt;_&amp;&amp;(l&lt;d||!r[a].type&amp;&amp;!r[a-1].greedy);++a)<span class="cstat-no" title="statement not covered" >l+=r[a].length,c&gt;=l&amp;&amp;(++V,te=l);<span class="cstat-no" title="statement not covered" >i</span></span>f(r[V]instanceof ge)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >u</span></span>=a-V,Ce=e.slice(te,l),p.index-=te}</span>else{<span class="cstat-no" title="statement not covered" >R.lastIndex=0;v</span>ar p=<span class="cstat-no" title="statement not covered" >R.exec(Ce),u</span>=<span class="cstat-no" title="statement not covered" >1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!p){<span class="cstat-no" title="statement not covered" >if(o)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >c</span></span>ontinue}<span class="cstat-no" title="statement not covered" ></span>D</span>&amp;&amp;(ae=p[1]?p[1].length:0);v</span>ar c=<span class="cstat-no" title="statement not covered" >p.index+ae,p</span>=<span class="cstat-no" title="statement not covered" >p[0].slice(ae),d</span>=<span class="cstat-no" title="statement not covered" >c+p.length,</span>f=<span class="cstat-no" title="statement not covered" >Ce.slice(0,c),h</span>=<span class="cstat-no" title="statement not covered" >Ce.slice(d);l</span>et H=<span class="cstat-no" title="statement not covered" >[V,u];<span class="cstat-no" title="statement not covered" >f</span>&amp;&amp;(++V,te+=f.length,H.push(f));l</span>et fr=<span class="cstat-no" title="statement not covered" >new ge(g,b?v.tokenize(p,b):p,Hr,p,me);<span class="cstat-no" title="statement not covered" >i</span>f(H.push(fr),h&amp;&amp;H.push(h),Array.prototype.splice.apply(r,H),u!=1&amp;&amp;v.matchGrammar(e,r,t,V,te,!0,g),o)<span class="cstat-no" title="statement not covered" >break}</span></span>}</span>}</span>}</span>,tokenize:<span class="fstat-no" title="function not covered" >function(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >[e],n</span>=<span class="cstat-no" title="statement not covered" >r.rest;<span class="cstat-no" title="statement not covered" ></span>if(n){<span class="cstat-no" title="statement not covered" >for(let i in n)<span class="cstat-no" title="statement not covered" >r[i]=n[i];<span class="cstat-no" title="statement not covered" >d</span></span>elete r.rest}<span class="cstat-no" title="statement not covered" >r</span></span>eturn v.matchGrammar(e,t,r,0,0,!1),t}</span>,hooks:{all:{},add:<span class="fstat-no" title="function not covered" >function(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >v.hooks.all;<span class="cstat-no" title="statement not covered" ></span>t[e]=t[e]||[],t[e].push(r)}</span>,run:<span class="fstat-no" title="function not covered" >function(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >v.hooks.all[e];<span class="cstat-no" title="statement not covered" ></span>if(!(!t||!t.length))<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0,i</span>;i=t[n++];)<span class="cstat-no" title="statement not covered" >i(r)}</span></span></span>},Token:ge};v.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|&lt;=?|&gt;=?|==?=?|&amp;&amp;?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};v.languages.javascript=v.languages.extend("clike",{"class-name":[v.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|&lt;&lt;?=?|&gt;&gt;?&gt;?=?|=(?:==?|&gt;)?|&amp;[&amp;=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/});v.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;v.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=&gt;))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:v.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=&gt;)/i,inside:v.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=&gt;)/,lookbehind:!0,inside:v.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:v.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/});v.languages.markup&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >v.languages.markup.tag.addInlined("script","javascript");v</span>.languages.js=v.languages.javascript;v.languages.typescript=v.languages.extend("javascript",{keyword:/\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/});v.languages.ts=v.languages.typescript;function <span class="fstat-no" title="function not covered" >ge(e</span>,r,t,n,i){<span class="cstat-no" title="statement not covered" >this.type=e,this.content=r,this.alias=t,this.length=(n||"").length|0,this.greedy=!!i}</span>ge.stringify=<span class="fstat-no" title="function not covered" >function(e</span>,r){<span class="cstat-no" title="statement not covered" >return typeof e=="string"?e:Array.isArray(e)?e.map(<span class="fstat-no" title="function not covered" >function(t</span>){<span class="cstat-no" title="statement not covered" >return ge.stringify(t,r)}</span>).join(""):wd(e.type)(e.content)}</span>;function <span class="fstat-no" title="function not covered" >wd(e</span>){<span class="cstat-no" title="statement not covered" >return ea[e]||bd}</span>function <span class="fstat-no" title="function not covered" >ra(e</span>){<span class="cstat-no" title="statement not covered" >return xd(e,v.languages.javascript)}</span>function <span class="fstat-no" title="function not covered" >xd(e</span>,r){<span class="cstat-no" title="statement not covered" >return v.tokenize(e,r).map(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >g</span>e.stringify(n)).j</span>oin("")}</span>function <span class="fstat-no" title="function not covered" >ta(e</span>){<span class="cstat-no" title="statement not covered" >return Ii(e)}</span>var vn=class e{firstLineNumber;lines;<span class="fstat-no" title="function not covered" >static r</span>ead(r){let t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=na.default.readFileSync(r,"utf-8")}</span>catch{<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.fromContent(t)}<span class="fstat-no" title="function not covered" ></span>static f</span>romContent(r){let t=<span class="cstat-no" title="statement not covered" >r.split(/\r?\n/);<span class="cstat-no" title="statement not covered" >r</span>eturn new e(1,t)}<span class="fstat-no" title="function not covered" ></span>constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >this.firstLineNumber=r,this.lines=t}<span class="fstat-no" title="function not covered" ></span>get l</span>astLineNumber(){<span class="cstat-no" title="statement not covered" >return this.firstLineNumber+this.lines.length-1}<span class="fstat-no" title="function not covered" ></span>mapLineAt(r</span>,t){<span class="cstat-no" title="statement not covered" >if(r&lt;this.firstLineNumber||r&gt;this.lines.length+this.firstLineNumber)<span class="cstat-no" title="statement not covered" >return this;l</span></span>et n=<span class="cstat-no" title="statement not covered" >r-this.firstLineNumber,</span>i=<span class="cstat-no" title="statement not covered" >[...this.lines];<span class="cstat-no" title="statement not covered" >r</span>eturn i[n]=t(i[n]),new e(this.firstLineNumber,i)}<span class="fstat-no" title="function not covered" ></span>mapLines(r</span>){<span class="cstat-no" title="statement not covered" >return new e(this.firstLineNumber,this.lines.map(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r(t,this.firstLineNumber+n)))}<span class="fstat-no" title="function not covered" ></span></span>lineAt(r</span>){<span class="cstat-no" title="statement not covered" >return this.lines[r-this.firstLineNumber]}<span class="fstat-no" title="function not covered" >p</span>rependSymbolAt(r</span>,t){<span class="cstat-no" title="statement not covered" >return this.mapLines(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >i===r?`${t} ${n}`:`  ${n}`)</span>}<span class="fstat-no" title="function not covered" ></span>slice(r</span>,t){let n=<span class="cstat-no" title="statement not covered" >this.lines.slice(r-1,t).join(`</span>
`);<span class="cstat-no" title="statement not covered" >return new e(r,ta(n).split(`</span>
`))}<span class="fstat-no" title="function not covered" >highlight(){</span>let r=<span class="cstat-no" title="statement not covered" >ra(this.toString());<span class="cstat-no" title="statement not covered" >r</span>eturn new e(this.firstLineNumber,r.split(`</span>
`))}<span class="fstat-no" title="function not covered" >toString(){<span class="cstat-no" title="statement not covered" ></span>return this.lines.join(`</span>
`)}};var vd={red:ce,gray:Kr,dim:Ie,bold:W,underline:Y,highlightSource:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.highlight()}</span>,Pd={red:e=&gt;e,gray:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,d</span>im:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,b</span>old:e=&gt;e,underline:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,h</span>ighlightSource:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>}</span>;function Td({message:e,originalMethod:r,isPanic:t,callArguments:n}){return{functionName:`prisma.${r}()`,message:e,isPanic:t??!1,callArguments:n}}function Sd({callsite:e,message:r,originalMethod:t,isPanic:n,callArguments:i},o){let s=Td({message:r,originalMethod:t,isPanic:n,callArguments:i});<span class="missing-if-branch" title="else path not taken" >E</span>if(!e||typeof window&lt;"u"||<span class="branch-2 cbranch-no" title="branch not covered" >process.env.NODE_ENV==="production")r</span>eturn s;let a=<span class="cstat-no" title="statement not covered" >e.getLocation();<span class="cstat-no" title="statement not covered" >i</span>f(!a||!a.lineNumber||!a.columnNumber)<span class="cstat-no" title="statement not covered" >return s;l</span></span>et l=<span class="cstat-no" title="statement not covered" >Math.max(1,a.lineNumber-3),u</span>=<span class="cstat-no" title="statement not covered" >vn.read(a.fileName)?.slice(l,a.lineNumber),c</span>=<span class="cstat-no" title="statement not covered" >u?.lineAt(a.lineNumber);<span class="cstat-no" title="statement not covered" >i</span>f(u&amp;&amp;c){let p=<span class="cstat-no" title="statement not covered" >Ad(c),d</span>=<span class="cstat-no" title="statement not covered" >Rd(c);<span class="cstat-no" title="statement not covered" >i</span>f(!d)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>.functionName=`${d.code})`,s.location=a,n||(u=u.mapLineAt(a.lineNumber,<span class="fstat-no" title="function not covered" >h=&gt;<span class="cstat-no" title="statement not covered" >h</span>.slice(0,d.openingBraceIndex))</span>),u=o.highlightSource(u);l</span>et f=<span class="cstat-no" title="statement not covered" >String(u.lastLineNumber).length;<span class="cstat-no" title="statement not covered" ></span>if(s.contextLines=u.mapLines(<span class="fstat-no" title="function not covered" >(h</span>,g)=&gt;<span class="cstat-no" title="statement not covered" >o.gray(String(g).padStart(f))+" "+h).m</span>apLines(<span class="fstat-no" title="function not covered" >h=&gt;<span class="cstat-no" title="statement not covered" >o</span>.dim(h)).p</span>rependSymbolAt(a.lineNumber,o.bold(o.red("\u2192"))),i){let h=<span class="cstat-no" title="statement not covered" >p+f+1;<span class="cstat-no" title="statement not covered" >h</span>+=2,s.callArguments=(0,ia.default)(i,h).slice(h)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>function <span class="fstat-no" title="function not covered" >Rd(e</span>){let r=<span class="cstat-no" title="statement not covered" >Object.keys(Ar).join("|"),n</span>=<span class="cstat-no" title="statement not covered" >new RegExp(String.raw`\.(${r})\(`).exec(e);<span class="cstat-no" title="statement not covered" >i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >n.index+n[0].length,</span>o=<span class="cstat-no" title="statement not covered" >e.lastIndexOf(" ",n.index)+1;<span class="cstat-no" title="statement not covered" >r</span>eturn{code:e.slice(o,i),openingBraceIndex:i}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >Ad(e</span>){let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;t</span>&lt;e.length;t++){<span class="cstat-no" title="statement not covered" >if(e.charAt(t)!==" ")<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >r</span></span>++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function Cd({functionName:e,location:r,message:t,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],l=r?<span class="branch-0 cbranch-no" title="branch not covered" >" in":"</span>:";<span class="missing-if-branch" title="if path not taken" >I</span>if(n?(<span class="branch-0 cbranch-no" title="branch not covered" >a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))</span>):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),r&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >a.push(s.underline(Id(r))),i</span>){<span class="cstat-no" title="statement not covered" >a.push("");l</span>et u=<span class="cstat-no" title="statement not covered" >[i.toString()];<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;(u.push(o),u.push(s.dim(")"))),a.push(u.join("")),o&amp;&amp;a.push("")}</span>else a.push(""),o&amp;&amp;a.push(o),a.push("");return a.push(t),a.join(`
`)}function <span class="fstat-no" title="function not covered" >Id(e</span>){let r=<span class="cstat-no" title="statement not covered" >[e.fileName];<span class="cstat-no" title="statement not covered" >r</span>eturn e.lineNumber&amp;&amp;r.push(String(e.lineNumber)),e.columnNumber&amp;&amp;r.push(String(e.columnNumber)),r.join(":")}</span>function Pn(e){let r=e.showColors?<span class="branch-0 cbranch-no" title="branch not covered" >vd:P</span>d,t;return t=Sd(e,r),Cd(t,r)}var ma=C(Ki());function la(e,r,t){let n=ua(e),i=kd(n),o=Od(i);o?Tn(o,r,t):<span class="branch-1 cbranch-no" title="branch not covered" >r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>Unknown error")}</span></span>function ua(e){return e.errors.flatMap(r=&gt;r.kind==="Union"?<span class="branch-0 cbranch-no" title="branch not covered" >ua(r):[</span>r])}function kd(e){let r=new Map,t=[];for(let n of e){<span class="missing-if-branch" title="else path not taken" >E</span>if(n.kind!=="InvalidArgumentType"){t.push(n);continue}let i=<span class="cstat-no" title="statement not covered" >`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,</span>o=<span class="cstat-no" title="statement not covered" >r.get(i);<span class="cstat-no" title="statement not covered" >o</span>?r.set(i,{...n,argument:{...n.argument,typeNames:Dd(o.argument.typeNames,n.argument.typeNames)}}):r.set(i,n)}</span>return t.push(...r.values()),t}function <span class="fstat-no" title="function not covered" >Dd(e</span>,r){<span class="cstat-no" title="statement not covered" >return[...new Set(e.concat(r))]}f</span>unction Od(e){return Bi(e,(r,t)=&gt;{let n=sa(r),i=sa(t);return n!==i?<span class="branch-0 cbranch-no" title="branch not covered" >n-i:a</span>a(r)-aa(t)})}function sa(e){let r=0;return Array.isArray(e.selectionPath)&amp;&amp;(r+=e.selectionPath.length),Array.isArray(e.argumentPath)&amp;&amp;(r+=e.argumentPath.length),r}function aa(e){switch(e.kind){<span class="branch-0 cbranch-no" title="branch not covered" >case"InvalidArgumentValue":<span class="branch-1 cbranch-no" title="branch not covered" >c</span>ase"ValueTooLarge":<span class="cstat-no" title="statement not covered" >return 20;<span class="branch-2 cbranch-no" title="branch not covered" >c</span></span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >return 10;c</span></span>ase"RequiredArgumentMissing":return-10;<span class="branch-4 cbranch-no" title="branch not covered" >default:<span class="cstat-no" title="statement not covered" >return 0}</span></span>}var ue=class{constructor(r,t){this.name=r;this.value=t}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(r){let{colors:{green:t}}=r.context;r.addMarginSymbol(t(this.isRequired?"+":<span class="branch-1 cbranch-no" title="branch not covered" >"?")),r</span>.write(t(this.name)),this.isRequired||<span class="branch-1 cbranch-no" title="branch not covered" >r.write(t("?")),r</span>.write(t(": ")),typeof this.value=="string"?<span class="branch-0 cbranch-no" title="branch not covered" >r.write(t(this.value)):r</span>.write(this.value)}};pa();var Cr=class{constructor(r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>t){this.context=t;this.currentIndent=r}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(r){return typeof r=="string"?this.currentLine+=r:r.write(this),this}writeJoined(r,t,n=(i,o)=&gt;o.write(i)){let i=t.length-1;for(let o=0;o&lt;t.length;o++)n(t[o],this),o!==i&amp;&amp;this.write(r);return this}writeLine(r){return this.write(r).newLine()}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let r=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,r?.(),this}withIndent(r){return this.indent(),r(this),this.unindent(),this}<span class="fstat-no" title="function not covered" >afterNextNewline(r</span>){<span class="cstat-no" title="statement not covered" >return this.afterNextNewLineCallback=r,this}i</span>ndent(){return this.currentIndent++,this}unindent(){return this.currentIndent&gt;0&amp;&amp;this.currentIndent--,this}addMarginSymbol(r){return this.marginSymbol=r,this}toString(){return this.lines.concat(this.indentedCurrentLine()).join(`
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let r=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+r.slice(1):r}};ca();var Sn=class{<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >this.value=r}<span class="fstat-no" title="function not covered" ></span>write(r</span>){<span class="cstat-no" title="statement not covered" >r.write(this.value)}<span class="fstat-no" title="function not covered" ></span>markAsError(){<span class="cstat-no" title="statement not covered" ></span>this.value.markAsError()}</span>};var Rn=e=&gt;e,An={bold:Rn,red:Rn,green:Rn,dim:Rn,enabled:!1},da={bold:W,red:ce,green:qe,dim:Ie,enabled:!0},Ir={write(e){e.writeLine(",")}};var Te=class{constructor(r){this.contents=r}isUnderlined=!1;color=r=&gt;r;<span class="fstat-no" title="function not covered" >underline(){<span class="cstat-no" title="statement not covered" ></span>return this.isUnderlined=!0,this}<span class="fstat-no" title="function not covered" >s</span>etColor(r</span>){<span class="cstat-no" title="statement not covered" >return this.color=r,this}w</span>rite(r){let t=r.getCurrentLineLength();r.write(this.color(this.contents)),this.isUnderlined&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >r</span>.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length)))}</span>)}</span>};var ze=class{hasError=!1;<span class="fstat-no" title="function not covered" >markAsError(){<span class="cstat-no" title="statement not covered" ></span>return this.hasError=!0,this}}</span>;var kr=<span class="cstat-no" title="statement not covered" >class extends ze{items=[];<span class="fstat-no" title="function not covered" >a</span>ddItem(r</span>){<span class="cstat-no" title="statement not covered" >return this.items.push(new Sn(r)),this}<span class="fstat-no" title="function not covered" >g</span>etField(r</span>){<span class="cstat-no" title="statement not covered" >return this.items[r]}<span class="fstat-no" title="function not covered" >g</span>etPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.items.length===0?2:Math.max(...this.items.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.value.getPrintWidth()))+2</span>}<span class="fstat-no" title="function not covered" ></span>write(r</span>){<span class="cstat-no" title="statement not covered" >if(this.items.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(r);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithItems(r)}<span class="fstat-no" title="function not covered" ></span>writeEmpty(r</span>){let t=<span class="cstat-no" title="statement not covered" >new Te("[]");<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;t.setColor(r.context.colors.red).underline(),r.write(t)}<span class="fstat-no" title="function not covered" ></span>writeWithItems(r</span>){let{colors:t}=<span class="cstat-no" title="statement not covered" >r.context;<span class="cstat-no" title="statement not covered" ></span>r.writeLine("[").withIndent(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >r</span>.writeJoined(Ir,this.items).newLine()).w</span>rite("]"),this.hasError&amp;&amp;r.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >r</span>.writeLine(t.red("~".repeat(this.getPrintWidth())))}</span>)}<span class="fstat-no" title="function not covered" ></span>asObject(){</span>}};var Dr=class e extends ze{fields={};suggestions=[];addField(r){this.fields[r.name]=r}addSuggestion(r){this.suggestions.push(r)}getField(r){return this.fields[r]}getDeepField(r){let[t,...n]=r,i=this.getField(t);<span class="missing-if-branch" title="if path not taken" >I</span>if(!i)<span class="cstat-no" title="statement not covered" >return;l</span>et o=i;for(let s of n){let a;<span class="cstat-no" title="statement not covered" >if(o.value instanceof e?a=o.value.getField(s):o.value instanceof kr&amp;&amp;(a=o.value.getField(Number(s))),!a)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >o</span></span>=a}</span>return o}getDeepFieldValue(r){return r.length===0?<span class="branch-0 cbranch-no" title="branch not covered" >this:</span>this.getDeepField(r)?.value}<span class="fstat-no" title="function not covered" >hasField(r</span>){<span class="cstat-no" title="statement not covered" >return!!this.getField(r)}<span class="fstat-no" title="function not covered" ></span>removeAllFields(){<span class="cstat-no" title="statement not covered" ></span>this.fields={}}<span class="fstat-no" title="function not covered" ></span>removeField(r</span>){<span class="cstat-no" title="statement not covered" >delete this.fields[r]}<span class="fstat-no" title="function not covered" >g</span>etFields(){<span class="cstat-no" title="statement not covered" ></span>return this.fields}<span class="fstat-no" title="function not covered" >i</span>sEmpty(){<span class="cstat-no" title="statement not covered" ></span>return Object.keys(this.fields).length===0}<span class="fstat-no" title="function not covered" ></span>getFieldValue(r</span>){<span class="cstat-no" title="statement not covered" >return this.getField(r)?.value}</span>getDeepSubSelectionValue(r){let t=this;for(let n of r){<span class="cstat-no" title="statement not covered" >if(!(t instanceof e))<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.getSubSelectionValue(n);<span class="cstat-no" title="statement not covered" >i</span>f(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>=i}</span>return t}<span class="fstat-no" title="function not covered" >getDeepSelectionParent(r</span>){let t=<span class="cstat-no" title="statement not covered" >this.getSelectionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >f</span>or(let i of r){let o=<span class="cstat-no" title="statement not covered" >n.value.getFieldValue(i);<span class="cstat-no" title="statement not covered" >i</span>f(!o||!(o instanceof e))<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >o.getSelectionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span></span>=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>getSelectionParent(){</span>let r=<span class="cstat-no" title="statement not covered" >this.getField("select")?.value.asObject();<span class="cstat-no" title="statement not covered" >i</span>f(r)<span class="cstat-no" title="statement not covered" >return{kind:"select",value:r};l</span></span>et t=<span class="cstat-no" title="statement not covered" >this.getField("include")?.value.asObject();<span class="cstat-no" title="statement not covered" >i</span>f(t)<span class="cstat-no" title="statement not covered" >return{kind:"include",value:t}}<span class="fstat-no" title="function not covered" ></span></span>getSubSelectionValue(r</span>){<span class="cstat-no" title="statement not covered" >return this.getSelectionParent()?.value.fields[r].value}<span class="fstat-no" title="function not covered" ></span>getPrintWidth(){</span>let r=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" >r</span>eturn r.length==0?2:Math.max(...r.map(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.getPrintWidth()))+2</span>}</span>write(r){let t=Object.values(this.fields);<span class="missing-if-branch" title="if path not taken" >I</span>if(t.length===0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >this.suggestions.length===0){<span class="cstat-no" title="statement not covered" ></span>this.writeEmpty(r);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>this.writeWithContents(r,t)}asObject(){return this}<span class="fstat-no" title="function not covered" >writeEmpty(r</span>){let t=<span class="cstat-no" title="statement not covered" >new Te("{}");<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;t.setColor(r.context.colors.red).underline(),r.write(t)}</span>writeWithContents(r,t){r.writeLine("{").withIndent(()=&gt;{r.writeJoined(Ir,[...t,...this.suggestions]).newLine()}),r.write("}"),this.hasError&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >r</span>.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())))}</span>)}</span>};var Q=class extends ze{constructor(t){super();this.text=t}<span class="fstat-no" title="function not covered" >getPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.text.length}w</span>rite(t){let n=new Te(this.text);this.hasError&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >n.underline().setColor(t.context.colors.red),t</span>.write(n)}<span class="fstat-no" title="function not covered" >asObject(){</span>}};var pt=class{fields=[];addField(r,t){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("+")))}}),this}write(r){let{colors:{green:t}}=r.context;r.writeLine(t("{")).withIndent(()=&gt;{r.writeJoined(Ir,this.fields).newLine()}).write(t("}")).addMarginSymbol(t("+"))}};function Tn(e,r,t){switch(e.kind){<span class="branch-0 cbranch-no" title="branch not covered" >case"MutuallyExclusiveFields":<span class="cstat-no" title="statement not covered" >_d(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-1 cbranch-no" title="branch not covered" >c</span></span>ase"IncludeOnScalar":<span class="cstat-no" title="statement not covered" >Nd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-2 cbranch-no" title="branch not covered" >c</span></span>ase"EmptySelection":<span class="cstat-no" title="statement not covered" >Ld(e,r,t);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-3 cbranch-no" title="branch not covered" >c</span></span>ase"UnknownSelectionField":<span class="cstat-no" title="statement not covered" >qd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-4 cbranch-no" title="branch not covered" >c</span></span>ase"InvalidSelectionValue":<span class="cstat-no" title="statement not covered" >jd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-5 cbranch-no" title="branch not covered" >c</span></span>ase"UnknownArgument":<span class="cstat-no" title="statement not covered" >Vd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-6 cbranch-no" title="branch not covered" >c</span></span>ase"UnknownInputField":<span class="cstat-no" title="statement not covered" >Bd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span></span>ase"RequiredArgumentMissing":Ud(e,r);break;<span class="branch-8 cbranch-no" title="branch not covered" >case"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >Gd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-9 cbranch-no" title="branch not covered" >c</span></span>ase"InvalidArgumentValue":<span class="cstat-no" title="statement not covered" >Qd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-10 cbranch-no" title="branch not covered" >c</span></span>ase"ValueTooLarge":<span class="cstat-no" title="statement not covered" >Wd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-11 cbranch-no" title="branch not covered" >c</span></span>ase"SomeFieldsMissing":<span class="cstat-no" title="statement not covered" >Jd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-12 cbranch-no" title="branch not covered" >c</span></span>ase"TooManyFieldsGiven":<span class="cstat-no" title="statement not covered" >Hd(e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span></span>ase"Union":la(e,r,t);break;<span class="branch-14 cbranch-no" title="branch not covered" >default:<span class="cstat-no" title="statement not covered" >throw new Error("not implemented: "+e.kind)}</span></span>}function <span class="fstat-no" title="function not covered" >_d(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;(t.getField(e.firstField)?.markAsError(),t.getField(e.secondField)?.markAsError()),r.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)</span>}</span>function <span class="fstat-no" title="function not covered" >Nd(e</span>,r){let[t,n]=<span class="cstat-no" title="statement not covered" >Or(e.selectionPath),i</span>=<span class="cstat-no" title="statement not covered" >e.outputType,</span>o=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSelectionParent(t)?.value;<span class="cstat-no" title="statement not covered" >i</span>f(o&amp;&amp;(o.getField(n)?.markAsError(),i))<span class="cstat-no" title="statement not covered" >for(let s of i.fields)<span class="cstat-no" title="statement not covered" >s.isRelation&amp;&amp;o.addSuggestion(new ue(s.name,"true"));<span class="cstat-no" title="statement not covered" >r</span></span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >s=&gt;{l</span>et a=<span class="cstat-no" title="statement not covered" >`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;<span class="cstat-no" title="statement not covered" ></span>return i?a+=` on model ${s.bold(i.name)}. ${dt(s)}`:a+=".",a+=`</span></span>
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function <span class="fstat-no" title="function not covered" >Ld(e</span>,r,t){let n=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >n.getField("omit")?.value.asObject();<span class="cstat-no" title="statement not covered" >i</span>f(i){<span class="cstat-no" title="statement not covered" >Fd(e,r,i);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.hasField("select")){<span class="cstat-no" title="statement not covered" >Md(e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t?.[Ye(e.outputType.name)]){<span class="cstat-no" title="statement not covered" >$d(e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Unknown field at "${e.selectionPath.join(".")} selection"`)</span>}</span>function <span class="fstat-no" title="function not covered" >Fd(e</span>,r,t){<span class="cstat-no" title="statement not covered" >t.removeAllFields();<span class="cstat-no" title="statement not covered" >f</span>or(let n of e.outputType.fields)<span class="cstat-no" title="statement not covered" >t.addSuggestion(new ue(n.name,"false"));<span class="cstat-no" title="statement not covered" >r</span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >Md(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >e.outputType,</span>n=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSelectionParent(e.selectionPath)?.value,i</span>=<span class="cstat-no" title="statement not covered" >n?.isEmpty()??!1;<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;(n.removeAllFields(),ha(n,t)),r.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >i</span>?`The ${o.red("`select`")} statement for type ${o.bold(t.name)} must not be empty. ${dt(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`)</span>}</span>function <span class="fstat-no" title="function not covered" >$d(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >new pt;<span class="cstat-no" title="statement not covered" >f</span>or(let i of e.outputType.fields)<span class="cstat-no" title="statement not covered" >i.isRelation||t.addField(i.name,"false");l</span></span>et n=<span class="cstat-no" title="statement not covered" >new ue("omit",t).makeRequired();<span class="cstat-no" title="statement not covered" >i</span>f(e.selectionPath.length===0)<span class="cstat-no" title="statement not covered" >r.arguments.addSuggestion(n);else{</span>let[i,o]=<span class="cstat-no" title="statement not covered" >Or(e.selectionPath),a</span>=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);<span class="cstat-no" title="statement not covered" >i</span>f(a){let l=<span class="cstat-no" title="statement not covered" >a?.value.asObject()??new Dr;<span class="cstat-no" title="statement not covered" >l</span>.addSuggestion(n),a.value=l}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >`</span>The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >qd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >ya(e.selectionPath,r);<span class="cstat-no" title="statement not covered" >i</span>f(t.parentKind!=="unknown"){<span class="cstat-no" title="statement not covered" >t.field.markAsError();l</span>et n=<span class="cstat-no" title="statement not covered" >t.parent;<span class="cstat-no" title="statement not covered" ></span>switch(t.parentKind){case"select":<span class="cstat-no" title="statement not covered" >ha(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"include":<span class="cstat-no" title="statement not covered" >Kd(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"omit":<span class="cstat-no" title="statement not covered" >Yd(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;{l</span>et i=<span class="cstat-no" title="statement not covered" >[`Unknown field ${n.red(`\`${t.fieldName}\``)}`];<span class="cstat-no" title="statement not covered" >r</span>eturn t.parentKind!=="unknown"&amp;&amp;i.push(`for ${n.bold(t.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(dt(n)),i.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >jd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >ya(e.selectionPath,r);<span class="cstat-no" title="statement not covered" >t</span>.parentKind!=="unknown"&amp;&amp;t.field.value.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>Invalid value for selection field \`${n.red(t.fieldName)}\`: ${e.underlyingError}`)</span>}</span>function <span class="fstat-no" title="function not covered" >Vd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >e.argumentPath[0],</span>n=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;(n.getField(t)?.markAsError(),zd(n,e.arguments)),r.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >f</span>a(i,t,e.arguments.map(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >o</span>.name)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >Bd(e</span>,r){let[t,n]=<span class="cstat-no" title="statement not covered" >Or(e.argumentPath),i</span>=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >i</span>f(i){<span class="cstat-no" title="statement not covered" >i.getDeepField(e.argumentPath)?.markAsError();l</span>et o=<span class="cstat-no" title="statement not covered" >i.getDeepFieldValue(t)?.asObject();<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;ba(o,e.inputType)}<span class="cstat-no" title="statement not covered" ></span>r</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >f</span>a(o,n,e.inputType.fields.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >s</span>.name)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >fa(e</span>,r,t){let n=<span class="cstat-no" title="statement not covered" >[`Unknown argument \`${e.red(r)}\`.`],i</span>=<span class="cstat-no" title="statement not covered" >Xd(r,t);<span class="cstat-no" title="statement not covered" >r</span>eturn i&amp;&amp;n.push(`Did you mean \`${e.green(i)}\`?`),t.length&gt;0&amp;&amp;n.push(dt(e)),n.join(" ")}</span>function Ud(e,r){let t;r.addErrorMessage(l=&gt;t?.value instanceof Q&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t.value.text==="null"?<span class="branch-0 cbranch-no" title="branch not covered" >`</span>Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:</span>`Argument \`${l.green(o)}\` is missing.`);let n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="missing-if-branch" title="if path not taken" >I</span>if(!n)<span class="cstat-no" title="statement not covered" >return;l</span>et[i,o]=Or(e.argumentPath),s=new pt,a=n.getDeepFieldValue(i)?.asObject();<span class="missing-if-branch" title="else path not taken" >E</span>if(a){if(t=a.getField(o),t&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >a.removeField(o),e</span>.inputTypes.length===1&amp;&amp;e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new ue(o,s).makeRequired())}else<span class="missing-if-branch" title="else path not taken" >E</span>{let l=<span class="cstat-no" title="statement not covered" >e.inputTypes.map(ga).join(" | ");<span class="cstat-no" title="statement not covered" >a</span>.addSuggestion(new ue(o,l).makeRequired())}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(e.dependentArgumentPath){<span class="cstat-no" title="statement not covered" >n.getDeepField(e.dependentArgumentPath)?.markAsError();l</span>et[,l]=<span class="cstat-no" title="statement not covered" >Or(e.dependentArgumentPath);<span class="cstat-no" title="statement not covered" >r</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >u=&gt;<span class="cstat-no" title="statement not covered" >`</span>Argument \`${u.green(o)}\` is required because argument \`${u.green(l)}\` was provided.`)</span>}</span>}}function <span class="fstat-no" title="function not covered" >ga(e</span>){<span class="cstat-no" title="statement not covered" >return e.kind==="list"?`${ga(e.elementType)}[]`:e.name}f</span>unction <span class="fstat-no" title="function not covered" >Gd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >Cn("or",e.argument.typeNames.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >i</span>.green(s)));<span class="cstat-no" title="statement not covered" >r</span></span>eturn`Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}</span></span>function <span class="fstat-no" title="function not covered" >Qd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >[`Invalid value for argument \`${i.bold(t)}\``];<span class="cstat-no" title="statement not covered" >i</span>f(e.underlyingError&amp;&amp;o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length&gt;0){let s=<span class="cstat-no" title="statement not covered" >Cn("or",e.argument.typeNames.map(<span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >i</span>.green(a)));<span class="cstat-no" title="statement not covered" >o</span></span>.push(` Expected ${s}.`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.join("")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Wd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i</span>;<span class="cstat-no" title="statement not covered" >if(n){let s=<span class="cstat-no" title="statement not covered" >n.getDeepField(e.argumentPath)?.value;<span class="cstat-no" title="statement not covered" >s</span>?.markAsError(),s instanceof Q&amp;&amp;(i=s.text)</span>}<span class="cstat-no" title="statement not covered" >r</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;{l</span>et s=<span class="cstat-no" title="statement not covered" >["Unable to fit value"];<span class="cstat-no" title="statement not covered" >r</span>eturn i&amp;&amp;s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Jd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >e.argumentPath[e.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(e.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" >i</span>&amp;&amp;ba(i,e.inputType)}<span class="cstat-no" title="statement not covered" ></span>r</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >[`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" >r</span>eturn e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Cn("or",e.constraints.requiredFields.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >`</span>\`${i.bold(s)}\``)</span>)} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(dt(i)),o.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Hd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >e.argumentPath[e.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(n){let o=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(e.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;(o.markAsError(),i=Object.keys(o.getFields()))}<span class="cstat-no" title="statement not covered" ></span>r</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;{l</span>et s=<span class="cstat-no" title="statement not covered" >[`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" >r</span>eturn e.constraints.minFieldCount===1&amp;&amp;e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Cn("and",i.map(<span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >o</span>.red(a)))}.</span> Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >ha(e</span>,r){<span class="cstat-no" title="statement not covered" >for(let t of r.fields)<span class="cstat-no" title="statement not covered" >e.hasField(t.name)||e.addSuggestion(new ue(t.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >Kd(e</span>,r){<span class="cstat-no" title="statement not covered" >for(let t of r.fields)<span class="cstat-no" title="statement not covered" >t.isRelation&amp;&amp;!e.hasField(t.name)&amp;&amp;e.addSuggestion(new ue(t.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >Yd(e</span>,r){<span class="cstat-no" title="statement not covered" >for(let t of r.fields)<span class="cstat-no" title="statement not covered" >!e.hasField(t.name)&amp;&amp;!t.isRelation&amp;&amp;e.addSuggestion(new ue(t.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >zd(e</span>,r){<span class="cstat-no" title="statement not covered" >for(let t of r)<span class="cstat-no" title="statement not covered" >e.hasField(t.name)||e.addSuggestion(new ue(t.name,t.typeNames.join(" | ")))}</span></span>function <span class="fstat-no" title="function not covered" >ya(e</span>,r){let[t,n]=<span class="cstat-no" title="statement not covered" >Or(e),i</span>=<span class="cstat-no" title="statement not covered" >r.arguments.getDeepSubSelectionValue(t)?.asObject();<span class="cstat-no" title="statement not covered" >i</span>f(!i)<span class="cstat-no" title="statement not covered" >return{parentKind:"unknown",fieldName:n};l</span></span>et o=<span class="cstat-no" title="statement not covered" >i.getFieldValue("select")?.asObject(),s</span>=<span class="cstat-no" title="statement not covered" >i.getFieldValue("include")?.asObject(),a</span>=<span class="cstat-no" title="statement not covered" >i.getFieldValue("omit")?.asObject(),l</span>=<span class="cstat-no" title="statement not covered" >o?.getField(n);<span class="cstat-no" title="statement not covered" >r</span>eturn o&amp;&amp;l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&amp;&amp;l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&amp;&amp;l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}</span>function <span class="fstat-no" title="function not covered" >ba(e</span>,r){<span class="cstat-no" title="statement not covered" >if(r.kind==="object")<span class="cstat-no" title="statement not covered" >for(let t of r.fields)<span class="cstat-no" title="statement not covered" >e.hasField(t.name)||e.addSuggestion(new ue(t.name,t.typeNames.join(" | ")))}</span></span></span>function Or(e){let r=[...e],t=r.pop();<span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >throw new Error("unexpected empty path");r</span>eturn[r,t]}function <span class="fstat-no" title="function not covered" >dt({</span>green:e,enabled:r}){<span class="cstat-no" title="statement not covered" >return"Available options are "+(r?`listed in ${e("green")}`:"marked with ?")+"."}</span>function <span class="fstat-no" title="function not covered" >Cn(e</span>,r){<span class="cstat-no" title="statement not covered" >if(r.length===1)<span class="cstat-no" title="statement not covered" >return r[0];l</span></span>et t=<span class="cstat-no" title="statement not covered" >[...r],n</span>=<span class="cstat-no" title="statement not covered" >t.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn`${t.join(", ")} ${e} ${n}`}v</span>ar Zd=3;function <span class="fstat-no" title="function not covered" >Xd(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >1/0,n</span>;<span class="cstat-no" title="statement not covered" >for(let i of r){let o=<span class="cstat-no" title="statement not covered" >(0,ma.default)(e,i);<span class="cstat-no" title="statement not covered" >o</span>&gt;Zd||o&lt;t&amp;&amp;(t=o,n=i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>var mt=class{modelName;name;typeName;isList;isEnum;<span class="fstat-no" title="function not covered" >constructor(r</span>,t,n,i,o){<span class="cstat-no" title="statement not covered" >this.modelName=r,this.name=t,this.typeName=n,this.isList=i,this.isEnum=o}<span class="fstat-no" title="function not covered" ></span>_toGraphQLInputType(){</span>let r=<span class="cstat-no" title="statement not covered" >this.isList?"List":"",t</span>=<span class="cstat-no" title="statement not covered" >this.isEnum?"Enum":"";<span class="cstat-no" title="statement not covered" >r</span>eturn`${r}${t}${this.typeName}FieldRefInput&lt;${this.modelName}&gt;`}}</span>;function _r(e){return e instanceof mt}var In=Symbol(),zi=new WeakMap,Me=class{constructor(r){r===In?zi.set(this,`Prisma.${this._getName()}`):<span class="branch-1 cbranch-no" title="branch not covered" >zi.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}</span>_getName(){return this.constructor.name}<span class="fstat-no" title="function not covered" >toString(){<span class="cstat-no" title="statement not covered" ></span>return zi.get(this)}</span>},ft=class extends Me{<span class="fstat-no" title="function not covered" >_getNamespace(){<span class="cstat-no" title="statement not covered" ></span>return"NullTypes"}</span>},gt=class extends ft{#e};Zi(gt,"DbNull");var ht=class extends ft{#e};Zi(ht,"JsonNull");var yt=class extends ft{#e};Zi(yt,"AnyNull");var kn={classes:{DbNull:gt,JsonNull:ht,AnyNull:yt},instances:{DbNull:new gt(In),JsonNull:new ht(In),AnyNull:new yt(In)}};function Zi(e,r){Object.defineProperty(e,"name",{value:r,configurable:!0})}var Ea=": ",Dn=class{constructor(r,t){this.name=r;this.value=t}hasError=!1;<span class="fstat-no" title="function not covered" >markAsError(){<span class="cstat-no" title="statement not covered" ></span>this.hasError=!0}<span class="fstat-no" title="function not covered" ></span>getPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.name.length+this.value.getPrintWidth()+Ea.length}w</span>rite(r){let t=new Te(this.name);this.hasError&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t.underline().setColor(r.context.colors.red),r</span>.write(t).write(Ea).write(this.value)}};var Xi=class{arguments;errorMessages=[];constructor(r){this.arguments=r}write(r){r.write(this.arguments)}addErrorMessage(r){this.errorMessages.push(r)}renderAllMessages(r){return this.errorMessages.map(t=&gt;t(r)).join(`
`)}};function Nr(e){return new Xi(wa(e))}function wa(e){let r=new Dr;for(let[t,n]of Object.entries(e)){let i=new Dn(t,xa(n));r.addField(i)}return r}function xa(e){if(typeof e=="string")return new Q(JSON.stringify(e));<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e=="number"||typeof e=="boolean")<span class="cstat-no" title="statement not covered" >return new Q(String(e));<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return new Q(`${e}n`);i</span>f(e===null)return new Q("null");<span class="missing-if-branch" title="if path not taken" >I</span>if(e===void 0)<span class="cstat-no" title="statement not covered" >return new Q("undefined");<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(Rr(e))<span class="cstat-no" title="statement not covered" >return new Q(`new Prisma.Decimal("${e.toFixed()}")`);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e instanceof Uint8Array)<span class="cstat-no" title="statement not covered" >return Buffer.isBuffer(e)?new Q(`Buffer.alloc(${e.byteLength})`):new Q(`new Uint8Array(${e.byteLength})`);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e instanceof Date){let r=<span class="cstat-no" title="statement not covered" >wn(e)?e.toISOString():"Invalid Date";<span class="cstat-no" title="statement not covered" >r</span>eturn new Q(`new Date("${r}")`)}</span>return e instanceof Me?<span class="branch-0 cbranch-no" title="branch not covered" >new Q(`Prisma.${e._getName()}`):_</span>r(e)?<span class="branch-0 cbranch-no" title="branch not covered" >new Q(`prisma.${Ye(e.modelName)}.$fields.${e.name}`):A</span>rray.isArray(e)?<span class="branch-0 cbranch-no" title="branch not covered" >em(e):t</span>ypeof e=="object"?wa(e):<span class="branch-1 cbranch-no" title="branch not covered" >new Q(Object.prototype.toString.call(e))}</span>function <span class="fstat-no" title="function not covered" >em(e</span>){let r=<span class="cstat-no" title="statement not covered" >new kr;<span class="cstat-no" title="statement not covered" >f</span>or(let t of e)<span class="cstat-no" title="statement not covered" >r.addItem(xa(t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function On(e,r){let t=r==="pretty"?<span class="branch-0 cbranch-no" title="branch not covered" >da:A</span>n,n=e.renderAllMessages(t),i=new Cr(0,{colors:t}).write(e).toString();return{message:n,args:i}}function _n({args:e,errors:r,errorFormat:t,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=Nr(e);for(let p of r)Tn(p,a,s);let{message:l,args:u}=On(a,t),c=Pn({message:l,callsite:n,originalMethod:i,showColors:t==="pretty",callArguments:u});throw new Z(c,{clientVersion:o})}function Se(e){return e.replace(/^./,r=&gt;r.toLowerCase())}function <span class="fstat-no" title="function not covered" >Pa(e</span>,r,t){let n=<span class="cstat-no" title="statement not covered" >Se(t);<span class="cstat-no" title="statement not covered" >r</span>eturn!r.result||!(r.result.$allModels||r.result[n])?e:rm({...e,...va(r.name,e,r.result.$allModels),...va(r.name,e,r.result[n])})}</span>function <span class="fstat-no" title="function not covered" >rm(e</span>){let r=<span class="cstat-no" title="statement not covered" >new Pe,t</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >r.getOrCreate(n,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >t</span>(o,i)):[</span>n])</span></span>);<span class="cstat-no" title="statement not covered" >r</span>eturn xr(e,<span class="fstat-no" title="function not covered" >n=&gt;(<span class="cstat-no" title="statement not covered" >{</span>...n,needs:t(n.name,new Set)}))}</span></span>function <span class="fstat-no" title="function not covered" >va(e</span>,r,t){<span class="cstat-no" title="statement not covered" >return t?xr(t,<span class="fstat-no" title="function not covered" >({</span>needs:n,compute:i},o)=&gt;(<span class="cstat-no" title="statement not covered" >{name:o,needs:n?Object.keys(n).filter(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >n</span>[s])</span>:[],compute:tm(r,o,i)})):{</span>}}</span>function <span class="fstat-no" title="function not covered" >tm(e</span>,r,t){let n=<span class="cstat-no" title="statement not covered" >e?.[r]?.compute;<span class="cstat-no" title="statement not covered" >r</span>eturn n?<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >t</span>({...i,[r]:n(i)}):t</span>}</span>function Ta(e,r){<span class="missing-if-branch" title="else path not taken" >E</span>if(!r)return e;let t=<span class="cstat-no" title="statement not covered" >{...e};<span class="cstat-no" title="statement not covered" >f</span>or(let n of Object.values(r))<span class="cstat-no" title="statement not covered" >if(e[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >t[i]=!0;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn t}</span>function Sa(e,r){<span class="missing-if-branch" title="else path not taken" >E</span>if(!r)return e;let t=<span class="cstat-no" title="statement not covered" >{...e};<span class="cstat-no" title="statement not covered" >f</span>or(let n of Object.values(r))<span class="cstat-no" title="statement not covered" >if(!e[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >delete t[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn t}</span>var Nn=class{<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >this.extension=r;<span class="cstat-no" title="statement not covered" >t</span>his.previous=t}<span class="cstat-no" title="statement not covered" ></span>computedFieldsCache=new Pe;<span class="cstat-no" title="statement not covered" >m</span>odelExtensionsCache=new Pe;<span class="cstat-no" title="statement not covered" >q</span>ueryCallbacksCache=new Pe;<span class="cstat-no" title="statement not covered" >c</span>lientExtensions=ut(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());<span class="cstat-no" title="statement not covered" >b</span></span>atchCallbacks=ut(<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >this.previous?.getAllBatchQueryCallbacks()??[],</span>t=<span class="cstat-no" title="statement not covered" >this.extension.query?.$__internalBatch;<span class="cstat-no" title="statement not covered" >r</span>eturn t?r.concat(t):r}</span>);<span class="fstat-no" title="function not covered" >g</span>etAllComputedFields(r</span>){<span class="cstat-no" title="statement not covered" >return this.computedFieldsCache.getOrCreate(r,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>a(this.previous?.getAllComputedFields(r),this.extension,r))}<span class="fstat-no" title="function not covered" ></span></span>getAllClientExtensions(){<span class="cstat-no" title="statement not covered" ></span>return this.clientExtensions.get()}<span class="fstat-no" title="function not covered" ></span>getAllModelExtensions(r</span>){<span class="cstat-no" title="statement not covered" >return this.modelExtensionsCache.getOrCreate(r,<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >Se(r);<span class="cstat-no" title="statement not covered" >r</span>eturn!this.extension.model||!(this.extension.model[t]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(r):{...this.previous?.getAllModelExtensions(r),...this.extension.model.$allModels,...this.extension.model[t]}}</span>)}<span class="fstat-no" title="function not covered" ></span>getAllQueryCallbacks(r</span>,t){<span class="cstat-no" title="statement not covered" >return this.queryCallbacksCache.getOrCreate(`${r}:${t}`,<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >this.previous?.getAllQueryCallbacks(r,t)??[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >this.extension.query;<span class="cstat-no" title="statement not covered" ></span>return!o||!(o[r]||o.$allModels||o[t]||o.$allOperations)?n:(o[r]!==void 0&amp;&amp;(o[r][t]!==void 0&amp;&amp;i.push(o[r][t]),o[r].$allOperations!==void 0&amp;&amp;i.push(o[r].$allOperations)),r!=="$none"&amp;&amp;o.$allModels!==void 0&amp;&amp;(o.$allModels[t]!==void 0&amp;&amp;i.push(o.$allModels[t]),o.$allModels.$allOperations!==void 0&amp;&amp;i.push(o.$allModels.$allOperations)),o[t]!==void 0&amp;&amp;i.push(o[t]),o.$allOperations!==void 0&amp;&amp;i.push(o.$allOperations),n.concat(i))}</span>)}<span class="fstat-no" title="function not covered" ></span>getAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" ></span>return this.batchCallbacks.get()}</span>},Lr=class e{constructor(r){this.head=r}static empty(){return new e}<span class="fstat-no" title="function not covered" >static s</span>ingle(r){<span class="cstat-no" title="statement not covered" >return new e(new Nn(r))}</span>isEmpty(){return this.head===void 0}<span class="fstat-no" title="function not covered" >append(r</span>){<span class="cstat-no" title="statement not covered" >return new e(new Nn(r,this.head))}</span>getAllComputedFields(r){return this.head?.getAllComputedFields(r)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(r){return this.head?.getAllModelExtensions(r)}<span class="fstat-no" title="function not covered" >getAllQueryCallbacks(r</span>,t){<span class="cstat-no" title="statement not covered" >return this.head?.getAllQueryCallbacks(r,t)??[]}g</span>etAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}};var Ln=class{<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >this.name=r}</span>};function Ra(e){return e instanceof Ln}function <span class="fstat-no" title="function not covered" >Aa(e</span>){<span class="cstat-no" title="statement not covered" >return new Ln(e)}</span>var Ca=Symbol(),bt=class{constructor(r){<span class="missing-if-branch" title="if path not taken" >I</span>if(r!==Ca)<span class="cstat-no" title="statement not covered" >throw new Error("Skip instance can not be constructed directly")}<span class="fstat-no" title="function not covered" ></span>ifUndefined(r</span>){<span class="cstat-no" title="statement not covered" >return r===void 0?Fn:r}</span>},Fn=new bt(Ca);function Re(e){return e instanceof bt}var nm={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},Ia="explicitly `undefined` values are not allowed";function Mn({modelName:e,action:r,args:t,runtimeDataModel:n,extensions:i=<span class="branch-0 cbranch-no" title="branch not covered" >Lr.empty(),</span>callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c}){let p=new eo({runtimeDataModel:n,modelName:e,action:r,rootArgs:t,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c});return{modelName:e,action:nm[r],query:Et(t,p)}}function Et({select:e,include:r,...t}={},n){let i=t.omit;return delete t.omit,{arguments:Da(t,n),selection:im(e,r,i,n)}}function im(e,r,t,n){return e?(r?<span class="branch-0 cbranch-no" title="branch not covered" >n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):t</span>&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),l</span>m(e,n)):om(n,r,t)}function om(e,r,t){let n={};return e.modelOrType&amp;&amp;!e.isRawAction()&amp;&amp;(n.$composites=!0,n.$scalars=!0),r&amp;&amp;sm(n,r,e),am(n,t,e),n}function sm(e,r,t){for(let[n,i]of Object.entries(r)){<span class="missing-if-branch" title="if path not taken" >I</span>if(Re(i))<span class="cstat-no" title="statement not covered" >continue;l</span>et o=t.nestSelection(n);<span class="missing-if-branch" title="if path not taken" >I</span>if(ro(i,o),i===!1||i===void 0){<span class="cstat-no" title="statement not covered" >e[n]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>let s=t.findField(n);<span class="missing-if-branch" title="else path not taken" >E</span>if(s&amp;&amp;s.kind!=="object"&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >t.throwValidationError({kind:"IncludeOnScalar",selectionPath:t.getSelectionPath().concat(n),outputType:t.getOutputTypeDescription()}),s</span>){e[n]=Et(i===!0?{}:<span class="branch-1 cbranch-no" title="branch not covered" >i,o</span>);continue}<span class="cstat-no" title="statement not covered" >if(i===!0){<span class="cstat-no" title="statement not covered" >e[n]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>e</span>[n]=Et(i,o)}</span>}function am(e,r,t){let n=t.getComputedFields(),i={...t.getGlobalOmit(),...r},o=Sa(i,n);for(let[s,a]of Object.entries(o)){<span class="cstat-no" title="statement not covered" >if(Re(a))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >r</span></span>o(a,t.nestSelection(s));l</span>et l=<span class="cstat-no" title="statement not covered" >t.findField(s);<span class="cstat-no" title="statement not covered" >n</span>?.[s]&amp;&amp;!l||(e[s]=!a)}</span>}function lm(e,r){let t={},n=r.getComputedFields(),i=Ta(e,n);for(let[o,s]of Object.entries(i)){<span class="missing-if-branch" title="if path not taken" >I</span>if(Re(s))<span class="cstat-no" title="statement not covered" >continue;l</span>et a=r.nestSelection(o);ro(s,a);let l=r.findField(o);<span class="missing-if-branch" title="else path not taken" >E</span>if(!(n?.[o]&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!l)){<span class="missing-if-branch" title="if path not taken" >I</span></span>if(s===!1||s===void 0||Re(s)){<span class="cstat-no" title="statement not covered" >t[o]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>if(s===!0){l?.kind==="object"?<span class="branch-0 cbranch-no" title="branch not covered" >t[o]=Et({},a):t</span>[o]=!0;continue}t[o]=Et(s,a)}}return t}function ka(e,r){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return{$type:"BigInt",value:String(e)};i</span>f(Sr(e)){<span class="missing-if-branch" title="else path not taken" >E</span>if(wn(e))return{$type:"DateTime",value:e.toISOString()};<span class="cstat-no" title="statement not covered" >r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(Ra(e))<span class="cstat-no" title="statement not covered" >return{$type:"Param",value:e.name};<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(_r(e))<span class="cstat-no" title="statement not covered" >return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};i</span>f(Array.isArray(e))return um(e,r);<span class="missing-if-branch" title="if path not taken" >I</span>if(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn{$type:"Bytes",value:Buffer.from(t,n,i).toString("base64")}}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(cm(e))<span class="cstat-no" title="statement not covered" >return e.values;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(Rr(e))<span class="cstat-no" title="statement not covered" >return{$type:"Decimal",value:e.toFixed()};<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e instanceof Me){<span class="cstat-no" title="statement not covered" >if(e!==kn.instances[e._getName()])<span class="cstat-no" title="statement not covered" >throw new Error("Invalid ObjectEnumValue");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"Enum",value:e._getName()}}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(pm(e))<span class="cstat-no" title="statement not covered" >return e.toJSON();<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(typeof e=="object")return Da(e,r);<span class="cstat-no" title="statement not covered" >r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}</span>function Da(e,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.$type)<span class="cstat-no" title="statement not covered" >return{$type:"Raw",value:e};l</span>et t={};for(let n in e){let i=e[n],o=r.nestArgument(n);Re(i)||(i!==void 0?t[n]=ka(i,o):<span class="branch-1 cbranch-no" title="branch not covered" >r.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;r.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:r.getSelectionPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:Ia})</span>)}return t}function um(e,r){let t=[];for(let n=0;n&lt;e.length;n++){let i=r.nestArgument(String(n)),o=e[n];<span class="missing-if-branch" title="if path not taken" >I</span>if(o===void 0||Re(o)){let s=<span class="cstat-no" title="statement not covered" >o===void 0?"undefined":"Prisma.skip";<span class="cstat-no" title="statement not covered" >r</span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${r.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}</span>t.push(ka(o,i))}return t}function cm(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.__prismaRawParameters__===!0}function pm(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;typeof e.toJSON=="function"}function ro(e,r){e===void 0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >r</span>.throwValidationError({kind:"InvalidSelectionValue",selectionPath:r.getSelectionPath(),underlyingError:Ia})}</span>var eo=class e{constructor(r){this.params=r;this.params.modelName&amp;&amp;(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??<span class="branch-1 cbranch-no" title="branch not covered" >this.params.runtimeDataModel.types[this.params.modelName])</span>}modelOrType;<span class="fstat-no" title="function not covered" >throwValidationError(r</span>){<span class="cstat-no" title="statement not covered" >_n({errors:[r],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}<span class="fstat-no" title="function not covered" ></span>getSelectionPath(){<span class="cstat-no" title="statement not covered" ></span>return this.params.selectionPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentPath(){<span class="cstat-no" title="statement not covered" ></span>return this.params.argumentPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentName(){<span class="cstat-no" title="statement not covered" ></span>return this.params.argumentPath[this.params.argumentPath.length-1]}<span class="fstat-no" title="function not covered" >g</span>etOutputTypeDescription(){<span class="cstat-no" title="statement not covered" ></span>if(!(!this.params.modelName||!this.modelOrType))<span class="cstat-no" title="statement not covered" >return{name:this.params.modelName,fields:this.modelOrType.fields.map(<span class="fstat-no" title="function not covered" >r=&gt;(<span class="cstat-no" title="statement not covered" >{</span>name:r.name,typeName:"boolean",isRelation:r.kind==="object"}))}</span>}</span></span>isRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}<span class="fstat-no" title="function not covered" >isPreviewFeatureOn(r</span>){<span class="cstat-no" title="statement not covered" >return this.params.previewFeatures.includes(r)}</span>getComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}findField(r){return this.modelOrType?.fields.find(t=&gt;t.name===r)}nestSelection(r){let t=this.findField(r),n=t?.kind==="object"?t.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(r)})}getGlobalOmit(){return this.params.modelName&amp;&amp;this.shouldApplyGlobalOmit()?this.params.globalOmit?.[Ye(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){<span class="branch-0 cbranch-no" title="branch not covered" >case"findFirst":<span class="branch-1 cbranch-no" title="branch not covered" >c</span>ase"findFirstOrThrow":<span class="branch-2 cbranch-no" title="branch not covered" >c</span>ase"findUniqueOrThrow":c</span>ase"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;<span class="branch-11 cbranch-no" title="branch not covered" >case"executeRaw":<span class="branch-12 cbranch-no" title="branch not covered" >c</span>ase"aggregateRaw":<span class="branch-13 cbranch-no" title="branch not covered" >c</span>ase"runCommandRaw":<span class="branch-14 cbranch-no" title="branch not covered" >c</span>ase"findRaw":c</span>ase"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;<span class="branch-22 cbranch-no" title="branch not covered" >default:<span class="cstat-no" title="statement not covered" >Ne(this.params.action,"Unknown action")}</span></span>}nestArgument(r){return new e({...this.params,argumentPath:this.params.argumentPath.concat(r)})}};function <span class="fstat-no" title="function not covered" >Oa(e</span>){<span class="cstat-no" title="statement not covered" >if(!e._hasPreviewFlag("metrics"))<span class="cstat-no" title="statement not covered" >throw new Z("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}</span></span>var Fr=class{_client;constructor(r){this._client=r}<span class="fstat-no" title="function not covered" >prometheus(r</span>){<span class="cstat-no" title="statement not covered" >return Oa(this._client),this._client._engine.metrics({format:"prometheus",...r})}<span class="fstat-no" title="function not covered" ></span>json(r</span>){<span class="cstat-no" title="statement not covered" >return Oa(this._client),this._client._engine.metrics({format:"json",...r})}</span>};function _a(e,r){let t=ut(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >d</span>m(r));O</span>bject.defineProperty(e,"dmmf",{get:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>.get()}</span>)}function <span class="fstat-no" title="function not covered" >dm(e</span>){<span class="cstat-no" title="statement not covered" >return{datamodel:{models:to(e.models),enums:to(e.enums),types:to(e.types)}}}</span>function <span class="fstat-no" title="function not covered" >to(e</span>){<span class="cstat-no" title="statement not covered" >return Object.entries(e).map(<span class="fstat-no" title="function not covered" >([</span>r,t])=&gt;(<span class="cstat-no" title="statement not covered" >{name:r,...t}))}</span></span>var no=new WeakMap,$n="$$PrismaTypedSql",wt=class{<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >no.set(this,{sql:r,values:t}),Object.defineProperty(this,$n,{value:$n})}<span class="fstat-no" title="function not covered" ></span>get s</span>ql(){<span class="cstat-no" title="statement not covered" >return no.get(this).sql}<span class="fstat-no" title="function not covered" >g</span>et v</span>alues(){<span class="cstat-no" title="statement not covered" >return no.get(this).values}}</span>;function <span class="fstat-no" title="function not covered" >Na(e</span>){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..r)=&gt;<span class="cstat-no" title="statement not covered" >new wt(e,r)}</span></span>function <span class="fstat-no" title="function not covered" >qn(e</span>){<span class="cstat-no" title="statement not covered" >return e!=null&amp;&amp;e[$n]===$n}</span>var fu=C(Si());var gu=require("node:async_hooks"),hu=require("node:events"),yu=C(require("node:fs")),ti=C(require("node:path"));var oe=class e{constructor(r,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(r.length-1!==t.length)<span class="cstat-no" title="statement not covered" >throw r.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${r.length} strings to have ${r.length-1} values`);l</span>et n=t.reduce(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >s+(a instanceof e?a.values.length:1),0</span>);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=r[0];let i=0,o=0;for(;i&lt;t.length;){let s=<span class="cstat-no" title="statement not covered" >t[i++],</span>a=<span class="cstat-no" title="statement not covered" >r[i];<span class="cstat-no" title="statement not covered" ></span>if(s instanceof e){<span class="cstat-no" title="statement not covered" >this.strings[o]+=s.strings[0];l</span>et l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;l&lt;s.values.length;)<span class="cstat-no" title="statement not covered" >this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];<span class="cstat-no" title="statement not covered" >t</span></span>his.strings[o]+=a}</span>else <span class="cstat-no" title="statement not covered" >this.values[o++]=s,this.strings[o]=a}</span></span>}<span class="fstat-no" title="function not covered" >get s</span>ql(){let r=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>t=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;t&lt;r;)<span class="cstat-no" title="statement not covered" >n+=`?${this.strings[t++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>get s</span>tatement(){let r=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>t=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;t&lt;r;)<span class="cstat-no" title="statement not covered" >n+=`:${t}${this.strings[t++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>get t</span>ext(){let r=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>t=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;t&lt;r;)<span class="cstat-no" title="statement not covered" >n+=`$${t}${this.strings[t++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>inspect(){<span class="cstat-no" title="statement not covered" ></span>return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}</span>};function <span class="fstat-no" title="function not covered" >La(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >",",</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"")</span>{<span class="cstat-no" title="statement not covered" >if(e.length===0)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new oe([t,...Array(e.length-1).fill(r),n],e)}</span>function io(e){return new oe([e],[])}var Fa=io("");function <span class="fstat-no" title="function not covered" >oo(e</span>,...r){<span class="cstat-no" title="statement not covered" >return new oe(e,r)}</span>function xt(e){return{getKeys(){return Object.keys(e)},<span class="fstat-no" title="function not covered" >getPropertyValue(r</span>){<span class="cstat-no" title="statement not covered" >return e[r]}}</span>}function re(e,r){return{getKeys(){return[e]},getPropertyValue(){return r()}}}function lr(e){let r=new Pe;return{getKeys(){return e.getKeys()},getPropertyValue(t){return r.getOrCreate(t,()=&gt;e.getPropertyValue(t))},getPropertyDescriptor(t){return e.getPropertyDescriptor?.(t)}}}var jn={enumerable:!0,configurable:!0,writable:!0};function Vn(e){let r=new Set(e);return{getPrototypeOf:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>bject.prototype,</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >j</span>n,h</span>as:<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r.has(n),s</span>et:<span class="fstat-no" title="function not covered" >(t</span>,n,i)=&gt;<span class="cstat-no" title="statement not covered" >r.add(n)&amp;&amp;Reflect.set(t,n,i),o</span>wnKeys:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >[</span>...r]}}</span>var Ma=Symbol.for("nodejs.util.inspect.custom");function he(e,r){let t=mm(r),n=new Set,i=new Proxy(e,{get(o,s){<span class="missing-if-branch" title="if path not taken" >I</span>if(n.has(s))<span class="cstat-no" title="statement not covered" >return o[s];l</span>et a=t.get(s);return a?a.getPropertyValue(s):o[s]},<span class="fstat-no" title="function not covered" >has(o</span>,s){<span class="cstat-no" title="statement not covered" >if(n.has(s))<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et a=<span class="cstat-no" title="statement not covered" >t.get(s);<span class="cstat-no" title="statement not covered" >r</span>eturn a?a.has?.(s)??!0:Reflect.has(o,s)}</span>,<span class="fstat-no" title="function not covered" >ownKeys(o</span>){let s=<span class="cstat-no" title="statement not covered" >$a(Reflect.ownKeys(o),t),a</span>=<span class="cstat-no" title="statement not covered" >$a(Array.from(t.keys()),t);<span class="cstat-no" title="statement not covered" >r</span>eturn[...new Set([...s,...a,...n])]},s</span>et(o,s,a){return t.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?<span class="branch-0 cbranch-no" title="branch not covered" >!1:(n</span>.add(s),Reflect.set(o,s,a))},getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);<span class="missing-if-branch" title="if path not taken" >I</span>if(a&amp;&amp;!a.configurable)<span class="cstat-no" title="statement not covered" >return a;l</span>et l=t.get(s);return l?l.getPropertyDescriptor?{...jn,...l?.getPropertyDescriptor(s)}:<span class="branch-1 cbranch-no" title="branch not covered" >jn:a</span>},<span class="fstat-no" title="function not covered" >defineProperty(o</span>,s,a){<span class="cstat-no" title="statement not covered" >return n.add(s),Reflect.defineProperty(o,s,a)}</span>,getPrototypeOf:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>bject.prototype}</span>);return i[Ma]=<span class="fstat-no" title="function not covered" >function(){l</span>et o=<span class="cstat-no" title="statement not covered" >{...this};<span class="cstat-no" title="statement not covered" >r</span>eturn delete o[Ma],o}</span>,i}function mm(e){let r=new Map;for(let t of e){let n=t.getKeys();for(let i of n)r.set(i,t)}return r}function <span class="fstat-no" title="function not covered" >$a(e</span>,r){<span class="cstat-no" title="statement not covered" >return e.filter(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >r</span>.get(t)?.has?.(t)??!0)}</span></span>function Mr(e){return{getKeys(){return e},<span class="fstat-no" title="function not covered" >has(){<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(){}</span>}}function $r(e,r){return{batch:e,transaction:r?.kind==="batch"?{isolationLevel:r.options.isolationLevel}:<span class="branch-1 cbranch-no" title="branch not covered" >void 0}</span>}function <span class="fstat-no" title="function not covered" >qa(e</span>){<span class="cstat-no" title="statement not covered" >if(e===void 0)<span class="cstat-no" title="statement not covered" >return"";l</span></span>et r=<span class="cstat-no" title="statement not covered" >Nr(e);<span class="cstat-no" title="statement not covered" >r</span>eturn new Cr(0,{colors:An}).write(r).toString()}</span>var fm="P2037";function qr({error:e,user_facing_error:r},t,n){return r.error_code?new z(gm(r,n),{code:r.error_code,clientVersion:t,meta:r.meta,batchRequestIdx:r.batch_request_idx}):<span class="branch-1 cbranch-no" title="branch not covered" >new j(e,{clientVersion:t,batchRequestIdx:r.batch_request_idx})}</span>function gm(e,r){let t=e.message;return(r==="postgresql"||<span class="branch-1 cbranch-no" title="branch not covered" >r==="postgres"||<span class="branch-2 cbranch-no" title="branch not covered" >r</span>==="mysql"</span>)&amp;&amp;e.error_code===fm&amp;&amp;(<span class="branch-4 cbranch-no" title="branch not covered" >t+=`</span>
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),t}var vt="&lt;unknown&gt;";function <span class="fstat-no" title="function not covered" >ja(e</span>){var r=<span class="cstat-no" title="statement not covered" >e.split(`</span>
`);<span class="cstat-no" title="statement not covered" >return r.reduce(<span class="fstat-no" title="function not covered" >function(t</span>,n){var i=<span class="cstat-no" title="statement not covered" >bm(n)||wm(n)||Pm(n)||Am(n)||Sm(n);<span class="cstat-no" title="statement not covered" >r</span>eturn i&amp;&amp;t.push(i),t}</span>,[])}</span>var hm=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|&lt;anonymous&gt;|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,ym=/\((\S*)(?::(\d+))(?::(\d+))\)/;function <span class="fstat-no" title="function not covered" >bm(e</span>){var r=<span class="cstat-no" title="statement not covered" >hm.exec(e);<span class="cstat-no" title="statement not covered" >i</span>f(!r)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >r[2]&amp;&amp;r[2].indexOf("native")===0,n</span>=<span class="cstat-no" title="statement not covered" >r[2]&amp;&amp;r[2].indexOf("eval")===0,i</span>=<span class="cstat-no" title="statement not covered" >ym.exec(r[2]);<span class="cstat-no" title="statement not covered" >r</span>eturn n&amp;&amp;i!=null&amp;&amp;(r[2]=i[1],r[3]=i[2],r[4]=i[3]),{file:t?null:r[2],methodName:r[1]||vt,arguments:t?[r[2]]:[],lineNumber:r[3]?+r[3]:null,column:r[4]?+r[4]:null}}</span>var Em=/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;function <span class="fstat-no" title="function not covered" >wm(e</span>){var r=<span class="cstat-no" title="statement not covered" >Em.exec(e);<span class="cstat-no" title="statement not covered" >r</span>eturn r?{file:r[2],methodName:r[1]||vt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}</span>var xm=/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,vm=/(\S+) line (\d+)(?: &gt; eval line \d+)* &gt; eval/i;function <span class="fstat-no" title="function not covered" >Pm(e</span>){var r=<span class="cstat-no" title="statement not covered" >xm.exec(e);<span class="cstat-no" title="statement not covered" >i</span>f(!r)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >r[3]&amp;&amp;r[3].indexOf(" &gt; eval")&gt;-1,n</span>=<span class="cstat-no" title="statement not covered" >vm.exec(r[3]);<span class="cstat-no" title="statement not covered" >r</span>eturn t&amp;&amp;n!=null&amp;&amp;(r[3]=n[1],r[4]=n[2],r[5]=null),{file:r[3],methodName:r[1]||vt,arguments:r[2]?r[2].split(","):[],lineNumber:r[4]?+r[4]:null,column:r[5]?+r[5]:null}}</span>var Tm=/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;function <span class="fstat-no" title="function not covered" >Sm(e</span>){var r=<span class="cstat-no" title="statement not covered" >Tm.exec(e);<span class="cstat-no" title="statement not covered" >r</span>eturn r?{file:r[3],methodName:r[1]||vt,arguments:[],lineNumber:+r[4],column:r[5]?+r[5]:null}:null}</span>var Rm=/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;function <span class="fstat-no" title="function not covered" >Am(e</span>){var r=<span class="cstat-no" title="statement not covered" >Rm.exec(e);<span class="cstat-no" title="statement not covered" >r</span>eturn r?{file:r[2],methodName:r[1]||vt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}</span>var so=class{<span class="fstat-no" title="function not covered" >getLocation(){<span class="cstat-no" title="statement not covered" ></span>return null}</span>},ao=class{_error;constructor(){this._error=new Error}<span class="fstat-no" title="function not covered" >getLocation(){</span>let r=<span class="cstat-no" title="statement not covered" >this._error.stack;<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et n=<span class="cstat-no" title="statement not covered" >ja(r).find(<span class="fstat-no" title="function not covered" >i=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(!i.file)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et o=<span class="cstat-no" title="statement not covered" >Fi(i.file);<span class="cstat-no" title="statement not covered" >r</span>eturn o!=="&lt;anonymous&gt;"&amp;&amp;!o.includes("@prisma")&amp;&amp;!o.includes("/packages/client/src/runtime/")&amp;&amp;!o.endsWith("/runtime/binary.js")&amp;&amp;!o.endsWith("/runtime/library.js")&amp;&amp;!o.endsWith("/runtime/edge.js")&amp;&amp;!o.endsWith("/runtime/edge-esm.js")&amp;&amp;!o.startsWith("internal/")&amp;&amp;!i.methodName.includes("new ")&amp;&amp;!i.methodName.includes("getCallSite")&amp;&amp;!i.methodName.includes("Proxy.")&amp;&amp;i.methodName.split(".").length&lt;4}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn!n||!n.file?null:{fileName:n.file,lineNumber:n.lineNumber,columnNumber:n.column}}</span>};function Ze(e){return e==="minimal"?<span class="branch-0 cbranch-no" title="branch not covered" >typeof $EnabledCallSite=="function"&amp;&amp;e!=="minimal"?new $EnabledCallSite:new so:n</span>ew ao}var Va={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function jr(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let r=Im(e);return Object.entries(r).reduce((n,[i,o])=&gt;(Va[i]!==void 0?n.select[i]={select:o}:<span class="branch-1 cbranch-no" title="branch not covered" >n[i]=o,n</span>),{select:{}})}function Im(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{return typeof e._count=="boolean"?<span class="branch-0 cbranch-no" title="branch not covered" >{...e,_count:{_all:e._count}}:e</span>}function Bn(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{return r=&gt;(typeof e._count=="boolean"&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >r._count=r._count._all)</span>,r)}function <span class="fstat-no" title="function not covered" >Ba(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >Bn(e);<span class="cstat-no" title="statement not covered" >r</span>eturn r({action:"aggregate",unpacker:t,argsMapper:jr})(e)}</span>function km(e={}){let{select:r,...t}=e;return typeof r=="object"?<span class="branch-0 cbranch-no" title="branch not covered" >jr({...t,_count:r}):j</span>r({...t,_count:{_all:!0}})}function Dm(e={}){return typeof e.select=="object"?<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >B</span>n(e)(r)._count:</span></span>r=&gt;Bn(e)(r)._count._all}function Ua(e,r){return r({action:"count",unpacker:Dm(e),argsMapper:km})(e)}function <span class="fstat-no" title="function not covered" >Om(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let r=<span class="cstat-no" title="statement not covered" >jr(e);<span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(r.by))<span class="cstat-no" title="statement not covered" >for(let t of r.by)<span class="cstat-no" title="statement not covered" >typeof t=="string"&amp;&amp;(r.select[t]=!0);else <span class="cstat-no" title="statement not covered" >t</span></span>ypeof r.by=="string"&amp;&amp;(r.select[r.by]=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >_m(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >r=&gt;(<span class="cstat-no" title="statement not covered" >t</span>ypeof e?._count=="boolean"&amp;&amp;r.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>._count=t._count._all}),r</span>)}</span></span>function <span class="fstat-no" title="function not covered" >Ga(e</span>,r){<span class="cstat-no" title="statement not covered" >return r({action:"groupBy",unpacker:_m(e),argsMapper:Om})(e)}</span>function Qa(e,r,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(r==="aggregate")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >B</span>a(n,t);<span class="missing-if-branch" title="else path not taken" >E</span>i</span></span>f(r==="count")return n=&gt;Ua(n,t);<span class="cstat-no" title="statement not covered" >if(r==="groupBy")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >G</span>a(n,t)}</span></span></span>function <span class="fstat-no" title="function not covered" >Wa(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >r.fields.filter(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >!</span>i.relationName)</span>,n</span>=<span class="cstat-no" title="statement not covered" >Zs(t,"name");<span class="cstat-no" title="statement not covered" >r</span>eturn new Proxy({},{<span class="fstat-no" title="function not covered" >get(i</span>,o){<span class="cstat-no" title="statement not covered" >if(o in i||typeof o=="symbol")<span class="cstat-no" title="statement not covered" >return i[o];l</span></span>et s=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return new mt(e,o,s.type,s.isList,s.kind==="enum")}</span></span>,...Vn(Object.keys(n))})}</span>var Ja=e=&gt;Array.isArray(e)?e:<span class="branch-1 cbranch-no" title="branch not covered" >e.split("."),l</span>o=(e,r)=&gt;Ja(r).reduce(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;t[n],</span>e),Ha=<span class="fstat-no" title="function not covered" >(e</span>,r,t)=&gt;<span class="cstat-no" title="statement not covered" >Ja(r).reduceRight(<span class="fstat-no" title="function not covered" >(n</span>,i,o,s)=&gt;<span class="cstat-no" title="statement not covered" >Object.assign({},lo(e,s.slice(0,o)),{[i]:n}),t</span>);f</span>unction Nm(e,r){return e===void 0||<span class="branch-1 cbranch-no" title="branch not covered" >r===void 0?[</span>]:<span class="branch-1 cbranch-no" title="branch not covered" >[...r,"select",e]}f</span>unction Lm(e,r,t){return r===void 0?e??<span class="branch-1 cbranch-no" title="branch not covered" >{}:<span class="branch-1 cbranch-no" title="branch not covered" >H</span>a(r,t,e||!0)}</span>function uo(e,r,t,n,i,o){let a=e._runtimeDataModel.models[r].fields.reduce((l,u)=&gt;({...l,[u.name]:u}),{});return l=&gt;{let u=Ze(e._errorFormat),c=Nm(n,i),p=Lm(l,o,c),d=t({dataPath:c,callsite:u})(p),f=Fm(e,r);return new Proxy(d,{get(h,g){<span class="missing-if-branch" title="else path not taken" >E</span>if(!f.includes(g))return h[g];let P=<span class="cstat-no" title="statement not covered" >[a[g].type,t,g],R</span>=<span class="cstat-no" title="statement not covered" >[c,p];<span class="cstat-no" title="statement not covered" >r</span>eturn uo(e,...P,...R)}</span>,...Vn([...f,...Object.getOwnPropertyNames(d)])})}}function Fm(e,r){return e._runtimeDataModel.models[r].fields.filter(t=&gt;t.kind==="object").map(t=&gt;t.name)}var Mm=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],$m=["aggregate","count","groupBy"];function co(e,r){let t=e._extensions.getAllModelExtensions(r)??{},n=[qm(e,r),Vm(e,r),xt(t),re("name",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >r</span>),r</span>e("$name",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >r</span>),r</span>e("$parent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>._appliedParent)</span>];return he({},n)}function qm(e,r){let t=Se(r),n=Object.keys(Ar).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=&gt;l=&gt;{let u=Ze(e._errorFormat);return e._createPrismaPromise(c=&gt;{let p={args:l,dataPath:[],action:o,model:r,clientMethod:`${t}.${i}`,jsModelName:t,transaction:c,callsite:u};return e._request({...p,...a})},{action:o,args:l,model:r})};return Mm.includes(o)?uo(e,r,s):jm(i)?Qa(e,i,s):s({})}}}function jm(e){return $m.includes(e)}function Vm(e,r){return lr(re("fields",<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >e._runtimeDataModel.models[r];<span class="cstat-no" title="statement not covered" ></span>return Wa(r,t)}</span>))}function Ka(e){return e.replace(/^./,r=&gt;r.toUpperCase())}var po=Symbol();function Pt(e){let r=[Bm(e),Um(e),re(po,()=&gt;e),re("$parent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>._appliedParent)</span>],t=e._extensions.getAllClientExtensions();return t&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r.push(xt(t)),h</span>e(e,r)}function Bm(e){let r=Object.getPrototypeOf(e._originalClient),t=[...new Set(Object.getOwnPropertyNames(r))];return{getKeys(){return t},getPropertyValue(n){return e[n]}}}function Um(e){let r=Object.keys(e._runtimeDataModel.models),t=r.map(Se),n=[...new Set(r.concat(t))];return lr({getKeys(){return n},getPropertyValue(i){let o=Ka(i);<span class="missing-if-branch" title="else path not taken" >E</span>if(e._runtimeDataModel.models[o]!==void 0)return co(e,o);<span class="cstat-no" title="statement not covered" >if(e._runtimeDataModel.models[i]!==void 0)<span class="cstat-no" title="statement not covered" >return co(e,i)}</span></span>,getPropertyDescriptor(i){<span class="missing-if-branch" title="if path not taken" >I</span>if(!t.includes(i))<span class="cstat-no" title="statement not covered" >return{enumerable:!1}}</span>})}function Ya(e){return e[po]?e[po]:<span class="branch-1 cbranch-no" title="branch not covered" >e}</span>function <span class="fstat-no" title="function not covered" >za(e</span>){<span class="cstat-no" title="statement not covered" >if(typeof e=="function")<span class="cstat-no" title="statement not covered" >return e(this);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.client?.__AccelerateEngine){let t=<span class="cstat-no" title="statement not covered" >e.client.__AccelerateEngine;<span class="cstat-no" title="statement not covered" ></span>this._originalClient._engine=new t(this._originalClient._accelerateEngineConfig)}</span>l</span>et r=<span class="cstat-no" title="statement not covered" >Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});<span class="cstat-no" title="statement not covered" >r</span>eturn Pt(r)}</span>function <span class="fstat-no" title="function not covered" >Za({</span>result:e,modelName:r,select:t,omit:n,extensions:i}){let o=<span class="cstat-no" title="statement not covered" >i.getAllComputedFields(r);<span class="cstat-no" title="statement not covered" >i</span>f(!o)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let l of Object.values(o)){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >if(n[l.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et u=<span class="cstat-no" title="statement not covered" >l.needs.filter(<span class="fstat-no" title="function not covered" >c=&gt;<span class="cstat-no" title="statement not covered" >n</span>[c])</span>;<span class="cstat-no" title="statement not covered" >u</span>.length&gt;0&amp;&amp;a.push(Mr(u))}</span>else <span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >if(!t[l.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et u=<span class="cstat-no" title="statement not covered" >l.needs.filter(<span class="fstat-no" title="function not covered" >c=&gt;<span class="cstat-no" title="statement not covered" >!</span>t[c])</span>;<span class="cstat-no" title="statement not covered" >u</span>.length&gt;0&amp;&amp;a.push(Mr(u))}<span class="cstat-no" title="statement not covered" ></span>G</span></span>m(e,l.needs)&amp;&amp;s.push(Qm(l,he(e,s)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.length&gt;0||a.length&gt;0?he(e,[...s,...a]):e}</span>function <span class="fstat-no" title="function not covered" >Gm(e</span>,r){<span class="cstat-no" title="statement not covered" >return r.every(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >V</span>i(e,t))}</span></span>function <span class="fstat-no" title="function not covered" >Qm(e</span>,r){<span class="cstat-no" title="statement not covered" >return lr(re(e.name,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>.compute(r)))}</span></span>function <span class="fstat-no" title="function not covered" >Un({</span>visitor:e,result:r,args:t,runtimeDataModel:n,modelName:i}){<span class="cstat-no" title="statement not covered" >if(Array.isArray(r)){<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;r.length;s++)<span class="cstat-no" title="statement not covered" >r[s]=Un({result:r[s],args:t,modelName:i,runtimeDataModel:n,visitor:e});<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >e(r,i,t)??r;<span class="cstat-no" title="statement not covered" >r</span>eturn t.include&amp;&amp;Xa({includeOrSelect:t.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),t.select&amp;&amp;Xa({includeOrSelect:t.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}</span>function <span class="fstat-no" title="function not covered" >Xa({</span>includeOrSelect:e,result:r,parentModelName:t,runtimeDataModel:n,visitor:i}){<span class="cstat-no" title="statement not covered" >for(let[o,s]of Object.entries(e)){<span class="cstat-no" title="statement not covered" >if(!s||r[o]==null||Re(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et l=<span class="cstat-no" title="statement not covered" >n.models[t].fields.find(<span class="fstat-no" title="function not covered" >c=&gt;<span class="cstat-no" title="statement not covered" >c</span>.name===o);<span class="cstat-no" title="statement not covered" >i</span></span>f(!l||l.kind!=="object"||!l.relationName)<span class="cstat-no" title="statement not covered" >continue;l</span></span>et u=<span class="cstat-no" title="statement not covered" >typeof s=="object"?s:{};<span class="cstat-no" title="statement not covered" >r</span>[o]=Un({visitor:i,result:r[o],args:u,modelName:l.type,runtimeDataModel:n})}</span>}</span>function el({result:e,modelName:r,args:t,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||<span class="branch-1 cbranch-no" title="branch not covered" >e==null||<span class="branch-2 cbranch-no" title="branch not covered" >t</span>ypeof e!="object"||<span class="branch-3 cbranch-no" title="branch not covered" >!</span>i.models[r]?</span>e:<span class="branch-1 cbranch-no" title="branch not covered" >Un({result:e,args:t??{},modelName:r,runtimeDataModel:i,visitor:<span class="fstat-no" title="function not covered" >(a</span>,l,u)=&gt;{let c=<span class="cstat-no" title="statement not covered" >Se(l);<span class="cstat-no" title="statement not covered" >r</span>eturn Za({result:a,modelName:c,select:u.select,omit:u.select?void 0:{...o?.[c],...u.omit},extensions:n})}</span>})}</span>var Wm=["$connect","$disconnect","$on","$transaction","$use","$extends"],rl=Wm;function <span class="fstat-no" title="function not covered" >tl(e</span>){<span class="cstat-no" title="statement not covered" >if(e instanceof oe)<span class="cstat-no" title="statement not covered" >return Jm(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(qn(e))<span class="cstat-no" title="statement not covered" >return Hm(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e)){let t=<span class="cstat-no" title="statement not covered" >[e[0]];<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >1;n</span>&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >t[n]=Tt(e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>l</span>et r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let t in e)<span class="cstat-no" title="statement not covered" >r[t]=Tt(e[t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Jm(e</span>){<span class="cstat-no" title="statement not covered" >return new oe(e.strings,e.values)}</span>function <span class="fstat-no" title="function not covered" >Hm(e</span>){<span class="cstat-no" title="statement not covered" >return new wt(e.sql,e.values)}</span>function <span class="fstat-no" title="function not covered" >Tt(e</span>){<span class="cstat-no" title="statement not covered" >if(typeof e!="object"||e==null||e instanceof Me||_r(e))<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(Rr(e))<span class="cstat-no" title="statement not covered" >return new ve(e.toFixed());<span class="cstat-no" title="statement not covered" >i</span></span>f(Sr(e))<span class="cstat-no" title="statement not covered" >return new Date(+e);<span class="cstat-no" title="statement not covered" >i</span></span>f(ArrayBuffer.isView(e))<span class="cstat-no" title="statement not covered" >return e.slice(0);<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e)){let r=<span class="cstat-no" title="statement not covered" >e.length,</span>t;<span class="cstat-no" title="statement not covered" >for(t=Array(r);r--;)<span class="cstat-no" title="statement not covered" >t[r]=Tt(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof e=="object"){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let t in e)<span class="cstat-no" title="statement not covered" >t==="__proto__"?Object.defineProperty(r,t,{value:Tt(e[t]),configurable:!0,enumerable:!0,writable:!0}):r[t]=Tt(e[t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>N</span>e(e,"Unknown value")}</span>function <span class="fstat-no" title="function not covered" >il(e</span>,r,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return e._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >r.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return"transaction"in r&amp;&amp;i!==void 0&amp;&amp;(r.transaction?.kind==="batch"&amp;&amp;r.transaction.lock.then(),r.transaction=i),n===t.length?e._executeRequest(r):t[n]({model:r.model,operation:r.model?r.action:r.clientMethod,args:tl(r.args??{}),__internalParams:r,query:<span class="fstat-no" title="function not covered" >(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >r)</span>=&gt;{let l=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=ll(o,l),a.args=s,il(e,a,t,n+1)}</span>})}</span>)}</span>function ol(e,r){let{jsModelName:t,action:n,clientMethod:i}=r,o=t?n:<span class="branch-1 cbranch-no" title="branch not covered" >i;<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(e._extensions.isEmpty())return e._executeRequest(r);let s=<span class="cstat-no" title="statement not covered" >e._extensions.getAllQueryCallbacks(t??"$none",o);<span class="cstat-no" title="statement not covered" >r</span>eturn il(e,r,s)}</span>function sl(e){return r=&gt;{let t={requests:r},n=r[0].extensions.getAllBatchQueryCallbacks();return n.length?<span class="branch-0 cbranch-no" title="branch not covered" >al(t,n,0,e):e</span>(t)}}function <span class="fstat-no" title="function not covered" >al(e</span>,r,t,n){<span class="cstat-no" title="statement not covered" >if(t===r.length)<span class="cstat-no" title="statement not covered" >return n(e);l</span></span>et i=<span class="cstat-no" title="statement not covered" >e.customDataProxyFetch,</span>o=<span class="cstat-no" title="statement not covered" >e.requests[0].transaction;<span class="cstat-no" title="statement not covered" ></span>return r[t]({args:{queries:e.requests.map(<span class="fstat-no" title="function not covered" >s=&gt;(<span class="cstat-no" title="statement not covered" >{</span>model:s.modelName,operation:s.action,args:s.args})),t</span>ransaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,<span class="fstat-no" title="function not covered" >query(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>{let l=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=ll(i,l),al(a,r,t+1,n)}</span>})}</span>var nl=<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>;f</span>unction <span class="fstat-no" title="function not covered" >ll(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >nl,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >nl)</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >e</span>(r(t))}</span></span>var ul=N("prisma:client"),cl={Vercel:"vercel","Netlify CI":"netlify"};function pl({postinstall:e,ciName:r,clientVersion:t}){<span class="missing-if-branch" title="if path not taken" >I</span>if(ul("checkPlatformCaching:postinstall",e),ul("checkPlatformCaching:ciName",r),e===!0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >r</span> in cl){</span>let n=<span class="cstat-no" title="statement not covered" >`Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.</span>
&nbsp;
Learn how: https://pris.ly/d/${cl[r]}-build`;<span class="cstat-no" title="statement not covered" >throw console.error(n),new T(n,t)}</span>}function dl(e,r){return e?e.datasources?e.datasources:<span class="branch-1 cbranch-no" title="branch not covered" >e.datasourceUrl?{[r[0]]:{url:e.datasourceUrl}}:{}:<span class="branch-1 cbranch-no" title="branch not covered" >{</span>}}</span>var Km=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>lobalThis.process?.release?.name==="node",Y</span>m=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>!globalThis.Bun||!!globalThis.process?.versions?.bun,z</span>m=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>!globalThis.Deno,</span>Zm=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof globalThis.Netlify=="object",X</span>m=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof globalThis.EdgeRuntime=="object",e</span>f=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>lobalThis.navigator?.userAgent==="Cloudflare-Workers";f</span>unction <span class="fstat-no" title="function not covered" >rf(){<span class="cstat-no" title="statement not covered" >r</span>eturn[[Zm,"netlify"],[Xm,"edge-light"],[ef,"workerd"],[zm,"deno"],[Ym,"bun"],[Km,"node"]].flatMap(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>[0]()?[t[1]]:[])</span>.at(0)??""}</span>var tf={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function <span class="fstat-no" title="function not covered" >Gn(){l</span>et e=<span class="cstat-no" title="statement not covered" >rf();<span class="cstat-no" title="statement not covered" >r</span>eturn{id:e,prettyName:tf[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}</span>var yl=C(require("node:fs")),St=C(require("node:path"));function <span class="fstat-no" title="function not covered" >Qn(e</span>){let{runtimeBinaryTarget:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn`Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:</span>
&nbsp;
${nf(e)}`}function <span class="fstat-no" title="function not covered" >nf(e</span>){let{generator:r,generatorBinaryTargets:t,runtimeBinaryTarget:n}=<span class="cstat-no" title="statement not covered" >e,i</span>=<span class="cstat-no" title="statement not covered" >{fromEnvVar:null,value:n},o</span>=<span class="cstat-no" title="statement not covered" >[...t,i];<span class="cstat-no" title="statement not covered" >r</span>eturn _i({...r,binaryTargets:o})}</span>function <span class="fstat-no" title="function not covered" >Xe(e</span>){let{runtimeBinaryTarget:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn`Prisma Client could not locate the Query Engine for runtime "${r}".`}f</span>unction <span class="fstat-no" title="function not covered" >er(e</span>){let{searchedLocations:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn`The following locations have been searched:</span>
${[...new Set(r)].map(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >`</span>  ${i}`)</span>.join(`
`)}`}function <span class="fstat-no" title="function not covered" >ml(e</span>){let{runtimeBinaryTarget:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn`${Xe(e)}</span>
&nbsp;
This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".
${Qn(e)}
&nbsp;
${er(e)}`}function <span class="fstat-no" title="function not covered" >Wn(e</span>){<span class="cstat-no" title="statement not covered" >return`We would appreciate if you could take the time to share some information with us.</span>
Please help us by answering a few questions: https://pris.ly/${e}`}function <span class="fstat-no" title="function not covered" >Jn(e</span>){let{errorStack:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn r?.match(/\/\.next|\/next@|\/next\//)?`</span>
&nbsp;
We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.`:""}function <span class="fstat-no" title="function not covered" >fl(e</span>){let{queryEngineName:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn`${Xe(e)}${Jn(e)}</span>
&nbsp;
This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.
Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".
&nbsp;
${Wn("engine-not-found-bundler-investigation")}
&nbsp;
${er(e)}`}function <span class="fstat-no" title="function not covered" >gl(e</span>){let{runtimeBinaryTarget:r,generatorBinaryTargets:t}=<span class="cstat-no" title="statement not covered" >e,n</span>=<span class="cstat-no" title="statement not covered" >t.find(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >i</span>.native)</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn`${Xe(e)}</span>
&nbsp;
This happened because Prisma Client was generated for "${n?.value??"unknown"}", but the actual deployment required "${r}".
${Qn(e)}
&nbsp;
${er(e)}`}function <span class="fstat-no" title="function not covered" >hl(e</span>){let{queryEngineName:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn`${Xe(e)}${Jn(e)}</span>
&nbsp;
This is likely caused by tooling that has not copied "${r}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".
&nbsp;
${Wn("engine-not-found-tooling-investigation")}
&nbsp;
${er(e)}`}var of=N("prisma:client:engines:resolveEnginePath"),sf=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>ew RegExp("runtime[\\\\/]library\\.m?js$");a</span>sync function bl(e,r){let t={binary:process.env.PRISMA_QUERY_ENGINE_BINARY,library:process.env.PRISMA_QUERY_ENGINE_LIBRARY}[e]??r.prismaPath;<span class="missing-if-branch" title="if path not taken" >I</span>if(t!==void 0)<span class="cstat-no" title="statement not covered" >return t;l</span>et{enginePath:n,searchedLocations:i}=await af(e,r);<span class="missing-if-branch" title="else path not taken" >E</span>if(of("enginePath",n),n!==void 0&amp;&amp;e==="binary"&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >Ai(n),n</span>!==void 0)return r.prismaPath=n;let o=<span class="cstat-no" title="statement not covered" >await ir(),s</span>=<span class="cstat-no" title="statement not covered" >r.generator?.binaryTargets??[],</span>a=<span class="cstat-no" title="statement not covered" >s.some(<span class="fstat-no" title="function not covered" >d=&gt;<span class="cstat-no" title="statement not covered" >d</span>.native)</span>,l</span>=<span class="cstat-no" title="statement not covered" >!s.some(<span class="fstat-no" title="function not covered" >d=&gt;<span class="cstat-no" title="statement not covered" >d</span>.value===o),u</span></span>=<span class="cstat-no" title="statement not covered" >__filename.match(sf())===null,c</span>=<span class="cstat-no" title="statement not covered" >{searchedLocations:i,generatorBinaryTargets:s,generator:r.generator,runtimeBinaryTarget:o,queryEngineName:El(e,o),expectedLocation:St.default.relative(process.cwd(),r.dirname),errorStack:new Error().stack},p</span>;<span class="cstat-no" title="statement not covered" >throw a&amp;&amp;l?p=gl(c):l?p=ml(c):u?p=fl(c):p=hl(c),new T(p,r.clientVersion)}</span>async function af(e,r){let t=await ir(),n=[],i=[r.dirname,St.default.resolve(__dirname,".."),r.generator?.output?.value??<span class="branch-1 cbranch-no" title="branch not covered" >__dirname,S</span>t.default.resolve(__dirname,"../../../.prisma/client"),"/tmp/prisma-engines",r.cwd];__filename.includes("resolveEnginePath")&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >i.push(gs());f</span>or(let o of i){let s=El(e,t),a=St.default.join(o,s);<span class="missing-if-branch" title="else path not taken" >E</span>if(n.push(o),yl.default.existsSync(a))return{enginePath:a,searchedLocations:n}}<span class="cstat-no" title="statement not covered" >return{enginePath:void 0,searchedLocations:n}}</span>function El(e,r){return e==="library"?Gt(r,"fs"):<span class="branch-1 cbranch-no" title="branch not covered" >`query-engine-${r}${r==="windows"?".exe":""}`}</span>var mo=C(Li());function <span class="fstat-no" title="function not covered" >wl(e</span>){<span class="cstat-no" title="statement not covered" >return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >`</span>${r[0]}5`)</span>:""}</span>function <span class="fstat-no" title="function not covered" >xl(e</span>){<span class="cstat-no" title="statement not covered" >return e.split(`</span>
`).map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(/\+\d+\s*ms$/,"")).j</span>oin(`
`)}var vl=C(Fs());function <span class="fstat-no" title="function not covered" >Pl({</span>title:e,user:r=<span class="branch-0 cbranch-no" title="branch not covered" >"prisma",</span>repo:t=<span class="branch-0 cbranch-no" title="branch not covered" >"prisma",</span>template:n=<span class="branch-0 cbranch-no" title="branch not covered" >"bug_report.yml",</span>body:i}){<span class="cstat-no" title="statement not covered" >return(0,vl.default)({user:r,repo:t,template:n,title:e,body:i})}</span>function <span class="fstat-no" title="function not covered" >Tl({</span>version:e,binaryTarget:r,title:t,description:n,engineVersion:i,database:o,query:s}){let a=<span class="cstat-no" title="statement not covered" >Go(6e3-(s?.length??0)),l</span>=<span class="cstat-no" title="statement not covered" >xl((0,mo.default)(a)),u</span>=<span class="cstat-no" title="statement not covered" >n?`# Description</span>
\`\`\`
${n}
\`\`\``:"",c=<span class="cstat-no" title="statement not covered" >(0,mo.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:</span>
## Versions
&nbsp;
| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${r?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|
&nbsp;
${u}
&nbsp;
## Logs
\`\`\`
${l}
\`\`\`
&nbsp;
## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`
&nbsp;
## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`
&nbsp;
## Prisma Engine Query
\`\`\`
${s?wl(s):""}
\`\`\`
`),p=<span class="cstat-no" title="statement not covered" >Pl({title:t,body:c});<span class="cstat-no" title="statement not covered" >r</span>eturn`${t}</span>
&nbsp;
This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.
&nbsp;
${Y(p)}
&nbsp;
If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`}var Sl="6.13.0";function Vr({inlineDatasources:e,overrideDatasources:r,env:t,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=r[o]?.url;<span class="missing-if-branch" title="if path not taken" >I</span>if(o===void 0?<span class="branch-0 cbranch-no" title="branch not covered" >i=void 0:a</span>?i=a:<span class="branch-1 cbranch-no" title="branch not covered" >s?.value?i=s.value:s?.fromEnvVar&amp;&amp;(i=t[s.fromEnvVar]),s</span>?.fromEnvVar!==void 0&amp;&amp;i===void 0)<span class="cstat-no" title="statement not covered" >throw new T(`error: Environment variable not found: ${s.fromEnvVar}.`,n);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i===void 0)<span class="cstat-no" title="statement not covered" >throw new T("error: Missing URL environment variable, value, or override.",n);r</span>eturn i}var Hn=class extends Error{clientVersion;cause;<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >super(r),this.clientVersion=t.clientVersion,this.cause=t.cause}<span class="fstat-no" title="function not covered" >g</span>et[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return this.name}}</span>;var se=class extends Hn{isRetryable;<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >super(r,t),this.isRetryable=t.isRetryable??!0}</span>};function <span class="fstat-no" title="function not covered" >A(e</span>,r){<span class="cstat-no" title="statement not covered" >return{...e,isRetryable:r}}</span>var ur=class extends se{name="InvalidDatasourceError";code="P6001";<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >super(r,A(t,!1))}};x(ur,"InvalidDatasourceError");function <span class="fstat-no" title="function not covered" >Rl(e</span>){let r=<span class="cstat-no" title="statement not covered" >{clientVersion:e.clientVersion},t</span>=<span class="cstat-no" title="statement not covered" >Object.keys(e.inlineDatasources)[0],</span>n=<span class="cstat-no" title="statement not covered" >Vr({inlineDatasources:e.inlineDatasources,overrideDatasources:e.overrideDatasources,clientVersion:e.clientVersion,env:{...e.env,...typeof process&lt;"u"?process.env:{}}}),i</span>;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=new URL(n)}</span>catch{<span class="cstat-no" title="statement not covered" >throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``,r)}</span>l</span>et{protocol:o,searchParams:s}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" >i</span>f(o!=="prisma:"&amp;&amp;o!==sn)<span class="cstat-no" title="statement not covered" >throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``,r);l</span></span>et a=<span class="cstat-no" title="statement not covered" >s.get("api_key");<span class="cstat-no" title="statement not covered" >i</span>f(a===null||a.length&lt;1)<span class="cstat-no" title="statement not covered" >throw new ur(`Error validating datasource \`${t}\`: the URL must contain a valid API key`,r);l</span></span>et l=<span class="cstat-no" title="statement not covered" >ki(i)?"http:":"https:",u</span>=<span class="cstat-no" title="statement not covered" >new URL(i.href.replace(o,l));<span class="cstat-no" title="statement not covered" >r</span>eturn{apiKey:a,url:u}}</span>var Al=C(on()),Kn=class{apiKey;tracingHelper;logLevel;logQueries;engineHash;<span class="fstat-no" title="function not covered" >constructor({</span>apiKey:r,tracingHelper:t,logLevel:n,logQueries:i,engineHash:o}){<span class="cstat-no" title="statement not covered" >this.apiKey=r,this.tracingHelper=t,this.logLevel=n,this.logQueries=i,this.engineHash=o}<span class="fstat-no" title="function not covered" ></span>build({</span>traceparent:r,transactionId:t}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let n=<span class="cstat-no" title="statement not covered" >{Accept:"application/json",Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json","Prisma-Engine-Hash":this.engineHash,"Prisma-Engine-Version":Al.enginesVersion};<span class="cstat-no" title="statement not covered" >t</span>his.tracingHelper.isEnabled()&amp;&amp;(n.traceparent=r??this.tracingHelper.getTraceParent()),t&amp;&amp;(n["X-Transaction-Id"]=t);l</span>et i=<span class="cstat-no" title="statement not covered" >this.#e();<span class="cstat-no" title="statement not covered" >r</span>eturn i.length&gt;0&amp;&amp;(n["X-Capture-Telemetry"]=i.join(", ")),n}</span>#e(){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.tracingHelper.isEnabled()&amp;&amp;r.push("tracing"),this.logLevel&amp;&amp;r.push(this.logLevel),this.logQueries&amp;&amp;r.push("query"),r}</span>};function <span class="fstat-no" title="function not covered" >uf(e</span>){<span class="cstat-no" title="statement not covered" >return e[0]*1e3+e[1]/1e6}</span>function <span class="fstat-no" title="function not covered" >fo(e</span>){<span class="cstat-no" title="statement not covered" >return new Date(uf(e))}</span>var Br=class extends se{name="ForcedRetryError";code="P5001";<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >super("This request must be retried",A(r,!0))}};x(Br,"ForcedRetryError");var cr=class extends se{name="NotImplementedYetError";code="P5004";<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >super(r,A(t,!1))}};x(cr,"NotImplementedYetError");var $=class extends se{response;<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >super(r,t),this.response=t.response;l</span>et n=<span class="cstat-no" title="statement not covered" >this.response.headers.get("prisma-request-id");<span class="cstat-no" title="statement not covered" >i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >`(The request id was: ${n})`;<span class="cstat-no" title="statement not covered" ></span>this.message=this.message+" "+i}</span>}</span>};var pr=class extends ${name="SchemaMissingError";code="P5005";<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >super("Schema needs to be uploaded",A(r,!0))}};x(pr,"SchemaMissingError");var go="This request could not be understood by the server",Rt=class extends ${name="BadRequestError";code="P5000";<span class="fstat-no" title="function not covered" >constructor(r</span>,t,n){<span class="cstat-no" title="statement not covered" >super(t||go,A(r,!1)),n&amp;&amp;(this.code=n)}</span>};x(Rt,"BadRequestError");var At=class extends ${name="HealthcheckTimeoutError";code="P5013";logs;<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >super("Engine not started: healthcheck timeout",A(r,!0)),this.logs=t}</span>};x(At,"HealthcheckTimeoutError");var Ct=class extends ${name="EngineStartupError";code="P5014";logs;<span class="fstat-no" title="function not covered" >constructor(r</span>,t,n){<span class="cstat-no" title="statement not covered" >super(t,A(r,!0)),this.logs=n}</span>};x(Ct,"EngineStartupError");var It=class extends ${name="EngineVersionNotSupportedError";code="P5012";<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >super("Engine version is not supported",A(r,!1))}};x(It,"EngineVersionNotSupportedError");var ho="Request timed out",kt=class extends ${name="GatewayTimeoutError";code="P5009";<span class="fstat-no" title="function not covered" >constructor(r</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >ho)</span>{<span class="cstat-no" title="statement not covered" >super(t,A(r,!1))}};x(kt,"GatewayTimeoutError");var cf="Interactive transaction error",Dt=class extends ${name="InteractiveTransactionError";code="P5015";<span class="fstat-no" title="function not covered" >constructor(r</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >cf)</span>{<span class="cstat-no" title="statement not covered" >super(t,A(r,!1))}};x(Dt,"InteractiveTransactionError");var pf="Request parameters are invalid",Ot=class extends ${name="InvalidRequestError";code="P5011";<span class="fstat-no" title="function not covered" >constructor(r</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >pf)</span>{<span class="cstat-no" title="statement not covered" >super(t,A(r,!1))}};x(Ot,"InvalidRequestError");var yo="Requested resource does not exist",_t=class extends ${name="NotFoundError";code="P5003";<span class="fstat-no" title="function not covered" >constructor(r</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >yo)</span>{<span class="cstat-no" title="statement not covered" >super(t,A(r,!1))}};x(_t,"NotFoundError");var bo="Unknown server error",Ur=class extends ${name="ServerError";code="P5006";logs;<span class="fstat-no" title="function not covered" >constructor(r</span>,t,n){<span class="cstat-no" title="statement not covered" >super(t||bo,A(r,!0)),this.logs=n}</span>};x(Ur,"ServerError");var Eo="Unauthorized, check your connection string",Nt=class extends ${name="UnauthorizedError";code="P5007";<span class="fstat-no" title="function not covered" >constructor(r</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >Eo)</span>{<span class="cstat-no" title="statement not covered" >super(t,A(r,!1))}};x(Nt,"UnauthorizedError");var wo="Usage exceeded, retry again later",Lt=class extends ${name="UsageExceededError";code="P5008";<span class="fstat-no" title="function not covered" >constructor(r</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >wo)</span>{<span class="cstat-no" title="statement not covered" >super(t,A(r,!0))}};x(Lt,"UsageExceededError");async function <span class="fstat-no" title="function not covered" >df(e</span>){let r;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=await e.text()}</span>catch{<span class="cstat-no" title="statement not covered" >return{type:"EmptyError"}}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{let t=<span class="cstat-no" title="statement not covered" >JSON.parse(r);<span class="cstat-no" title="statement not covered" >i</span>f(typeof t=="string")<span class="cstat-no" title="statement not covered" >switch(t){case"InternalDataProxyError":<span class="cstat-no" title="statement not covered" >return{type:"DataProxyError",body:t};d</span>efault:<span class="cstat-no" title="statement not covered" >return{type:"UnknownTextError",body:t}}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(typeof t=="object"&amp;&amp;t!==null){<span class="cstat-no" title="statement not covered" >if("is_panic"in t&amp;&amp;"message"in t&amp;&amp;"error_code"in t)<span class="cstat-no" title="statement not covered" >return{type:"QueryEngineError",body:t};<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineNotStarted"in t||"InteractiveTransactionMisrouted"in t||"InvalidRequestError"in t){let n=<span class="cstat-no" title="statement not covered" >Object.values(t)[0].reason;<span class="cstat-no" title="statement not covered" ></span>return typeof n=="string"&amp;&amp;!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:t}:{type:"DataProxyError",body:t}}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{type:"UnknownJsonError",body:t}}</span>catch{<span class="cstat-no" title="statement not covered" >return r===""?{type:"EmptyError"}:{type:"UnknownTextError",body:r}}</span>}</span>async function <span class="fstat-no" title="function not covered" >Ft(e</span>,r){<span class="cstat-no" title="statement not covered" >if(e.ok)<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >{clientVersion:r,response:e},n</span>=<span class="cstat-no" title="statement not covered" >await df(e);<span class="cstat-no" title="statement not covered" >i</span>f(n.type==="QueryEngineError")<span class="cstat-no" title="statement not covered" >throw new z(n.body.message,{code:n.body.error_code,clientVersion:r});<span class="cstat-no" title="statement not covered" >i</span></span>f(n.type==="DataProxyError"){<span class="cstat-no" title="statement not covered" >if(n.body==="InternalDataProxyError")<span class="cstat-no" title="statement not covered" >throw new Ur(t,"Internal Data Proxy error");<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineNotStarted"in n.body){<span class="cstat-no" title="statement not covered" >if(n.body.EngineNotStarted.reason==="SchemaMissing")<span class="cstat-no" title="statement not covered" >return new pr(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")<span class="cstat-no" title="statement not covered" >throw new It(t);<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.EngineStartupError;<span class="cstat-no" title="statement not covered" ></span>throw new Ct(t,i,o)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.KnownEngineStartupError;<span class="cstat-no" title="statement not covered" ></span>throw new T(i,r,o)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.HealthcheckTimeout;<span class="cstat-no" title="statement not covered" ></span>throw new At(t,i)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f("InteractiveTransactionMisrouted"in n.body){let i=<span class="cstat-no" title="statement not covered" >{IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};<span class="cstat-no" title="statement not covered" >t</span>hrow new Dt(t,i[n.body.InteractiveTransactionMisrouted.reason])}<span class="cstat-no" title="statement not covered" ></span>i</span>f("InvalidRequestError"in n.body)<span class="cstat-no" title="statement not covered" >throw new Ot(t,n.body.InvalidRequestError.reason)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(e.status===401||e.status===403)<span class="cstat-no" title="statement not covered" >throw new Nt(t,Gr(Eo,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===404)<span class="cstat-no" title="statement not covered" >return new _t(t,Gr(yo,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===429)<span class="cstat-no" title="statement not covered" >throw new Lt(t,Gr(wo,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===504)<span class="cstat-no" title="statement not covered" >throw new kt(t,Gr(ho,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status&gt;=500)<span class="cstat-no" title="statement not covered" >throw new Ur(t,Gr(bo,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status&gt;=400)<span class="cstat-no" title="statement not covered" >throw new Rt(t,Gr(go,n))}</span></span>function <span class="fstat-no" title="function not covered" >Gr(e</span>,r){<span class="cstat-no" title="statement not covered" >return r.type==="EmptyError"?e:`${e}: ${JSON.stringify(r)}`}f</span>unction <span class="fstat-no" title="function not covered" >Cl(e</span>){let r=<span class="cstat-no" title="statement not covered" >Math.pow(2,e)*50,t</span>=<span class="cstat-no" title="statement not covered" >Math.ceil(Math.random()*r)-Math.ceil(r/2),n</span>=<span class="cstat-no" title="statement not covered" >r+t;<span class="cstat-no" title="statement not covered" >r</span>eturn new Promise(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >s</span>etTimeout(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>(n),n</span>))}</span></span>var $e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function <span class="fstat-no" title="function not covered" >Il(e</span>){let r=<span class="cstat-no" title="statement not covered" >new TextEncoder().encode(e),t</span>=<span class="cstat-no" title="statement not covered" >"",n</span>=<span class="cstat-no" title="statement not covered" >r.byteLength,</span>i=<span class="cstat-no" title="statement not covered" >n%3,o</span>=<span class="cstat-no" title="statement not covered" >n-i,s</span>,a,l,u,c;<span class="cstat-no" title="statement not covered" >for(let p=<span class="cstat-no" title="statement not covered" >0;p</span>&lt;o;p=p+3)<span class="cstat-no" title="statement not covered" >c=r[p]&lt;&lt;16|r[p+1]&lt;&lt;8|r[p+2],s=(c&amp;16515072)&gt;&gt;18,a=(c&amp;258048)&gt;&gt;12,l=(c&amp;4032)&gt;&gt;6,u=c&amp;63,t+=$e[s]+$e[a]+$e[l]+$e[u];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i==1?(c=r[o],s=(c&amp;252)&gt;&gt;2,a=(c&amp;3)&lt;&lt;4,t+=$e[s]+$e[a]+"=="):i==2&amp;&amp;(c=r[o]&lt;&lt;8|r[o+1],s=(c&amp;64512)&gt;&gt;10,a=(c&amp;1008)&gt;&gt;4,l=(c&amp;15)&lt;&lt;2,t+=$e[s]+$e[a]+$e[l]+"="),t}</span>function <span class="fstat-no" title="function not covered" >kl(e</span>){<span class="cstat-no" title="statement not covered" >if(!!e.generator?.previewFeatures.some(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.toLowerCase().includes("metrics")))<span class="cstat-no" title="statement not covered" >t</span>hrow new T("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}</span></span>var Dl={"@prisma/debug":"workspace:*","@prisma/engines-version":"6.13.0-35.361e86d0ea4987e9f53a565309b3eed797a6bcbd","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};var Mt=class extends se{name="RequestError";code="P5010";<span class="fstat-no" title="function not covered" >constructor(r</span>,t){<span class="cstat-no" title="statement not covered" >super(`Cannot fetch data from service:</span></span></span></span></span></span></span></span></span></span></span></span>
${r}`,A(t,!0))}};x(Mt,"RequestError");async function <span class="fstat-no" title="function not covered" >dr(e</span>,r,t=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>)</span></span>{let{clientVersion:n,...i}=<span class="cstat-no" title="statement not covered" >r,o</span>=<span class="cstat-no" title="statement not covered" >t(fetch);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return await o(e,i)}</span>catch(s){let a=<span class="cstat-no" title="statement not covered" >s.message??"Unknown error";<span class="cstat-no" title="statement not covered" >t</span>hrow new Mt(a,{clientVersion:n,cause:s})}</span>}</span>var ff=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,Ol=N("prisma:client:dataproxyEngine");async function <span class="fstat-no" title="function not covered" >gf(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >Dl["@prisma/engines-version"],</span>n=<span class="cstat-no" title="statement not covered" >r.clientVersion??"unknown";<span class="cstat-no" title="statement not covered" >i</span>f(process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)<span class="cstat-no" title="statement not covered" >return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.includes("accelerate")&amp;&amp;n!=="0.0.0"&amp;&amp;n!=="in-memory")<span class="cstat-no" title="statement not covered" >return n;l</span></span>et[i,o]=<span class="cstat-no" title="statement not covered" >n?.split("-")??[];<span class="cstat-no" title="statement not covered" ></span>if(o===void 0&amp;&amp;ff.test(i))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f(o!==void 0||n==="0.0.0"||n==="in-memory"){let[s]=<span class="cstat-no" title="statement not covered" >t.split("-")??[],</span>[a,l,u]=<span class="cstat-no" title="statement not covered" >s.split("."),c</span>=<span class="cstat-no" title="statement not covered" >hf(`&lt;=${a}.${l}.${u}`),p</span>=<span class="cstat-no" title="statement not covered" >await dr(c,{clientVersion:n});<span class="cstat-no" title="statement not covered" >i</span>f(!p.ok)<span class="cstat-no" title="statement not covered" >throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text()||"&lt;empty body&gt;"}`);l</span></span>et d=<span class="cstat-no" title="statement not covered" >await p.text();<span class="cstat-no" title="statement not covered" >O</span>l("length of body fetched from unpkg.com",d.length);l</span>et f;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >f=JSON.parse(d)}</span>catch(h){<span class="cstat-no" title="statement not covered" >throw console.error("JSON.parse error: body fetched from unpkg.com: ",d),h}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn f.version}<span class="cstat-no" title="statement not covered" >t</span></span>hrow new cr("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}</span>async function <span class="fstat-no" title="function not covered" >_l(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >await gf(e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn Ol("version",t),t}</span>function <span class="fstat-no" title="function not covered" >hf(e</span>){<span class="cstat-no" title="statement not covered" >return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}</span>var Nl=3,$t=N("prisma:client:dataproxyEngine"),qt=class{<span class="cstat-no" title="statement not covered" >name="DataProxyEngine";inlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;protocol;<span class="fstat-no" title="function not covered" >c</span>onstructor(r</span>){<span class="cstat-no" title="statement not covered" >kl(r),this.config=r,this.env=r.env,this.inlineSchema=Il(r.inlineSchema),this.inlineDatasources=r.inlineDatasources,this.inlineSchemaHash=r.inlineSchemaHash,this.clientVersion=r.clientVersion,this.engineHash=r.engineVersion,this.logEmitter=r.logEmitter,this.tracingHelper=r.tracingHelper}<span class="fstat-no" title="function not covered" >a</span>piKey(){<span class="cstat-no" title="statement not covered" ></span>return this.headerBuilder.apiKey}<span class="fstat-no" title="function not covered" >v</span>ersion(){<span class="cstat-no" title="statement not covered" ></span>return this.engineHash}<span class="fstat-no" title="function not covered" >a</span>sync s</span>tart(){<span class="cstat-no" title="statement not covered" >this.startPromise!==void 0&amp;&amp;await this.startPromise,this.startPromise=(<span class="fstat-no" title="function not covered" >async()=&gt;{l</span>et{apiKey:r,url:t}=<span class="cstat-no" title="statement not covered" >this.getURLAndAPIKey();<span class="cstat-no" title="statement not covered" >t</span>his.host=t.host,this.protocol=t.protocol,this.headerBuilder=new Kn({apiKey:r,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel??"error",logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await _l(this.host,this.config),$t("host",this.host),$t("protocol",this.protocol)}</span>)(),await this.startPromise}<span class="fstat-no" title="function not covered" >a</span>sync s</span>top(){}<span class="fstat-no" title="function not covered" >propagateResponseExtensions(r</span>){<span class="cstat-no" title="statement not covered" >r?.logs?.length&amp;&amp;r.logs.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >s</span>witch(t.level){case"debug":case"trace":<span class="cstat-no" title="statement not covered" >$t(t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"error":case"warn":case"info":{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit(t.level,{timestamp:fo(t.timestamp),message:t.attributes.message??"",target:t.target});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"query":{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit("query",{query:t.attributes.query??"",timestamp:fo(t.timestamp),duration:t.attributes.duration_ms??0,params:t.attributes.params??"",target:t.target});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >t.level}}</span></span>),r?.traces?.length&amp;&amp;this.tracingHelper.dispatchEngineSpans(r.traces)}<span class="fstat-no" title="function not covered" ></span>onBeforeExit(){<span class="cstat-no" title="statement not covered" ></span>throw new Error('"beforeExit" hook is not applicable to the remote query engine')}<span class="fstat-no" title="function not covered" ></span>async u</span>rl(r){<span class="cstat-no" title="statement not covered" >return await this.start(),`${this.protocol}//${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`}<span class="fstat-no" title="function not covered" >a</span>sync u</span>ploadSchema(){let r=<span class="cstat-no" title="statement not covered" >{name:"schemaUpload",internal:!0};<span class="cstat-no" title="statement not covered" >r</span>eturn this.tracingHelper.runInChildSpan(r,<span class="fstat-no" title="function not covered" >async()=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >await dr(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" >t</span>.ok||$t("schema response status",t.status);l</span>et n=<span class="cstat-no" title="statement not covered" >await Ft(t,this.clientVersion);<span class="cstat-no" title="statement not covered" >i</span>f(n)<span class="cstat-no" title="statement not covered" >throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;<span class="cstat-no" title="statement not covered" >t</span></span>his.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})}</span>)}<span class="fstat-no" title="function not covered" ></span>request(r</span>,{traceparent:t,interactiveTransaction:n,customDataProxyFetch:i}){<span class="cstat-no" title="statement not covered" >return this.requestInternal({body:r,traceparent:t,interactiveTransaction:n,customDataProxyFetch:i})}<span class="fstat-no" title="function not covered" ></span>async r</span>equestBatch(r,{traceparent:t,transaction:n,customDataProxyFetch:i}){let o=<span class="cstat-no" title="statement not covered" >n?.kind==="itx"?n.options:void 0,s</span>=<span class="cstat-no" title="statement not covered" >$r(r,n);<span class="cstat-no" title="statement not covered" >r</span>eturn(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:t})).map(<span class="fstat-no" title="function not covered" >l=&gt;(<span class="cstat-no" title="statement not covered" >l</span>.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l))}<span class="fstat-no" title="function not covered" ></span></span>requestInternal({</span>body:r,traceparent:t,customDataProxyFetch:n,interactiveTransaction:i}){<span class="cstat-no" title="statement not covered" >return this.withRetry({actionGerund:"querying",callback:<span class="fstat-no" title="function not covered" >async({</span>logHttpCall:o})=&gt;{let s=<span class="cstat-no" title="statement not covered" >i?`${i.payload.endpoint}/graphql`:await this.url("graphql");<span class="cstat-no" title="statement not covered" >o</span>(s);l</span>et a=<span class="cstat-no" title="statement not covered" >await dr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t,transactionId:i?.id}),body:JSON.stringify(r),clientVersion:this.clientVersion},n);<span class="cstat-no" title="statement not covered" >a</span>.ok||$t("graphql response status",a.status),await this.handleError(await Ft(a,this.clientVersion));l</span>et l=<span class="cstat-no" title="statement not covered" >await a.json();<span class="cstat-no" title="statement not covered" >i</span>f(l.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l)<span class="cstat-no" title="statement not covered" >throw this.convertProtocolErrorsToClientError(l.errors);<span class="cstat-no" title="statement not covered" >r</span></span>eturn"batchResult"in l?l.batchResult:l}</span>})}<span class="fstat-no" title="function not covered" ></span>async t</span>ransaction(r,t,n){let i=<span class="cstat-no" title="statement not covered" >{start:"starting",commit:"committing",rollback:"rolling back"};<span class="cstat-no" title="statement not covered" >r</span>eturn this.withRetry({actionGerund:`${i[r]} transaction`,callback:<span class="fstat-no" title="function not covered" >async({</span>logHttpCall:o})=&gt;{<span class="cstat-no" title="statement not covered" >if(r==="start"){let s=<span class="cstat-no" title="statement not covered" >JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),a</span>=<span class="cstat-no" title="statement not covered" >await this.url("transaction/start");<span class="cstat-no" title="statement not covered" >o</span>(a);l</span>et l=<span class="cstat-no" title="statement not covered" >await dr(a,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),body:s,clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" >a</span>wait this.handleError(await Ft(l,this.clientVersion));l</span>et u=<span class="cstat-no" title="statement not covered" >await l.json(),{</span>extensions:c}=<span class="cstat-no" title="statement not covered" >u;<span class="cstat-no" title="statement not covered" >c</span>&amp;&amp;this.propagateResponseExtensions(c);l</span>et p=<span class="cstat-no" title="statement not covered" >u.id,</span>d=<span class="cstat-no" title="statement not covered" >u["data-proxy"].endpoint;<span class="cstat-no" title="statement not covered" ></span>return{id:p,payload:{endpoint:d}}}</span>else{let s=<span class="cstat-no" title="statement not covered" >`${n.payload.endpoint}/${r}`;<span class="cstat-no" title="statement not covered" ></span>o(s);l</span>et a=<span class="cstat-no" title="statement not covered" >await dr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" >a</span>wait this.handleError(await Ft(a,this.clientVersion));l</span>et l=<span class="cstat-no" title="statement not covered" >await a.json(),{</span>extensions:u}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" >u</span>&amp;&amp;this.propagateResponseExtensions(u);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}</span>})}<span class="fstat-no" title="function not covered" ></span>getURLAndAPIKey(){<span class="cstat-no" title="statement not covered" ></span>return Rl({clientVersion:this.clientVersion,env:this.env,inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources})}<span class="fstat-no" title="function not covered" ></span>metrics(){<span class="cstat-no" title="statement not covered" ></span>throw new cr("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}<span class="fstat-no" title="function not covered" ></span>async w</span>ithRetry(r){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0;;t</span>++){let n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >i=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.logEmitter.emit("info",{message:`Calling ${i} (n=${t})`,timestamp:new Date,target:""})}</span>;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return await r.callback({logHttpCall:n})}</span>catch(i){<span class="cstat-no" title="statement not covered" >if(!(i instanceof se)||!i.isRetryable)<span class="cstat-no" title="statement not covered" >throw i;<span class="cstat-no" title="statement not covered" >i</span></span>f(t&gt;=Nl)<span class="cstat-no" title="statement not covered" >throw i instanceof Br?i.cause:i;<span class="cstat-no" title="statement not covered" >t</span></span>his.logEmitter.emit("warn",{message:`Attempt ${t+1}/${Nl} failed for ${r.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});l</span>et o=<span class="cstat-no" title="statement not covered" >await Cl(t);<span class="cstat-no" title="statement not covered" >t</span>his.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>async h</span>andleError(r){<span class="cstat-no" title="statement not covered" >if(r instanceof pr)<span class="cstat-no" title="statement not covered" >throw await this.uploadSchema(),new Br({clientVersion:this.clientVersion,cause:r});<span class="cstat-no" title="statement not covered" >i</span></span>f(r)<span class="cstat-no" title="statement not covered" >throw r}<span class="fstat-no" title="function not covered" ></span></span>convertProtocolErrorsToClientError(r</span>){<span class="cstat-no" title="statement not covered" >return r.length===1?qr(r[0],this.config.clientVersion,this.config.activeProvider):new j(JSON.stringify(r),{clientVersion:this.config.clientVersion})}<span class="fstat-no" title="function not covered" ></span>applyPendingMigrations(){<span class="cstat-no" title="statement not covered" ></span>throw new Error("Method not implemented.")}</span>};function Ll(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(e?.kind==="itx")<span class="cstat-no" title="statement not covered" >return e.options.id}v</span>ar vo=C(require("node:os")),Fl=C(require("node:path"));var xo=Symbol("PrismaLibraryEngineCache");function yf(){let e=globalThis;return e[xo]===void 0&amp;&amp;(e[xo]={}),e[xo]}function bf(e){let r=yf();<span class="missing-if-branch" title="if path not taken" >I</span>if(r[e]!==void 0)<span class="cstat-no" title="statement not covered" >return r[e];l</span>et t=Fl.default.toNamespacedPath(e),n={exports:{}},i=0;return process.platform!=="win32"&amp;&amp;(i=vo.default.constants.dlopen.RTLD_LAZY|vo.default.constants.dlopen.RTLD_DEEPBIND),process.dlopen(n,t,i),r[e]=n.exports,n.exports}var Ml={async loadLibrary(e){let r=await gi(),t=await bl("library",e);try{return e.tracingHelper.runInChildSpan({name:"loadLibrary",internal:!0},()=&gt;bf(t))}catch(n){let i=<span class="cstat-no" title="statement not covered" >Ci({e:n,platformInfo:r,id:t});<span class="cstat-no" title="statement not covered" >t</span>hrow new T(i,e.clientVersion)}</span>}};var Po,$l={<span class="fstat-no" title="function not covered" >async l</span>oadLibrary(e){let{clientVersion:r,adapter:t,engineWasm:n}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >i</span>f(t===void 0)<span class="cstat-no" title="statement not covered" >throw new T(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Gn().prettyName})`,r);<span class="cstat-no" title="statement not covered" >i</span></span>f(n===void 0)<span class="cstat-no" title="statement not covered" >throw new T("WASM engine was unexpectedly `undefined`",r);<span class="cstat-no" title="statement not covered" >P</span></span>o===void 0&amp;&amp;(Po=(<span class="fstat-no" title="function not covered" >async()=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >await n.getRuntime(),s</span>=<span class="cstat-no" title="statement not covered" >await n.getQueryEngineWasmModule();<span class="cstat-no" title="statement not covered" >i</span>f(s==null)<span class="cstat-no" title="statement not covered" >throw new T("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",r);l</span></span>et a=<span class="cstat-no" title="statement not covered" >{"./query_engine_bg.js":o},l</span>=<span class="cstat-no" title="statement not covered" >new WebAssembly.Instance(s,a),u</span>=<span class="cstat-no" title="statement not covered" >l.exports.__wbindgen_start;<span class="cstat-no" title="statement not covered" ></span>return o.__wbg_set_wasm(l.exports),u(),o.QueryEngine})()</span>);l</span>et i=<span class="cstat-no" title="statement not covered" >await Po;<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >debugPanic(){<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.reject("{}")}</span>,<span class="fstat-no" title="function not covered" >dmmf(){<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve("{}")}</span>,<span class="fstat-no" title="function not covered" >version(){<span class="cstat-no" title="statement not covered" >r</span>eturn{commit:"unknown",version:"unknown"}}</span>,QueryEngine:i}}</span>};var Ef="P2036",Ae=N("prisma:client:libraryEngine");function <span class="fstat-no" title="function not covered" >wf(e</span>){<span class="cstat-no" title="statement not covered" >return e.item_type==="query"&amp;&amp;"query"in e}</span>function <span class="fstat-no" title="function not covered" >xf(e</span>){<span class="cstat-no" title="statement not covered" >return"level"in e?e.level==="error"&amp;&amp;e.message==="PANIC":!1}</span>var ql=[...ui,"native"],vf=0xffffffffffffffffn,To=1n;function Pf(){let e=To++;return To&gt;vf&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >To=1n)</span>,e}var Qr=class{name="LibraryEngine";engine;libraryInstantiationPromise;libraryStartingPromise;libraryStoppingPromise;libraryStarted;executingQueryPromise;config;QueryEngineConstructor;libraryLoader;library;logEmitter;libQueryEnginePath;binaryTarget;datasourceOverrides;datamodel;logQueries;logLevel;lastQuery;loggerRustPanic;tracingHelper;adapterPromise;versionInfo;constructor(r,t){this.libraryLoader=t??Ml,r.engineWasm!==void 0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.libraryLoader=t??$l</span>),this.config=r,this.libraryStarted=!1,this.logQueries=r.logQueries??<span class="branch-1 cbranch-no" title="branch not covered" >!1,t</span>his.logLevel=r.logLevel??<span class="branch-1 cbranch-no" title="branch not covered" >"error",t</span>his.logEmitter=r.logEmitter,this.datamodel=r.inlineSchema,this.tracingHelper=r.tracingHelper,r.enableDebugLogs&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.logLevel="debug"</span>);let n=Object.keys(r.overrideDatasources)[0],i=r.overrideDatasources[n]?.url;n!==void 0&amp;&amp;i!==void 0&amp;&amp;(this.datasourceOverrides={[n]:i}),this.libraryInstantiationPromise=this.instantiateLibrary()}wrapEngine(r){return{applyPendingMigrations:r.applyPendingMigrations?.bind(r),commitTransaction:this.withRequestId(r.commitTransaction.bind(r)),connect:this.withRequestId(r.connect.bind(r)),disconnect:this.withRequestId(r.disconnect.bind(r)),metrics:r.metrics?.bind(r),query:this.withRequestId(r.query.bind(r)),rollbackTransaction:this.withRequestId(r.rollbackTransaction.bind(r)),sdlSchema:r.sdlSchema?.bind(r),startTransaction:this.withRequestId(r.startTransaction.bind(r)),trace:r.trace.bind(r),free:r.free?.bind(r)}}withRequestId(r){return async(...t)=&gt;{let n=Pf().toString();try{return await r(...t,n)}finally{<span class="missing-if-branch" title="if path not taken" >I</span>if(this.tracingHelper.isEnabled()){let i=<span class="cstat-no" title="statement not covered" >await this.engine?.trace(n);<span class="cstat-no" title="statement not covered" >i</span>f(i){let o=<span class="cstat-no" title="statement not covered" >JSON.parse(i);<span class="cstat-no" title="statement not covered" >t</span>his.tracingHelper.dispatchEngineSpans(o.spans)}</span>}</span>}}}<span class="fstat-no" title="function not covered" >async a</span>pplyPendingMigrations(){<span class="cstat-no" title="statement not covered" >throw new Error("Cannot call this method from this type of engine instance")}</span>async transaction(r,t,n){await this.start();let i=await this.adapterPromise,o=JSON.stringify(t),s;if(r==="start"){let l=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});s=await this.engine?.startTransaction(l,o)}else r==="commit"?s=await this.engine?.commitTransaction(n.id,o):r==="rollback"&amp;&amp;(s=await this.engine?.rollbackTransaction(n.id,o));let a=this.parseEngineResponse(s);<span class="missing-if-branch" title="if path not taken" >I</span>if(Tf(a)){let l=<span class="cstat-no" title="statement not covered" >this.getExternalAdapterError(a,i?.errorRegistry);<span class="cstat-no" title="statement not covered" >t</span>hrow l?l.error:new z(a.message,{code:a.error_code,clientVersion:this.config.clientVersion,meta:a.meta})}</span>else <span class="missing-if-branch" title="if path not taken" >I</span>if(typeof a.message=="string")<span class="cstat-no" title="statement not covered" >throw new j(a.message,{clientVersion:this.config.clientVersion});r</span>eturn a}async instantiateLibrary(){<span class="missing-if-branch" title="if path not taken" >I</span>if(Ae("internalSetup"),this.libraryInstantiationPromise)<span class="cstat-no" title="statement not covered" >return this.libraryInstantiationPromise;l</span>i(),this.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",()=&gt;this.loadEngine()),this.version()}async getCurrentBinaryTarget(){{<span class="missing-if-branch" title="if path not taken" >I</span>if(this.binaryTarget)<span class="cstat-no" title="statement not covered" >return this.binaryTarget;l</span>et r=await this.tracingHelper.runInChildSpan("detect_platform",()=&gt;ir());<span class="missing-if-branch" title="if path not taken" >I</span>if(!ql.includes(r))<span class="cstat-no" title="statement not covered" >throw new T(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r))}. Possible binaryTargets: ${qe(ql.join(", "))} or a path to the query engine library.</span>
You may have to run ${qe("prisma generate")} for your changes to take effect.`,this.config.clientVersion);return r}}parseEngineResponse(r){<span class="missing-if-branch" title="if path not taken" >I</span>if(!r)<span class="cstat-no" title="statement not covered" >throw new j("Response from the Engine was empty",{clientVersion:this.config.clientVersion});t</span>ry{return JSON.parse(r)}catch{<span class="cstat-no" title="statement not covered" >throw new j("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}</span>}async loadEngine(){<span class="missing-if-branch" title="else path not taken" >E</span>if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let r=new WeakRef(this);this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(tn));let t=await this.adapterPromise;t&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Ae("Using driver adapter: %O",t),t</span>his.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:process.env,logQueries:this.config.logQueries??<span class="branch-1 cbranch-no" title="branch not covered" >!1,i</span>gnoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??<span class="branch-1 cbranch-no" title="branch not covered" >{},l</span>ogLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >r</span>.deref()?.logger(n)}</span>,t))}catch(r){let t=<span class="cstat-no" title="statement not covered" >r,n</span>=<span class="cstat-no" title="statement not covered" >this.parseInitError(t.message);<span class="cstat-no" title="statement not covered" >t</span>hrow typeof n=="string"?t:new T(n.message,this.config.clientVersion,n.error_code)}</span>}}<span class="fstat-no" title="function not covered" >logger(r</span>){let t=<span class="cstat-no" title="statement not covered" >this.parseEngineResponse(r);<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;(t.level=t?.level.toLowerCase()??"unknown",wf(t)?this.logEmitter.emit("query",{timestamp:new Date,query:t.query,params:t.params,duration:Number(t.duration_ms),target:t.module_path}):xf(t)?this.loggerRustPanic=new le(So(this,`${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`),this.config.clientVersion):this.logEmitter.emit(t.level,{timestamp:new Date,message:t.message,target:t.module_path}))}<span class="fstat-no" title="function not covered" ></span>parseInitError(r</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.parse(r)}</span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>parseRequestError(r){try{return JSON.parse(r)}catch{}return r}<span class="fstat-no" title="function not covered" >onBeforeExit(){<span class="cstat-no" title="statement not covered" ></span>throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}</span>async start(){<span class="missing-if-branch" title="if path not taken" >I</span>if(this.libraryInstantiationPromise||(<span class="branch-1 cbranch-no" title="branch not covered" >this.libraryInstantiationPromise=this.instantiateLibrary()</span>),await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)<span class="cstat-no" title="statement not covered" >return Ae(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;i</span>f(this.libraryStarted)return;let r=async()=&gt;{Ae("library starting");try{let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(t)),this.libraryStarted=!0,this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(tn)),await this.adapterPromise,Ae("library started")}catch(t){let n=<span class="cstat-no" title="statement not covered" >this.parseInitError(t.message);<span class="cstat-no" title="statement not covered" >t</span>hrow typeof n=="string"?t:new T(n.message,this.config.clientVersion,n.error_code)}</span>finally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",r),this.libraryStartingPromise}async stop(){<span class="missing-if-branch" title="if path not taken" >I</span>if(await this.libraryInstantiationPromise,await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)<span class="cstat-no" title="statement not covered" >return Ae("library is already stopping"),this.libraryStoppingPromise;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!this.libraryStarted){<span class="cstat-no" title="statement not covered" >await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0;<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>let r=async()=&gt;{await new Promise(n=&gt;setImmediate(n)),Ae("library stopping");let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(t)),this.engine?.free&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >this.engine.free(),t</span>his.engine=void 0,this.libraryStarted=!1,this.libraryStoppingPromise=void 0,this.libraryInstantiationPromise=void 0,await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0,Ae("library stopped")};return this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",r),this.libraryStoppingPromise}version(){return this.versionInfo=this.library?.version(),this.versionInfo?.version??<span class="branch-1 cbranch-no" title="branch not covered" >"unknown"}<span class="fstat-no" title="function not covered" ></span>debugPanic(r</span>){<span class="cstat-no" title="statement not covered" >return this.library?.debugPanic(r)}</span>async request(r,{traceparent:t,interactiveTransaction:n}){Ae(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:t}),o=JSON.stringify(r);try{await this.start();let s=await this.adapterPromise;this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;let a=this.parseEngineResponse(await this.executingQueryPromise);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],s?.errorRegistry):<span class="branch-1 cbranch-no" title="branch not covered" >new j(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(this.loggerRustPanic)<span class="cstat-no" title="statement not covered" >throw this.loggerRustPanic;r</span>eturn{data:a}}catch(s){<span class="missing-if-branch" title="if path not taken" >I</span>if(s instanceof T)<span class="cstat-no" title="statement not covered" >throw s;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(s.code==="GenericFailure"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >s.message?.startsWith("PANIC:"))<span class="cstat-no" title="statement not covered" >t</span>hrow new le(So(this,s.message),this.config.clientVersion);l</span>et a=this.parseRequestError(s.message);throw typeof a=="string"?s:<span class="branch-1 cbranch-no" title="branch not covered" >new j(`${a.message}</span>
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}async requestBatch(r,{transaction:t,traceparent:n}){Ae("requestBatch");let i=$r(r,t);await this.start();let o=await this.adapterPromise;this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine?.query(this.lastQuery,JSON.stringify({traceparent:n}),Ll(t));let s=await this.executingQueryPromise,a=this.parseEngineResponse(s);<span class="missing-if-branch" title="if path not taken" >I</span>if(a.errors)<span class="cstat-no" title="statement not covered" >throw a.errors.length===1?this.buildQueryError(a.errors[0],o?.errorRegistry):new j(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});l</span>et{batchResult:l,errors:u}=a;<span class="missing-if-branch" title="else path not taken" >E</span>if(Array.isArray(l))return l.map(c=&gt;c.errors&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >c.errors.length&gt;0?<span class="branch-0 cbranch-no" title="branch not covered" >t</span>his.loggerRustPanic??this.buildQueryError(c.errors[0],o?.errorRegistry):{</span>data:c});<span class="cstat-no" title="statement not covered" >throw u&amp;&amp;u.length===1?new Error(u[0].error):new Error(JSON.stringify(a))}</span>buildQueryError(r,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(r.user_facing_error.is_panic)<span class="cstat-no" title="statement not covered" >return new le(So(this,r.user_facing_error.message),this.config.clientVersion);l</span>et n=this.getExternalAdapterError(r.user_facing_error,t);return n?<span class="branch-0 cbranch-no" title="branch not covered" >n.error:</span>qr(r,this.config.clientVersion,this.config.activeProvider)}getExternalAdapterError(r,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(r.error_code===Ef&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t){</span>let n=<span class="cstat-no" title="statement not covered" >r.meta?.id;<span class="cstat-no" title="statement not covered" >l</span>n(typeof n=="number","Malformed external JS error received from the engine");l</span>et i=<span class="cstat-no" title="statement not covered" >t.consumeError(n);<span class="cstat-no" title="statement not covered" >r</span>eturn ln(i,"External error with reported id was not registered"),i}</span>}<span class="fstat-no" title="function not covered" >async m</span>etrics(r){<span class="cstat-no" title="statement not covered" >await this.start();l</span>et t=<span class="cstat-no" title="statement not covered" >await this.engine.metrics(JSON.stringify(r));<span class="cstat-no" title="statement not covered" >r</span>eturn r.format==="prometheus"?t:this.parseEngineResponse(t)}</span>};function Tf(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.error_code!==void 0}function <span class="fstat-no" title="function not covered" >So(e</span>,r){<span class="cstat-no" title="statement not covered" >return Tl({binaryTarget:e.binaryTarget,title:r,version:e.config.clientVersion,engineVersion:e.versionInfo?.commit,database:e.config.activeProvider,query:e.lastQuery})}</span>function jl({url:e,adapter:r,copyEngine:t,targetBuildType:n}){let i=[],o=[],s=<span class="fstat-no" title="function not covered" >g=&gt;{<span class="cstat-no" title="statement not covered" >i</span>.push({_tag:"warning",value:g})}</span>,a=<span class="fstat-no" title="function not covered" >g=&gt;{l</span>et S=<span class="cstat-no" title="statement not covered" >g.join(`</span>
`);<span class="cstat-no" title="statement not covered" >o.push({_tag:"error",value:S})}</span>,l=!!e?.startsWith("prisma://"),u=an(e),c=!!r,p=l||u;!c&amp;&amp;t&amp;&amp;p&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >s(["recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);l</span>et d=p||!t;c&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >d||<span class="branch-2 cbranch-no" title="branch not covered" >n</span>==="edge"</span>)&amp;&amp;(<span class="branch-3 cbranch-no" title="branch not covered" >n==="edge"?a(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.","Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]):t?l&amp;&amp;a(["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]):a(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));l</span>et f={accelerate:d,ppg:u,driverAdapters:c};function h(g){return g.length&gt;0}return h(o)?<span class="branch-0 cbranch-no" title="branch not covered" >{ok:!1,diagnostics:{warnings:i,errors:o},isUsing:f}:{</span>ok:!0,diagnostics:{warnings:i},isUsing:f}}function Vl({copyEngine:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>,r){let t;try{t=Vr({inlineDatasources:r.inlineDatasources,overrideDatasources:r.overrideDatasources,env:{...r.env,...process.env},clientVersion:r.clientVersion})}catch{}let{ok:n,isUsing:i,diagnostics:o}=jl({url:t,adapter:r.adapter,copyEngine:e,targetBuildType:"library"});for(let p of o.warnings)<span class="cstat-no" title="statement not covered" >at(...p.value);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!n){let p=<span class="cstat-no" title="statement not covered" >o.errors[0];<span class="cstat-no" title="statement not covered" ></span>throw new Z(p.value,{clientVersion:r.clientVersion})}</span>let s=Er(r.generator),a=s==="library",l=s==="binary",u=s==="client",c=(i.accelerate||i.ppg)&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >!i.driverAdapters;</span>return i.accelerate?<span class="branch-0 cbranch-no" title="branch not covered" >new qt(r):(i</span>.driverAdapters,a?new Qr(r):(<span class="branch-1 cbranch-no" title="branch not covered" >i.accelerate,new Qr(r)</span>))}function Yn({generator:e}){return e?.previewFeatures??<span class="branch-1 cbranch-no" title="branch not covered" >[]}</span>var Bl=<span class="fstat-no" title="function not covered" >e=&gt;(<span class="cstat-no" title="statement not covered" >{</span>command:e});v</span>ar Ul=<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.strings.reduce(<span class="fstat-no" title="function not covered" >(r</span>,t,n)=&gt;<span class="cstat-no" title="statement not covered" >`${r}@P${n}${t}`)</span>;f</span>unction <span class="fstat-no" title="function not covered" >Wr(e</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return Gl(e,"fast")}</span>catch{<span class="cstat-no" title="statement not covered" >return Gl(e,"slow")}</span>}</span>function <span class="fstat-no" title="function not covered" >Gl(e</span>,r){<span class="cstat-no" title="statement not covered" >return JSON.stringify(e.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >W</span>l(t,r)))}</span></span>function <span class="fstat-no" title="function not covered" >Wl(e</span>,r){<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >W</span>l(t,r));<span class="cstat-no" title="statement not covered" >i</span></span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return{prisma__type:"bigint",prisma__value:e.toString()};<span class="cstat-no" title="statement not covered" >i</span></span>f(Sr(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"date",prisma__value:e.toJSON()};<span class="cstat-no" title="statement not covered" >i</span></span>f(ve.isDecimal(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"decimal",prisma__value:e.toJSON()};<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.isBuffer(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:e.toString("base64")};<span class="cstat-no" title="statement not covered" >i</span></span>f(Sf(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:Buffer.from(e).toString("base64")};<span class="cstat-no" title="statement not covered" >i</span></span>f(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn{prisma__type:"bytes",prisma__value:Buffer.from(t,n,i).toString("base64")}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn typeof e=="object"&amp;&amp;r==="slow"?Jl(e):e}</span>function <span class="fstat-no" title="function not covered" >Sf(e</span>){<span class="cstat-no" title="statement not covered" >return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&amp;&amp;e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}</span>function <span class="fstat-no" title="function not covered" >Jl(e</span>){<span class="cstat-no" title="statement not covered" >if(typeof e!="object"||e===null)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e.toJSON=="function")<span class="cstat-no" title="statement not covered" >return e.toJSON();<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(Ql);l</span></span>et r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let t of Object.keys(e))<span class="cstat-no" title="statement not covered" >r[t]=Ql(e[t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Ql(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="bigint"?e.toString():Jl(e)}</span>var Rf=/^(\s*alter\s)/i,Hl=N("prisma:client");function <span class="fstat-no" title="function not covered" >Ro(e</span>,r,t,n){<span class="cstat-no" title="statement not covered" >if(!(e!=="postgresql"&amp;&amp;e!=="cockroachdb")&amp;&amp;t.length&gt;0&amp;&amp;Rf.exec(r))<span class="cstat-no" title="statement not covered" >throw new Error(`Running ALTER using ${n} is not supported</span></span>
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.
&nbsp;
Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)
&nbsp;
More Information: https://pris.ly/d/execute-raw
`)}var Ao=<span class="fstat-no" title="function not covered" >({</span>clientMethod:e,activeProvider:r})=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >"",i</span>;<span class="cstat-no" title="statement not covered" >if(qn(t))<span class="cstat-no" title="statement not covered" >n=t.sql,i={values:Wr(t.values),__prismaRawParameters__:!0};else <span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(t)){let[o,...s]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >n</span>=o,i={values:Wr(s||[]),__prismaRawParameters__:!0}}</span>else <span class="cstat-no" title="statement not covered" >switch(r){case"sqlite":case"mysql":{<span class="cstat-no" title="statement not covered" >n=t.sql,i={values:Wr(t.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"cockroachdb":case"postgresql":case"postgres":{<span class="cstat-no" title="statement not covered" >n=t.text,i={values:Wr(t.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"sqlserver":{<span class="cstat-no" title="statement not covered" >n=Ul(t),i={values:Wr(t.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >throw new Error(`The ${r} provider does not support ${e}`)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn i?.values?Hl(`prisma.${e}(${n}, ${i.values})`):Hl(`prisma.${e}(${n})`),{query:n,parameters:i}}</span>,K</span>l={<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(e</span>){<span class="cstat-no" title="statement not covered" >return[e.strings,...e.values]},<span class="fstat-no" title="function not covered" >m</span>iddlewareArgsToRequestArgs(e</span>){let[r,...t]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn new oe(r,t)}</span>},Yl={<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(e</span>){<span class="cstat-no" title="statement not covered" >return[e]},<span class="fstat-no" title="function not covered" >m</span>iddlewareArgsToRequestArgs(e</span>){<span class="cstat-no" title="statement not covered" >return e[0]}}</span>;function Co(e){return function(t,n){let i,o=(s=e)=&gt;{try{return s===void 0||s?.kind==="itx"?i??=zl(t(s)):zl(t(s))}catch(a){<span class="cstat-no" title="statement not covered" >return Promise.reject(a)}</span>};return{<span class="fstat-no" title="function not covered" >get s</span>pec(){<span class="cstat-no" title="statement not covered" >return n}</span>,then(s,a){return o().then(s,a)},<span class="fstat-no" title="function not covered" >catch(s</span>){<span class="cstat-no" title="statement not covered" >return o().catch(s)}</span>,<span class="fstat-no" title="function not covered" >finally(s</span>){<span class="cstat-no" title="statement not covered" >return o().finally(s)}</span>,requestTransaction(s){let a=o(s);return a.requestTransaction?<span class="branch-0 cbranch-no" title="branch not covered" >a.requestTransaction(s):a</span>},[Symbol.toStringTag]:"PrismaPromise"}}}function zl(e){return typeof e.then=="function"?e:<span class="branch-1 cbranch-no" title="branch not covered" >Promise.resolve(e)}</span>var Af=vi.split(".")[0],Cf={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},<span class="fstat-no" title="function not covered" >dispatchEngineSpans(){}</span>,getActiveContext(){},runInChildSpan(e,r){return r()}},Io=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(r){return this.getGlobalTracingHelper().getTraceParent(r)}<span class="fstat-no" title="function not covered" >dispatchEngineSpans(r</span>){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().dispatchEngineSpans(r)}</span>getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(r,t){return this.getGlobalTracingHelper().runInChildSpan(r,t)}getGlobalTracingHelper(){let r=globalThis[`V${Af}_PRISMA_INSTRUMENTATION`],t=globalThis.PRISMA_INSTRUMENTATION;return r?.helper??t?.helper??Cf}};function Zl(){return new Io}function Xl(e,r=()=&gt;{}){let t,n=new Promise(i=&gt;t=i);return{then(i){return--e===0&amp;&amp;t(r()),i?.(n)}}}function eu(e){return typeof e=="string"?<span class="branch-0 cbranch-no" title="branch not covered" >e:e</span>.reduce((r,t)=&gt;{let n=typeof t=="string"?t:<span class="branch-1 cbranch-no" title="branch not covered" >t.level;</span>return n==="query"?<span class="branch-0 cbranch-no" title="branch not covered" >r:r</span>&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t==="info"||<span class="branch-2 cbranch-no" title="branch not covered" >r</span>==="info"</span>)?<span class="branch-0 cbranch-no" title="branch not covered" >"info":n</span>},void 0)}var zn=class{_middlewares=[];<span class="fstat-no" title="function not covered" >use(r</span>){<span class="cstat-no" title="statement not covered" >this._middlewares.push(r)}</span>get(r){return this._middlewares[r]}<span class="fstat-no" title="function not covered" >has(r</span>){<span class="cstat-no" title="statement not covered" >return!!this._middlewares[r]}<span class="fstat-no" title="function not covered" >l</span>ength(){<span class="cstat-no" title="statement not covered" ></span>return this._middlewares.length}}</span>;var tu=C(Li());function Zn(e){return typeof e.batchRequestIdx=="number"}function ru(e){if(e.action!=="findUnique"&amp;&amp;e.action!=="findUniqueOrThrow")return;let r=[];return e.modelName&amp;&amp;r.push(e.modelName),e.query.arguments&amp;&amp;r.push(ko(e.query.arguments)),r.push(ko(e.query.selection)),r.join("")}function ko(e){return`(${Object.keys(e).sort().map(t=&gt;{let n=e[t];return typeof n=="object"&amp;&amp;n!==null?`(${t} ${ko(n)})`:t}).join(" ")})`}var If={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function Do(e){return If[e]}var Xn=class{constructor(r){this.options=r;this.batches={}}batches;tickActive=!1;request(r){let t=this.options.batchBy(r);return t?(this.batches[t]||(this.batches[t]=[],this.tickActive||(this.tickActive=!0,process.nextTick(()=&gt;{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=&gt;{this.batches[t].push({request:r,resolve:n,reject:i})})):this.options.singleLoader(r)}dispatchBatches(){for(let r in this.batches){let t=this.batches[r];delete this.batches[r],t.length===1?this.options.singleLoader(t[0].request).then(n=&gt;{n instanceof Error?<span class="branch-0 cbranch-no" title="branch not covered" >t[0].reject(n):t</span>[0].resolve(n)}).catch(n=&gt;{t[0].reject(n)}):(t.sort((n,i)=&gt;this.options.batchOrder(n.request,i.request)),this.options.batchLoader(t.map(n=&gt;n.request)).then(n=&gt;{<span class="missing-if-branch" title="if path not taken" >I</span>if(n instanceof Error)<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >t[i].reject(n);else f</span></span>or(let i=0;i&lt;t.length;i++){let o=n[i];o instanceof Error?<span class="branch-0 cbranch-no" title="branch not covered" >t[i].reject(o):t</span>[i].resolve(o)}}).catch(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >t[i].reject(n)}</span></span>))}}<span class="fstat-no" title="function not covered" >get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"DataLoader"}</span>};function <span class="fstat-no" title="function not covered" >mr(e</span>,r){<span class="cstat-no" title="statement not covered" >if(r===null)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >s</span></span>witch(e){case"bigint":<span class="cstat-no" title="statement not covered" >return BigInt(r);c</span>ase"bytes":{let{buffer:t,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >Buffer.from(r,"base64");<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(t,n,i)}</span>case"decimal":<span class="cstat-no" title="statement not covered" >return new ve(r);c</span>ase"datetime":case"date":<span class="cstat-no" title="statement not covered" >return new Date(r);c</span>ase"time":<span class="cstat-no" title="statement not covered" >return new Date(`1970-01-01T${r}Z`);c</span>ase"bigint-array":<span class="cstat-no" title="statement not covered" >return r.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >m</span>r("bigint",t));c</span></span>ase"bytes-array":<span class="cstat-no" title="statement not covered" >return r.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >m</span>r("bytes",t));c</span></span>ase"decimal-array":<span class="cstat-no" title="statement not covered" >return r.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >m</span>r("decimal",t));c</span></span>ase"datetime-array":<span class="cstat-no" title="statement not covered" >return r.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >m</span>r("datetime",t));c</span></span>ase"date-array":<span class="cstat-no" title="statement not covered" >return r.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >m</span>r("date",t));c</span></span>ase"time-array":<span class="cstat-no" title="statement not covered" >return r.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >m</span>r("time",t));d</span></span>efault:<span class="cstat-no" title="statement not covered" >return r}</span>}</span>function <span class="fstat-no" title="function not covered" >ei(e</span>){let r=<span class="cstat-no" title="statement not covered" >[],</span>t=<span class="cstat-no" title="statement not covered" >kf(e);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;n</span>&lt;e.rows.length;n++){let i=<span class="cstat-no" title="statement not covered" >e.rows[n],</span>o=<span class="cstat-no" title="statement not covered" >{...t};<span class="cstat-no" title="statement not covered" >f</span>or(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >o[e.columns[s]]=mr(e.types[s],i[s]);<span class="cstat-no" title="statement not covered" >r</span></span>.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >kf(e</span>){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;t</span>&lt;e.columns.length;t++)<span class="cstat-no" title="statement not covered" >r[e.columns[t]]=null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>var Df=N("prisma:client:request_handler"),ri=class{client;dataloader;logEmitter;constructor(r,t){this.logEmitter=t,this.client=r,this.dataloader=new Xn({batchLoader:sl(async({requests:n,customDataProxyFetch:i})=&gt;{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(p=&gt;p.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),u=n.some(p=&gt;Do(p.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:Of(o),containsWrite:u,customDataProxyFetch:i})).map((p,d)=&gt;{<span class="missing-if-branch" title="if path not taken" >I</span>if(p instanceof Error)<span class="cstat-no" title="statement not covered" >return p;t</span>ry{return this.mapQueryEngineResult(n[d],p)}catch(f){<span class="cstat-no" title="statement not covered" >return f}</span>})}),singleLoader:async n=&gt;{let i=n.transaction?.kind==="itx"?nu(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:Do(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=&gt;n.transaction?.id?`transaction-${n.transaction.id}`:ru(n.protocolQuery),batchOrder(n,i){return n.transaction?.kind==="batch"&amp;&amp;i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:<span class="branch-1 cbranch-no" title="branch not covered" >0}</span>})}async request(r){try{return await this.dataloader.request(r)}catch(t){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=r;this.handleAndLogRequestError({error:t,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:r.globalOmit})}}mapQueryEngineResult({dataPath:r,unpacker:t},n){let i=n?.data,o=this.unpack(i,r,t);return process.env.PRISMA_CLIENT_GET_TIME?<span class="branch-0 cbranch-no" title="branch not covered" >{data:o}:o</span>}handleAndLogRequestError(r){try{this.handleRequestError(r)}catch(t){throw this.logEmitter&amp;&amp;this.logEmitter.emit("error",{message:t.message,target:r.clientMethod,timestamp:new Date}),t}}handleRequestError({error:r,clientMethod:t,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){<span class="missing-if-branch" title="if path not taken" >I</span>if(Df(r),_f(r,i))<span class="cstat-no" title="statement not covered" >throw r;<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(r instanceof z&amp;&amp;Nf(r)){let u=iu(r.meta);_n({args:o,errors:[u],callsite:n,errorFormat:this.client._errorFormat,originalMethod:t,clientVersion:this.client._clientVersion,globalOmit:a})}let l=<span class="cstat-no" title="statement not covered" >r.message;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;(l=Pn({callsite:n,originalMethod:t,isPanic:r.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),r.code){let u=<span class="cstat-no" title="statement not covered" >s?{modelName:s,...r.meta}:r.meta;<span class="cstat-no" title="statement not covered" ></span>throw new z(l,{code:r.code,clientVersion:this.client._clientVersion,meta:u,batchRequestIdx:r.batchRequestIdx})}</span>else{<span class="cstat-no" title="statement not covered" >if(r.isPanic)<span class="cstat-no" title="statement not covered" >throw new le(l,this.client._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(r instanceof j)<span class="cstat-no" title="statement not covered" >throw new j(l,{clientVersion:this.client._clientVersion,batchRequestIdx:r.batchRequestIdx});<span class="cstat-no" title="statement not covered" >i</span></span>f(r instanceof T)<span class="cstat-no" title="statement not covered" >throw new T(l,this.client._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(r instanceof le)<span class="cstat-no" title="statement not covered" >throw new le(l,this.client._clientVersion)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>hrow r.clientVersion=this.client._clientVersion,r}<span class="fstat-no" title="function not covered" ></span>sanitizeMessage(r</span>){<span class="cstat-no" title="statement not covered" >return this.client._errorFormat&amp;&amp;this.client._errorFormat!=="pretty"?(0,tu.default)(r):r}</span>unpack(r,t,n){<span class="missing-if-branch" title="if path not taken" >I</span>if(!r||(r.data&amp;&amp;(r=r.data),!r))<span class="cstat-no" title="statement not covered" >return r;l</span>et i=Object.keys(r)[0],o=Object.values(r)[0],s=t.filter(<span class="fstat-no" title="function not covered" >u=&gt;<span class="cstat-no" title="statement not covered" >u</span>!=="select"&amp;&amp;u!=="include"),a</span>=lo(o,s),l=i==="queryRaw"?<span class="branch-0 cbranch-no" title="branch not covered" >ei(a):T</span>r(a);return n?n(l):l}<span class="fstat-no" title="function not covered" >get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"RequestHandler"}</span>};function Of(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};<span class="cstat-no" title="statement not covered" >if(e.kind==="itx")<span class="cstat-no" title="statement not covered" >return{kind:"itx",options:nu(e)};<span class="cstat-no" title="statement not covered" >N</span></span>e(e,"Unknown transaction kind")}</span>}function nu(e){return{id:e.id,payload:e.payload}}function _f(e,r){return Zn(e)&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r?.kind==="batch"&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e</span>.batchRequestIdx!==r.index}</span>function Nf(e){return e.code==="P2009"||<span class="branch-1 cbranch-no" title="branch not covered" >e.code==="P2012"}</span>function iu(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(iu)};<span class="missing-if-branch" title="else path not taken" >E</span>if(Array.isArray(e.selectionPath)){let[,...r]=e.selectionPath;return{...e,selectionPath:r}}<span class="cstat-no" title="statement not covered" >return e}</span>var ou=Sl;var cu=C(Ki());var O=class extends Error{<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >super(r+`</span>
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}<span class="fstat-no" title="function not covered" >get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientConstructorValidationError"}</span>};x(O,"PrismaClientConstructorValidationError");var su=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],au=["pretty","colorless","minimal"],lu=["info","query","warn","error"],Lf={datasources:(e,{datasourceNames:r})=&gt;{<span class="missing-if-branch" title="else path not taken" >E</span>if(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="object"||Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);f</span>or(let[t,n]of Object.entries(e)){<span class="missing-if-branch" title="if path not taken" >I</span>if(!r.includes(t)){let i=<span class="cstat-no" title="statement not covered" >Jr(t,r)||` Available datasources: ${r.join(", ")}`;<span class="cstat-no" title="statement not covered" ></span>throw new O(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(typeof n!="object"||Array.isArray(n))<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.</span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="missing-if-branch" title="else path not taken" >E</span>if(n&amp;&amp;typeof n=="object")for(let[i,o]of Object.entries(n)){<span class="missing-if-branch" title="if path not taken" >I</span>if(i!=="url")<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.</span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof o!="string")<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.</span>
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(!e&amp;&amp;Er(r.generator)==="client")<span class="cstat-no" title="statement not covered" >throw new O('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');<span class="cstat-no" title="statement not covered" >i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(e===void 0)<span class="cstat-no" title="statement not covered" >throw new O('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');<span class="cstat-no" title="statement not covered" >i</span></span>f(!Yn(r).includes("driverAdapters"))<span class="cstat-no" title="statement not covered" >throw new O('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');<span class="cstat-no" title="statement not covered" >i</span></span>f(Er(r.generator)==="binary")<span class="cstat-no" title="statement not covered" >throw new O('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')}</span></span>,datasourceUrl:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(typeof e&lt;"u"&amp;&amp;typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.</span></span>
Expected string or undefined.`)},errorFormat:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(e){<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);<span class="cstat-no" title="statement not covered" >i</span></span>f(!au.includes(e)){let r=<span class="cstat-no" title="statement not covered" >Jr(e,au);<span class="cstat-no" title="statement not covered" >t</span>hrow new O(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`)}</span>}</span>}</span>,log:e=&gt;{<span class="missing-if-branch" title="if path not taken" >I</span>if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);f</span>unction r(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t=="string"&amp;&amp;!lu.includes(t)){let n=<span class="cstat-no" title="statement not covered" >Jr(t,lu);<span class="cstat-no" title="statement not covered" >t</span>hrow new O(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`)}</span>}for(let t of e){r(t);let n={level:r,emit:<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >["stdout","event"];<span class="cstat-no" title="statement not covered" >i</span>f(!o.includes(i)){let s=<span class="cstat-no" title="statement not covered" >Jr(i,o);<span class="cstat-no" title="statement not covered" >t</span>hrow new O(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}</span>}</span>};<span class="missing-if-branch" title="if path not taken" >I</span>if(t&amp;&amp;typeof t=="object")<span class="cstat-no" title="statement not covered" >for(let[i,o]of Object.entries(t))<span class="cstat-no" title="statement not covered" >if(n[i])<span class="cstat-no" title="statement not covered" >n[i](o);else <span class="cstat-no" title="statement not covered" >t</span>hrow new O(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}</span></span></span>},transactionOptions:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e.maxWait;<span class="cstat-no" title="statement not covered" ></span>if(r!=null&amp;&amp;r&lt;=0)<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);l</span></span>et t=<span class="cstat-no" title="statement not covered" >e.timeout;<span class="cstat-no" title="statement not covered" ></span>if(t!=null&amp;&amp;t&lt;=0)<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)}</span></span>,omit:<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new O('"omit" option is expected to be an object.');<span class="cstat-no" title="statement not covered" >i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >throw new O('"omit" option can not be `null`');l</span></span>et t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let[n,i]of Object.entries(e)){let o=<span class="cstat-no" title="statement not covered" >Mf(n,r.runtimeDataModel);<span class="cstat-no" title="statement not covered" >i</span>f(!o){<span class="cstat-no" title="statement not covered" >t.push({kind:"UnknownModel",modelKey:n});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let[s,a]of Object.entries(i)){let l=<span class="cstat-no" title="statement not covered" >o.fields.find(<span class="fstat-no" title="function not covered" >u=&gt;<span class="cstat-no" title="statement not covered" >u</span>.name===s);<span class="cstat-no" title="statement not covered" >i</span></span>f(!l){<span class="cstat-no" title="statement not covered" >t.push({kind:"UnknownField",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.relationName){<span class="cstat-no" title="statement not covered" >t.push({kind:"RelationInOmit",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>ypeof a!="boolean"&amp;&amp;t.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.length&gt;0)<span class="cstat-no" title="statement not covered" >throw new O($f(e,t))}</span></span>,__internal:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >["debug","engine","configOverride"];<span class="cstat-no" title="statement not covered" >i</span>f(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new O(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let[t]of Object.entries(e))<span class="cstat-no" title="statement not covered" >if(!r.includes(t)){let n=<span class="cstat-no" title="statement not covered" >Jr(t,r);<span class="cstat-no" title="statement not covered" >t</span>hrow new O(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`)}</span>}</span></span>};function pu(e,r){for(let[t,n]of Object.entries(e)){<span class="missing-if-branch" title="if path not taken" >I</span>if(!su.includes(t)){let i=<span class="cstat-no" title="statement not covered" >Jr(t,su);<span class="cstat-no" title="statement not covered" >t</span>hrow new O(`Unknown property ${t} provided to PrismaClient constructor.${i}`)}</span>Lf[t](n,r)}<span class="missing-if-branch" title="if path not taken" >I</span>if(e.datasourceUrl&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.datasources)<span class="cstat-no" title="statement not covered" ></span>throw new O('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}</span>function <span class="fstat-no" title="function not covered" >Jr(e</span>,r){<span class="cstat-no" title="statement not covered" >if(r.length===0||typeof e!="string")<span class="cstat-no" title="statement not covered" >return"";l</span></span>et t=<span class="cstat-no" title="statement not covered" >Ff(e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn t?` Did you mean "${t}"?`:""}</span>function <span class="fstat-no" title="function not covered" >Ff(e</span>,r){<span class="cstat-no" title="statement not covered" >if(r.length===0)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et t=<span class="cstat-no" title="statement not covered" >r.map(<span class="fstat-no" title="function not covered" >i=&gt;(<span class="cstat-no" title="statement not covered" >{</span>value:i,distance:(0,cu.default)(e,i)}));<span class="cstat-no" title="statement not covered" >t</span></span>.sort(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i.distance&lt;o.distance?-1:1);l</span></span>et n=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>return n.distance&lt;3?n.value:null}</span>function <span class="fstat-no" title="function not covered" >Mf(e</span>,r){<span class="cstat-no" title="statement not covered" >return uu(r.models,e)??uu(r.types,e)}</span>function <span class="fstat-no" title="function not covered" >uu(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >Object.keys(e).find(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >Y</span>e(n)===r);<span class="cstat-no" title="statement not covered" >i</span></span>f(t)<span class="cstat-no" title="statement not covered" >return e[t]}f</span></span>unction <span class="fstat-no" title="function not covered" >$f(e</span>,r){let t=<span class="cstat-no" title="statement not covered" >Nr(e);<span class="cstat-no" title="statement not covered" >f</span>or(let o of r)<span class="cstat-no" title="statement not covered" >switch(o.kind){case"UnknownModel":<span class="cstat-no" title="statement not covered" >t.arguments.getField(o.modelKey)?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Unknown model name: ${o.modelKey}.`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownField":<span class="cstat-no" title="statement not covered" >t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Model "${o.modelKey}" does not have a field named "${o.fieldName}".`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RelationInOmit":<span class="cstat-no" title="statement not covered" >t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >'</span>Relations are already excluded by default and can not be specified in "omit".');<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"InvalidFieldValue":<span class="cstat-no" title="statement not covered" >t.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>Omit field option value must be a boolean.");<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>l</span></span>et{message:n,args:i}=<span class="cstat-no" title="statement not covered" >On(t,"colorless");<span class="cstat-no" title="statement not covered" >r</span>eturn`Error validating "omit" option:</span>
&nbsp;
${i}
&nbsp;
${n}`}function du(e){return e.length===0?<span class="branch-0 cbranch-no" title="branch not covered" >Promise.resolve([]):n</span>ew Promise((r,t)=&gt;{let n=new Array(e.length),i=null,o=!1,s=0,a=()=&gt;{o||(s++,s===e.length&amp;&amp;(o=!0,i?<span class="branch-0 cbranch-no" title="branch not covered" >t(i):r</span>(n)))},l=<span class="fstat-no" title="function not covered" >u=&gt;{<span class="cstat-no" title="statement not covered" >o</span>||(o=!0,t(u))}</span>;for(let u=0;u&lt;e.length;u++)e[u].then(c=&gt;{n[u]=c,a()},<span class="fstat-no" title="function not covered" >c=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(!Zn(c)){<span class="cstat-no" title="statement not covered" >l(c);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>c</span>.batchRequestIdx===u?l(c):(i||(i=c),a())}</span>)})}var rr=N("prisma:client");typeof globalThis=="object"&amp;&amp;(globalThis.NODE_CLIENT=!0);var qf={requestArgsToMiddlewareArgs:e=&gt;e,middlewareArgsToRequestArgs:e=&gt;e},jf=Symbol.for("prisma.client.transaction.id"),Vf={id:0,nextId(){return++this.id}};function bu(e){class r{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_middlewares=new zn;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=Co();constructor(n){e=n?.__internal?.configOverride?.(e)??e,pl(e),n&amp;&amp;pu(n,e);let i=new hu.EventEmitter().on("error",()=&gt;{});this._extensions=Lr.empty(),this._previewFeatures=Yn(e),this._clientVersion=e.clientVersion??<span class="branch-1 cbranch-no" title="branch not covered" >ou,t</span>his._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=Zl();let o=e.relativeEnvPaths&amp;&amp;{rootEnvPath:e.relativeEnvPaths.rootEnvPath&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >ti.default.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),s</span>chemaEnvPath:e.relativeEnvPaths.schemaEnvPath&amp;&amp;ti.default.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;<span class="missing-if-branch" title="if path not taken" >I</span>if(n?.adapter){<span class="cstat-no" title="statement not covered" >s=n.adapter;l</span>et l=<span class="cstat-no" title="statement not covered" >e.activeProvider==="postgresql"||e.activeProvider==="cockroachdb"?"postgres":e.activeProvider;<span class="cstat-no" title="statement not covered" ></span>if(s.provider!==l)<span class="cstat-no" title="statement not covered" >throw new T(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(n.datasources||n.datasourceUrl!==void 0)<span class="cstat-no" title="statement not covered" >throw new T("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}</span></span>let a=!s&amp;&amp;o&amp;&amp;st(o,{conflictCheck:"none"})||<span class="branch-3 cbranch-no" title="branch not covered" >e.injectableEdgeEnv?.();t</span>ry{let l=n??<span class="branch-1 cbranch-no" title="branch not covered" >{},u</span>=l.__internal??{},c=u.debug===!0;c&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >N.enable("prisma:client");l</span>et p=ti.default.resolve(e.dirname,e.relativePath);yu.default.existsSync(p)||(<span class="branch-1 cbranch-no" title="branch not covered" >p=e.dirname)</span>,rr("dirname",e.dirname),rr("relativePath",e.relativePath),rr("cwd",p);let d=u.engine||{};<span class="missing-if-branch" title="else path not taken" >E</span>if(l.errorFormat?<span class="branch-0 cbranch-no" title="branch not covered" >this._errorFormat=l.errorFormat:</span>process.env.NODE_ENV==="production"?<span class="branch-0 cbranch-no" title="branch not covered" >this._errorFormat="minimal":p</span>rocess.env.NO_COLOR?<span class="branch-0 cbranch-no" title="branch not covered" >this._errorFormat="colorless":t</span>his._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:p,dirname:e.dirname,enableDebugLogs:c,allowTriggerPanic:d.allowTriggerPanic,prismaPath:d.binaryPath??void 0,engineEndpoint:d.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&amp;&amp;eu(l.log),logQueries:l.log&amp;&amp;!!(typeof l.log=="string"?<span class="branch-0 cbranch-no" title="branch not covered" >l.log==="query":l</span>.log.find(f=&gt;typeof f=="string"?f==="query":<span class="branch-1 cbranch-no" title="branch not covered" >f.level==="query")</span>),env:a?.parsed??<span class="branch-1 cbranch-no" title="branch not covered" >{},f</span>lags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:dl(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:Vr,getBatchRequestPayload:$r,prismaGraphQLToJSError:qr,PrismaClientUnknownRequestError:j,PrismaClientInitializationError:T,PrismaClientKnownRequestError:z,debug:N("prisma:client:accelerateEngine"),engineVersion:fu.version,clientVersion:e.clientVersion}},rr("clientVersion",e.clientVersion),this._engine=Vl(e,this._engineConfig),this._requestHandler=new ri(this,i),l.log)for(let f of l.log){let h=typeof f=="string"?f:<span class="branch-1 cbranch-no" title="branch not covered" >f.emit==="stdout"?f.level:null;h</span>&amp;&amp;this.$on(h,g=&gt;{nt.log(`${nt.tags[h]??<span class="branch-1 cbranch-no" title="branch not covered" >""}`,</span>g.message||<span class="branch-1 cbranch-no" title="branch not covered" >g.query)</span>})}}catch(l){<span class="cstat-no" title="statement not covered" >throw l.clientVersion=this._clientVersion,l}</span>return this._appliedParent=Pt(this)}<span class="fstat-no" title="function not covered" >get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClient"}<span class="fstat-no" title="function not covered" ></span>$use(n</span>){<span class="cstat-no" title="statement not covered" >this._middlewares.use(n)}</span>$on(n,i){return n==="beforeExit"?<span class="branch-0 cbranch-no" title="branch not covered" >this._engine.onBeforeExit(i):n</span>&amp;&amp;this._engineConfig.logEmitter.on(n,i),this}$connect(){try{return this._engine.start()}catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>}async $disconnect(){try{await this._engine.stop()}catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>finally{Qo()}}<span class="fstat-no" title="function not covered" >$executeRawInternal(n</span>,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:Ao({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$executeRaw(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(n.raw!==void 0||n.sql!==void 0){let[s,a]=<span class="cstat-no" title="statement not covered" >mu(n,i);<span class="cstat-no" title="statement not covered" >r</span>eturn Ro(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`&lt;SQL&gt;`":"prisma.$executeRaw(sql`&lt;SQL&gt;`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new Z("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$executeRawUnsafe(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;(<span class="cstat-no" title="statement not covered" >R</span>o(this._activeProvider,n,i,"prisma.$executeRawUnsafe(&lt;SQL&gt;, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}<span class="fstat-no" title="function not covered" ></span></span>$runCommandRaw(n</span>){<span class="cstat-no" title="statement not covered" >if(e.activeProvider!=="mongodb")<span class="cstat-no" title="statement not covered" >throw new Z(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:Bl,callsite:Ze(this._errorFormat),transaction:i}))}<span class="fstat-no" title="function not covered" ></span></span>async $</span>queryRawInternal(n,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:Ao({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$queryRaw(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(n.raw!==void 0||n.sql!==void 0)<span class="cstat-no" title="statement not covered" >return this.$queryRawInternal(o,"$queryRaw",...mu(n,i));<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Z("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$queryRawTyped(n</span>){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(!this._hasPreviewFlag("typedSql"))<span class="cstat-no" title="statement not covered" >throw new Z("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.$queryRawInternal(i,"$queryRawTyped",n)}</span>)}<span class="fstat-no" title="function not covered" ></span>$queryRawUnsafe(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}</span></span>_transactionWithArray({promises:n,options:i}){let o=Vf.nextId(),s=Xl(n.length),a=n.map((l,u)=&gt;{<span class="missing-if-branch" title="if path not taken" >I</span>if(l?.[Symbol.toStringTag]!=="PrismaPromise")<span class="cstat-no" title="statement not covered" >throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");l</span>et c=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,p={kind:"batch",id:o,index:u,isolationLevel:c,lock:s};return l.requestTransaction?.(p)??<span class="branch-1 cbranch-no" title="branch not covered" >l}</span>);return du(a)}async _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let u={kind:"itx",...a};l=await n(this._createItxClient(u)),await this._engine.transaction("commit",o,a)}catch(u){throw await this._engine.transaction("rollback",o,a).catch(<span class="fstat-no" title="function not covered" >()=&gt;{}</span>),u}return l}_createItxClient(n){return he(Pt(he(Ya(this),[re("_appliedParent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._appliedParent._createItxClient(n)),r</span>e("_createPrismaPromise",()=&gt;Co(n)),re(jf,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>.id)</span>])),[Mr(rl)])}$transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?<span class="branch-0 cbranch-no" title="branch not covered" >o=<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>hrow new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}</span>:o</span>=()=&gt;this._transactionWithCallback({callback:n,options:i}):o=()=&gt;this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??qf,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:<span class="branch-1 cbranch-no" title="branch not covered" >o.action}</span>}},a=-1,l=async u=&gt;{let c=this._middlewares.get(++a);<span class="missing-if-branch" title="if path not taken" >I</span>if(c)<span class="cstat-no" title="statement not covered" >return this._tracingHelper.runInChildSpan(s.middleware,<span class="fstat-no" title="function not covered" >S=&gt;<span class="cstat-no" title="statement not covered" >c</span>(u,<span class="fstat-no" title="function not covered" >P=&gt;(<span class="cstat-no" title="statement not covered" >S</span>?.end(),l(P)</span>)));l</span></span>et{runInTransaction:p,args:d,...f}=u,h={...n,...f};d&amp;&amp;(h.args=i.middlewareArgsToRequestArgs(d)),n.transaction!==void 0&amp;&amp;p===!1&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >delete h.transaction;</span>let g=await ol(this,h);return h.model?el({result:g,modelName:h.model,args:h.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):<span class="branch-1 cbranch-no" title="branch not covered" >g}</span>;return this._tracingHelper.runInChildSpan(s.operation,()=&gt;new gu.AsyncResource("prisma-client-request").runInAsyncScope(()=&gt;l(o)))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:u,transaction:c,unpacker:p,otelParentCtx:d,customDataProxyFetch:f}){try{n=u?u(n):n;let h={name:"serialize"},g=this._tracingHelper.runInChildSpan(h,()=&gt;Mn({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return N.enabled("prisma:client")&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >rr("Prisma Client call:"),rr(`prisma.${i}(${qa(n)})`),rr("Generated request:"),rr(JSON.stringify(g,null,2)+`</span>
`)),c?.kind==="batch"&amp;&amp;await c.lock,this._requestHandler.request({protocolQuery:g,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:c,unpacker:p,otelParentCtx:d,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:f})}catch(h){<span class="cstat-no" title="statement not covered" >throw h.clientVersion=this._clientVersion,h}</span>}$metrics=new Fr(this);<span class="fstat-no" title="function not covered" >_hasPreviewFlag(n</span>){<span class="cstat-no" title="statement not covered" >return!!this._engineConfig.previewFeatures?.includes(n)}<span class="fstat-no" title="function not covered" ></span>$applyPendingMigrations(){<span class="cstat-no" title="statement not covered" ></span>return this._engine.applyPendingMigrations()}</span>$extends=za}return r}function <span class="fstat-no" title="function not covered" >mu(e</span>,r){<span class="cstat-no" title="statement not covered" >return Bf(e)?[new oe(e,r),Kl]:[e,Yl]}f</span>unction <span class="fstat-no" title="function not covered" >Bf(e</span>){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)&amp;&amp;Array.isArray(e.raw)}</span>var Uf=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function Eu(e){return new Proxy(e,{<span class="fstat-no" title="function not covered" >get(r</span>,t){<span class="cstat-no" title="statement not covered" >if(t in r)<span class="cstat-no" title="statement not covered" >return r[t];<span class="cstat-no" title="statement not covered" >i</span></span>f(!Uf.has(t))<span class="cstat-no" title="statement not covered" >throw new TypeError(`Invalid enum value: ${String(t)}`)}</span></span>})}function wu(e){st(e,{conflictCheck:"warn"})}0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});</span>
/*! Bundled license information:
&nbsp;
decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin &lt;M8ch88l@gmail.com&gt;
   *  MIT Licence
   *)
*/
//# sourceMappingURL=library.js.map
&nbsp;</pre></td></tr></table></pre>

      <div class="push"></div>
      <!-- for sticky footer -->
    </div>
    <!-- /wrapper -->
    <div class="footer quiet pad2 space-top1 center small">
      Code coverage generated by
      <a
        href="https://istanbul.js.org/"
        target="_blank"
        rel="noopener noreferrer"
        >istanbul</a
      >
      at 2025-08-20T10:17:55.948Z
    </div>
    <script src="../../../../prettify.js"></script>
    <script>
      window.onload = function () {
        prettyPrint();
      };
    </script>
    <script src="../../../../sorter.js"></script>
    <script src="../../../../block-navigation.js"></script>
  </body>
</html>
